# Функциональный парсер для C51 (AT89S4051)

## Обзор

Этот парсер представляет собой современную функциональную реализацию синтаксического анализатора для языка C51, предназначенного для микроконтроллера AT89S4051. Парсер использует принципы функционального программирования и монадические комбинаторы для построения абстрактного синтаксического дерева (AST) из потока токенов.

## Архитектура

### Монадические комбинаторы

Парсер построен на основе монадических комбинаторов, что обеспечивает:

- **Композиционность**: Простые парсеры легко комбинируются в сложные
- **Читаемость**: Код парсера близок к грамматике языка
- **Обработка ошибок**: Элегантная обработка синтаксических ошибок
- **Функциональность**: Отсутствие побочных эффектов

### Основные компоненты

1. **ParseState** - Состояние парсера (токены + позиция)
2. **ParseResult** - Результат парсинга (успех/неудача + значение + новое состояние)
3. **Базовые комбинаторы** - `choice`, `many`, `optional`, `bind`
4. **Специализированные парсеры** - для выражений, операторов, деклараций

## Поддерживаемые конструкции языка

### Типы данных
- `void`, `int`, `char`
- Модификаторы: `signed`, `unsigned`

### Выражения
- Арифметические: `+`, `-`, `*`, `/`, `%`
- Логические: `&&`, `||`, `!`
- Битовые: `&`, `|`, `^`, `~`
- Сравнения: `<`, `>`, `<=`, `>=`, `==`, `!=`
- Присваивания: `=`, `&=`, `|=`, `^=`
- Унарные: `+`, `-`, `!`, `~`, `++`, `--`
- Вызовы функций: `func(args)`
- Индексация массивов: `arr[index]`

### Операторы
- Блоки: `{ statements }`
- Условные: `if (condition) statement [else statement]`
- Циклы: `while (condition) statement`, `for (init; condition; update) statement`
- Возврат: `return [expression];`
- Выражения: `expression;`

### Объявления
- Переменные: `type name [= initializer];`
- Функции: `type name(parameters) { body }`

## Приоритет операторов

Парсер корректно обрабатывает приоритет операторов согласно стандарту C:

1. Постфиксные: `()`, `[]`
2. Унарные: `!`, `~`, `+`, `-`, `++`, `--`
3. Мультипликативные: `*`, `/`, `%`
4. Аддитивные: `+`, `-`
5. Реляционные: `<`, `>`, `<=`, `>=`
6. Равенство: `==`, `!=`
7. Логическое И: `&&`
8. Логическое ИЛИ: `||`
9. Присваивание: `=`, `&=`, `|=`, `^=`

## Структура AST

AST представляет собой иерархию узлов, каждый из которых содержит:
- `:ast-type` - тип узла
- Специфичные для типа атрибуты

### Типы узлов

- `:program` - корневой узел программы
- `:function-declaration` - объявление функции
- `:variable-declaration` - объявление переменной
- `:block-statement` - блок операторов
- `:if-statement` - условный оператор
- `:while-statement` - цикл while
- `:for-statement` - цикл for
- `:return-statement` - оператор return
- `:expression-statement` - оператор-выражение
- `:binary-expression` - бинарное выражение
- `:unary-expression` - унарное выражение
- `:assignment-expression` - выражение присваивания
- `:call-expression` - вызов функции
- `:identifier` - идентификатор
- `:literal` - литерал

## Использование

### Базовое использование

```clojure
(require '[c51cc.parser :as parser]
         '[c51cc.lexer :as lexer])

;; Парсинг простой программы
(let [code "int main() { return 0; }"
      tokens (lexer/tokenize code)
      result (parser/parse tokens)]
  (if (:success result)
    (println "AST:" (:ast result))
    (println "Ошибка:" (:error result))))
```

### Работа с AST

```clojure
;; Красивая печать AST
(parser/pretty-print-ast ast)

;; Валидация AST
(parser/validate-ast ast)
```

### Обработка ошибок

```clojure
(let [result (parser/parse tokens)]
  (if (:success result)
    {:ast (:ast result)
     :remaining-tokens (:remaining-tokens result)}
    {:error (:error result)
     :position (:position result)}))
```

## Примеры

### Простая функция

```c
int add(int a, int b) {
    return a + b;
}
```

### Условные операторы

```c
void test() {
    if (x > 0) {
        return x;
    } else {
        return 0;
    }
}
```

### Циклы

```c
void loop() {
    int i;
    for (i = 0; i < 10; i = i + 1) {
        x = x + i;
    }
    
    while (x > 0) {
        x = x - 1;
    }
}
```

## Тестирование

Запуск тестов:

```clojure
(require '[c51cc.parser-test :as test])
(test/run-parser-tests)
```

Демонстрация:

```clojure
(test/demo-parser)
```

## Особенности реализации

### Функциональный подход

- **Иммутабельность**: Все структуры данных неизменяемы
- **Чистые функции**: Отсутствие побочных эффектов
- **Композиция**: Сложные парсеры строятся из простых

### Обработка ошибок

- **Детальные сообщения**: Точное указание места и типа ошибки
- **Восстановление**: Возможность продолжения парсинга после ошибки
- **Контекст**: Сохранение информации о состоянии парсера

### Производительность

- **Ленивые вычисления**: Парсинг по требованию
- **Оптимизация хвостовой рекурсии**: Эффективная обработка больших файлов
- **Минимальное копирование**: Переиспользование структур данных

## Расширение

Парсер легко расширяется для поддержки новых конструкций языка:

1. Добавить новые токены в лексер
2. Создать соответствующие узлы AST
3. Реализовать парсеры для новых конструкций
4. Интегрировать в существующую грамматику

## Ограничения

- Поддерживается подмножество языка C, специфичное для AT89S4051
- Отсутствует поддержка препроцессора
- Ограниченная поддержка указателей и структур
- Нет оптимизации AST

## Заключение

Данный парсер представляет собой современную, функциональную реализацию синтаксического анализатора для C51. Он демонстрирует преимущества функционального подхода к построению компиляторов и может служить основой для дальнейшего развития компилятора C51. 