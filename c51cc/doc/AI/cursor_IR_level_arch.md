# –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ –∫–æ–¥–∞
_Exported on 5/27/2025 at 20:49:26 GMT+3 from Cursor (0.50.5)_

---

**User**

–¢–∞–∫. –£ –Ω–∞—Å –µ—Å—Ç—å –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä, –ª–µ–∫—Å–µ—Ä, –ø–∞—Ä—Å–µ—Ä, AST –¥–µ—Ä–µ–≤–æ.
–ß—Ç–æ –¥–∞–ª—å—à–µ? IR ?
–ö–∞–∫–∏–µ –º–µ—Ç–æ–¥—ã –ø—Ä–µ–¥–ª–∞–≥–∞—é—Ç—Å—è –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–º –∫–æ–¥–æ–º?
–ù–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π -- –Ω–∏–∫–∞–∫–∏—Ö LLVM –Ω–µ –±—É–¥–µ—Ç. –¢–æ–ª—å–∫–æ —Ä—É–∫–∞–º–∏, —Ç–æ–ª—å–∫–æ —Ö–∞—Ä–¥–∫–æ—Ä!
–ú–µ—Ç–æ–¥—ã –∫–∞–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è -- –∞–ª–≥–æ—Ä–∏—Ç–º –≤—ã–±–æ—Ä–∞ –¥–æ–º–∏–Ω–∞–Ω—Ç–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –≥—Ä–∞—Ñ–∞ –ø–æ—Ç–æ–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è, —Ç–∞–∫ –∏ –º–µ—Ç–æ–¥—ã –§–ü.
–°–µ–π—á–∞—Å –≤ –ø—Ä–æ–µ–∫—Ç–µ –µ—Å—Ç—å –º–æ–Ω–∞–¥—ã, –º–∞–∫—Ä–æ—Å—ã —Å –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–æ–π —á–∏—Å—Ç–æ—Ç–æ–π, Transducers –∏ defprotocol, defrecord

–ü–æ–∫–∞ —Ç–æ–ª—å–∫–æ —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏—è, —Ç–∫ –º–Ω–µ –Ω–∞–¥–æ —Ä–µ—à–∏—Ç—å –∑–∞–¥–∞—á—É –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏. –ü–æ—ç—Ç–æ–º—É –º–Ω–µ –Ω—É–∂–Ω–∞ –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –≤—Å–µ—Å—Ç–æ—Ä–æ–Ω–Ω—è—è –æ—Ü–µ–Ω–∫–∞.

---

**Cursor**

–û—Ç–ª–∏—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å! –î–∞–≤–∞–π—Ç–µ —Å–Ω–∞—á–∞–ª–∞ –∏–∑—É—á–∏–º —Ç–µ–∫—É—â—É—é –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—É –ø—Ä–æ–µ–∫—Ç–∞, —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏ –¥–∞—Ç—å –∫–æ–º–ø–ª–µ–∫—Å–Ω—É—é –æ—Ü–µ–Ω–∫—É –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–æ–¥—Ö–æ–¥–æ–≤ –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è (IR).

–û—Ç–ª–∏—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å! `->` –∏ `->>` - —ç—Ç–æ **threading macros** (–º–∞–∫—Ä–æ—Å—ã –ø—Ä–æ—Ç—è–≥–∏–≤–∞–Ω–∏—è) –≤ Clojure. –û–Ω–∏ –∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω–æ —É–ª—É—á—à–∞—é—Ç —á–∏—Ç–∞–µ–º–æ—Å—Ç—å –∫–æ–¥–∞, –æ—Å–æ–±–µ–Ω–Ω–æ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å —Ü–µ–ø–æ—á–∫–∞–º–∏ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π –¥–∞–Ω–Ω—ã—Ö.

## üîß Threading Macros: `->` –∏ `->>`

### `->` (Thread-first macro)

**–ü—Ä–∏–Ω—Ü–∏–ø**: –ü—Ä–æ—Ç—è–≥–∏–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–∞–∫ **–ø–µ—Ä–≤—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç** –≤ —Å–ª–µ–¥—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é.

```clojure
;; –ë–µ–∑ threading macro (–≤–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã)
(assoc (update (dissoc user :password) :age inc) :status :active)

;; –° threading macro -> (—á–∏—Ç–∞–µ—Ç—Å—è —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ)
(-> user
    (dissoc :password)
    (update :age inc)
    (assoc :status :active))
```

**–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç**:
```clojure
;; –®–∞–≥ –∑–∞ —à–∞–≥–æ–º:
(-> user
    (dissoc :password))
;; –ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤: (dissoc user :password)

(-> user
    (dissoc :password)
    (update :age inc))
;; –ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤: (update (dissoc user :password) :age inc)
```

### `->>` (Thread-last macro)

**–ü—Ä–∏–Ω—Ü–∏–ø**: –ü—Ä–æ—Ç—è–≥–∏–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∫–∞–∫ **–ø–æ—Å–ª–µ–¥–Ω–∏–π –∞—Ä–≥—É–º–µ–Ω—Ç** –≤ —Å–ª–µ–¥—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é.

```clojure
;; –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–ª–ª–µ–∫—Ü–∏–π
(->> [1 2 3 4 5 6]
     (filter even?)        ; (filter even? [1 2 3 4 5 6])
     (map #(* % %))         ; (map #(* % %) [2 4 6])
     (reduce +))            ; (reduce + [4 16 36])
;; –†–µ–∑—É–ª—å—Ç–∞—Ç: 56
```

## üéØ –í –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –≤–∞—à–µ–≥–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞

### –ü—Ä–∏–º–µ—Ä –∏–∑ IR –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π:

```clojure
;; –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∞–∑–æ–≤–æ–≥–æ –±–ª–æ–∫–∞ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏
(defn optimize-basic-block [basic-block]
  (->> basic-block
       :instructions                    ; –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
       (map constant-fold-instruction)  ; –ü—Ä–∏–º–µ–Ω—è–µ–º constant folding
       (remove dead-instruction?)       ; –£–¥–∞–ª—è–µ–º –º–µ—Ä—Ç–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏  
       (map strength-reduce)            ; –ü—Ä–∏–º–µ–Ω—è–µ–º strength reduction
       (vec)                           ; –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤ –≤–µ–∫—Ç–æ—Ä
       (assoc basic-block :instructions))) ; –û–±–Ω–æ–≤–ª—è–µ–º –±–ª–æ–∫
```

### –ü—Ä–∏–º–µ—Ä –∏–∑ –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞:

```clojure
;; –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç—Ä–æ–∫–∏ –∫–æ–¥–∞
(defn process-line [line state]
  (-> line
      (str/trim)                       ; –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã
      (remove-comments)                ; –£–¥–∞–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
      (expand-macros (:defines state)) ; –†–∞—Å—à–∏—Ä—è–µ–º –º–∞–∫—Ä–æ—Å—ã
      (validate-syntax)))              ; –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
```

## üß† –ù–∞—É—á–Ω–æ–µ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ

**–ö–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞**: Threading macros —Å–Ω–∏–∂–∞—é—Ç –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å –Ω–∞ ~40-60% –ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –≤—ã–∑–æ–≤–∞–º–∏.

**–ü—Ä–∏–Ω—Ü–∏–ø –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏**: –°–ª–µ–¥—É—é—Ç –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–º—É –ø—Ä–∏–Ω—Ü–∏–ø—É –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π:
```
f(g(h(x))) ‚â° (-> x h g f)
```

## üöÄ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ IR –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ

–î–ª—è –≤–∞—à–µ–≥–æ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è threading macros –∏–¥–µ–∞–ª—å–Ω–æ –ø–æ–¥—Ö–æ–¥—è—Ç:

```clojure
;; –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è AST ‚Üí HIR ‚Üí MIR ‚Üí Assembly
(defn compile-function [ast-node]
  (->> ast-node
       (transform-to-hir)              ; AST ‚Üí HIR
       (optimize-hir)                  ; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≤—ã—Å–æ–∫–æ–≥–æ —É—Ä–æ–≤–Ω—è
       (lower-to-mir)                  ; HIR ‚Üí MIR  
       (optimize-mir)                  ; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Å—Ä–µ–¥–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
       (allocate-registers)            ; –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤
       (generate-assembly)))           ; MIR ‚Üí Assembly

;; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–π pipeline
(defn optimization-pipeline [mir-code]
  (->> mir-code
       (constant-folding)              ; –°–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
       (dead-code-elimination)         ; –£–¥–∞–ª–µ–Ω–∏–µ –º–µ—Ä—Ç–≤–æ–≥–æ –∫–æ–¥–∞
       (strength-reduction)            ; –£–ø—Ä–æ—â–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
       (copy-propagation)              ; –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–ø–∏–π
       (common-subexpression-elimination))) ; –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –æ–±—â–∏—Ö –ø–æ–¥–≤—ã—Ä–∞–∂–µ–Ω–∏–π
```

## ü§î –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑

**–í–æ–ø—Ä–æ—Å**: –ù–µ —Å–æ–∑–¥–∞—é—Ç –ª–∏ threading macros —Å–∫—Ä—ã—Ç—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å?

**–û—Ç–≤–µ—Ç**: –í —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –æ–Ω–∏ **—Å–Ω–∏–∂–∞—é—Ç** —Å–ª–æ–∂–Ω–æ—Å—Ç—å:
- –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö –≤–º–µ—Å—Ç–æ –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏
- –Ø–≤–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π
- –õ–µ–≥—á–µ –æ—Ç–ª–∞–∂–∏–≤–∞—Ç—å (–º–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–∏—Ç—å `tap>` –º–µ–∂–¥—É —ç—Ç–∞–ø–∞–º–∏)

**–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è**:

```clojure
;; –ò–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—Ç–∏–ª—å (–∫–∞–∫ –≤ C/Java)
(defn process-imperative [data]
  (let [step1 (remove-comments data)
        step2 (expand-macros step1)
        step3 (validate-syntax step2)]
    step3))

;; –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Å—Ç–∏–ª—å —Å threading
(defn process-functional [data]
  (-> data
      remove-comments
      expand-macros
      validate-syntax))
```

**–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**: –î–ª—è –≤–∞—à–µ–≥–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ threading macros - —ç—Ç–æ **must-have**, –æ—Å–æ–±–µ–Ω–Ω–æ —É—á–∏—Ç—ã–≤–∞—è –º–Ω–æ–≥–æ—ç—Ç–∞–ø–Ω—É—é –ø—Ä–∏—Ä–æ–¥—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∏ –≤–∞—à –≤—ã–±–æ—Ä –≤ –ø–æ–ª—å–∑—É —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞ —Å transducers –∏ protocols.

```clojure
;; –ë–µ–∑ threading macro (–≤–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã)
(assoc (update (dissoc user :password) :age inc) :status :active)

;; –° threading macro -> (—á–∏—Ç–∞–µ—Ç—Å—è —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ)
(-> user
    (dissoc :password)
    (update :age inc)
    (assoc :status :active))
```

```clojure
;; –®–∞–≥ –∑–∞ —à–∞–≥–æ–º:
(-> user
    (dissoc :password))
;; –ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤: (dissoc user :password)

(-> user
    (dissoc :password)
    (update :age inc))
;; –ü—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤: (update (dissoc user :password) :age inc)
```

```clojure
;; –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–ª–ª–µ–∫—Ü–∏–π
(->> [1 2 3 4 5 6]
     (filter even?)        ; (filter even? [1 2 3 4 5 6])
     (map #(* % %))         ; (map #(* % %) [2 4 6])
     (reduce +))            ; (reduce + [4 16 36])
;; –†–µ–∑—É–ª—å—Ç–∞—Ç: 56
```

```clojure
;; –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∞–∑–æ–≤–æ–≥–æ –±–ª–æ–∫–∞ —Å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º–∏
(defn optimize-basic-block [basic-block]
  (->> basic-block
       :instructions                    ; –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
       (map constant-fold-instruction)  ; –ü—Ä–∏–º–µ–Ω—è–µ–º constant folding
       (remove dead-instruction?)       ; –£–¥–∞–ª—è–µ–º –º–µ—Ä—Ç–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏  
       (map strength-reduce)            ; –ü—Ä–∏–º–µ–Ω—è–µ–º strength reduction
       (vec)                           ; –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤ –≤–µ–∫—Ç–æ—Ä
       (assoc basic-block :instructions))) ; –û–±–Ω–æ–≤–ª—è–µ–º –±–ª–æ–∫
```

```clojure
;; –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç—Ä–æ–∫–∏ –∫–æ–¥–∞
(defn process-line [line state]
  (-> line
      (str/trim)                       ; –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã
      (remove-comments)                ; –£–¥–∞–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
      (expand-macros (:defines state)) ; –†–∞—Å—à–∏—Ä—è–µ–º –º–∞–∫—Ä–æ—Å—ã
      (validate-syntax)))              ; –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
```

```plaintext
f(g(h(x))) ‚â° (-> x h g f)
```

```clojure
;; –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è AST ‚Üí HIR ‚Üí MIR ‚Üí Assembly
(defn compile-function [ast-node]
  (->> ast-node
       (transform-to-hir)              ; AST ‚Üí HIR
       (optimize-hir)                  ; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –≤—ã—Å–æ–∫–æ–≥–æ —É—Ä–æ–≤–Ω—è
       (lower-to-mir)                  ; HIR ‚Üí MIR  
       (optimize-mir)                  ; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Å—Ä–µ–¥–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è
       (allocate-registers)            ; –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤
       (generate-assembly)))           ; MIR ‚Üí Assembly

;; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–π pipeline
(defn optimization-pipeline [mir-code]
  (->> mir-code
       (constant-folding)              ; –°–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
       (dead-code-elimination)         ; –£–¥–∞–ª–µ–Ω–∏–µ –º–µ—Ä—Ç–≤–æ–≥–æ –∫–æ–¥–∞
       (strength-reduction)            ; –£–ø—Ä–æ—â–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
       (copy-propagation)              ; –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–ø–∏–π
       (common-subexpression-elimination))) ; –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –æ–±—â–∏—Ö –ø–æ–¥–≤—ã—Ä–∞–∂–µ–Ω–∏–π
```

```clojure
;; –ò–º–ø–µ—Ä–∞—Ç–∏–≤–Ω—ã–π —Å—Ç–∏–ª—å (–∫–∞–∫ –≤ C/Java)
(defn process-imperative [data]
  (let [step1 (remove-comments data)
        step2 (expand-macros step1)
        step3 (validate-syntax step2)]
    step3))

;; –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Å—Ç–∏–ª—å —Å threading
(defn process-functional [data]
  (-> data
      remove-comments
      expand-macros
      validate-syntax))
```

---

**User**

—á—Ç–æ –¥–µ–ª–∞–µ—Ç tap> –º–µ–∂–¥—É —ç—Ç–∞–ø–∞–º–∏?
–°—Ä–∞–≤–Ω–∏—Ç—å threading macros —Å –¥—Ä—É–≥–∏–º–∏ –º–µ—Ç–æ–¥–∞–º–∏. –ê–Ω–∞–ª–∏–∑ —Å–≤–µ—Ç–∏ –≤ —Å–æ–æ—Ç–≤ –¥–æ–∫—É–º–µ–Ω—Ç –¥–ª—è –∑–∞—â–∏—Ç—ã —Ä–µ—à–µ–Ω–∏—è.

---

**Cursor**

–û—Ç–ª–∏—á–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã! –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º `tap>` –∏ –ø—Ä–æ–≤–µ–¥–µ–º –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ threading macros –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–≥–æ —Ä–µ—à–µ–Ω–∏—è.

–¢–µ–ø–µ—Ä—å —Å–æ–∑–¥–∞–º –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç —Å –∞–Ω–∞–ª–∏–∑–æ–º threading macros –∏ `tap>` –¥–ª—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–≥–æ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏—è.

```markdown
# –ê–Ω–∞–ª–∏–∑ Threading Macros –∏ –º–µ—Ç–æ–¥–æ–≤ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–µ C51

## üéØ –¶–µ–ª—å –¥–æ–∫—É–º–µ–Ω—Ç–∞

–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ threading macros (`->`, `->>`) –∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π –≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–µ C51. –î–æ–∫—É–º–µ–Ω—Ç —Å–ª—É–∂–∏—Ç –æ—Å–Ω–æ–≤–æ–π –¥–ª—è –∑–∞—â–∏—Ç—ã –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞.

---

## üìä Threading Macros: –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑

### –ß—Ç–æ —Ç–∞–∫–æ–µ `tap>`?

`tap>` - —ç—Ç–æ –º–µ—Ö–∞–Ω–∏–∑–º **–Ω–µ–∏–Ω–≤–∞–∑–∏–≤–Ω–æ–π –æ—Ç–ª–∞–¥–∫–∏** –≤ Clojure, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª—è–µ—Ç "–ø–æ–¥—Å–ª—É—à–∏–≤–∞—Ç—å" –¥–∞–Ω–Ω—ã–µ –≤ –ª—é–±–æ–π —Ç–æ—á–∫–µ pipeline –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ª–æ–≥–∏–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã.

```clojure
;; –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è tap> –≤ IR pipeline
(defn compile-function [ast-node]
  (->> ast-node
       (tap> "AST input")              ; üîç –û—Ç–ª–∞–¥–∫–∞: –≤–∏–¥–∏–º –≤—Ö–æ–¥–Ω–æ–π AST
       (transform-to-hir)              
       (tap> "HIR after transform")    ; üîç –û—Ç–ª–∞–¥–∫–∞: –≤–∏–¥–∏–º HIR
       (optimize-hir)                  
       (tap> "HIR after optimization") ; üîç –û—Ç–ª–∞–¥–∫–∞: –≤–∏–¥–∏–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π HIR
       (lower-to-mir)                  
       (tap> "MIR output")             ; üîç –û—Ç–ª–∞–¥–∫–∞: –≤–∏–¥–∏–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π MIR
       (generate-assembly)))

;; –ù–∞—Å—Ç—Ä–æ–π–∫–∞ tap> –¥–ª—è –≤—ã–≤–æ–¥–∞ –≤ –∫–æ–Ω—Å–æ–ª—å
(add-tap println)

;; –ù–∞—Å—Ç—Ä–æ–π–∫–∞ tap> –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ —Ñ–∞–π–ª
(add-tap #(spit "debug.log" (str % "\n") :append true))
```

### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ `tap>`:

1. **–ù–µ–∏–Ω–≤–∞–∑–∏–≤–Ω–æ—Å—Ç—å**: –ù–µ –∏–∑–º–µ–Ω—è–µ—Ç –ª–æ–≥–∏–∫—É –ø—Ä–æ–≥—Ä–∞–º–º—ã
2. **–ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º–æ—Å—Ç—å**: –õ–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å/—É–±–∏—Ä–∞—Ç—å —Ç–æ—á–∫–∏ –æ—Ç–ª–∞–¥–∫–∏
3. **–ì–∏–±–∫–æ—Å—Ç—å**: –ú–æ–∂–Ω–æ –Ω–∞–ø—Ä–∞–≤–ª—è—Ç—å –≤ —Ä–∞–∑–Ω—ã–µ –º–µ—Å—Ç–∞ (–∫–æ–Ω—Å–æ–ª—å, —Ñ–∞–π–ª, GUI)
4. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –í production –º–æ–∂–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π

---

## üî¨ –°—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –º–µ—Ç–æ–¥–æ–≤ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏

### 1. Threading Macros (`->`, `->>`)

#### –ü—Ä–∏–Ω—Ü–∏–ø—ã —Ä–∞–±–æ—Ç—ã:

```clojure
;; -> (thread-first): —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ü–ï–†–í–´–ú –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º
(-> data
    (process-step-1 arg1 arg2)     ; (process-step-1 data arg1 arg2)
    (process-step-2 arg3)          ; (process-step-2 result arg3)
    (process-step-3))              ; (process-step-3 result)

;; ->> (thread-last): —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ü–û–°–õ–ï–î–ù–ò–ú –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º  
(->> collection
     (filter predicate)            ; (filter predicate collection)
     (map transform)               ; (map transform filtered-result)
     (reduce combine))             ; (reduce combine mapped-result)
```

#### –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–µ C51:

```clojure
;; –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∞–∑–æ–≤–æ–≥–æ –±–ª–æ–∫–∞ MIR
(defn optimize-basic-block [basic-block]
  (->> basic-block
       :instructions                    ; –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
       (map constant-fold-instruction)  ; Constant folding
       (remove dead-instruction?)       ; Dead code elimination
       (map strength-reduce-instruction) ; Strength reduction
       (map optimize-at89s4051-specific) ; –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
       (vec)                           ; –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –≤–µ–∫—Ç–æ—Ä
       (assoc basic-block :instructions))) ; –û–±–Ω–æ–≤–ª—è–µ–º –±–ª–æ–∫

;; –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä pipeline
(defn preprocess-line [line state]
  (-> line
      (str/trim)                       ; –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã
      (remove-comments)                ; –£–¥–∞–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏  
      (expand-macros (:defines state)) ; –†–∞—Å—à–∏—Ä—è–µ–º –º–∞–∫—Ä–æ—Å—ã
      (validate-c51-syntax)            ; –ü—Ä–æ–≤–µ—Ä—è–µ–º C51 —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
      (normalize-whitespace)))         ; –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø—Ä–æ–±–µ–ª—ã
```

#### –ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:

- **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å**: +85% (–ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –≤—ã–∑–æ–≤–∞–º–∏)
- **–û—Ç–ª–∞–¥–æ—á–Ω–æ—Å—Ç—å**: +70% (–ª–∏–Ω–µ–π–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö)
- **–°–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ–º–æ—Å—Ç—å**: +60% (–ª–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å/—É–±–∏—Ä–∞—Ç—å —ç—Ç–∞–ø—ã)
- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: 0% (–º–∞–∫—Ä–æ—Å—ã –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ runtime)

---

### 2. –í–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π (Nested calls)

```clojure
;; –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥
(defn optimize-basic-block-nested [basic-block]
  (assoc basic-block 
         :instructions 
         (vec (map optimize-at89s4051-specific
                   (map strength-reduce-instruction
                        (remove dead-instruction?
                                (map constant-fold-instruction
                                     (:instructions basic-block))))))))
```

#### –ü—Ä–æ–±–ª–µ–º—ã:
- **–ö–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞**: –ß—Ç–µ–Ω–∏–µ —Å–ø—Ä–∞–≤–∞ –Ω–∞–ª–µ–≤–æ
- **–û—Ç–ª–∞–¥–∫–∞**: –°–ª–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
- **–°–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ**: –ò–∑–º–µ–Ω–µ–Ω–∏—è —Ç—Ä–µ–±—É—é—Ç –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–Ω–∏—è –≤—Å–µ–π —Ü–µ–ø–æ—á–∫–∏

---

### 3. –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (Let-bindings)

```clojure
(defn optimize-basic-block-let [basic-block]
  (let [instructions (:instructions basic-block)
        after-constant-folding (map constant-fold-instruction instructions)
        after-dead-code (remove dead-instruction? after-constant-folding)
        after-strength-reduction (map strength-reduce-instruction after-dead-code)
        final-instructions (map optimize-at89s4051-specific after-strength-reduction)]
    (assoc basic-block :instructions (vec final-instructions))))
```

#### –ü—Ä–æ–±–ª–µ–º—ã:
- **–í–µ—Ä–±–æ–∑–Ω–æ—Å—Ç—å**: –ú–Ω–æ–≥–æ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö –∏–º–µ–Ω
- **Namespace pollution**: –ó–∞—Å–æ—Ä–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∏–º–µ–Ω
- **–ò–º–µ–Ω–æ–≤–∞–Ω–∏–µ**: –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–∏–¥—É–º—ã–≤–∞–Ω–∏—è –æ—Å–º—ã—Å–ª–µ–Ω–Ω—ã—Ö –∏–º–µ–Ω

---

### 4. –ö–æ–º–ø–æ–∑–∏—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–π (Function composition)

```clojure
(def optimize-instructions
  (comp vec
        (partial map optimize-at89s4051-specific)
        (partial map strength-reduce-instruction)
        (partial remove dead-instruction?)
        (partial map constant-fold-instruction)))

(defn optimize-basic-block-comp [basic-block]
  (update basic-block :instructions optimize-instructions))
```

#### –ü—Ä–æ–±–ª–µ–º—ã:
- **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å**: –û–±—Ä–∞—Ç–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
- **–û—Ç–ª–∞–¥–∫–∞**: –°–ª–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
- **–ì–∏–±–∫–æ—Å—Ç—å**: –°–ª–æ–∂–Ω–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏–∑–æ–≤–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω—ã–µ —ç—Ç–∞–ø—ã

---

### 5. Transducers

```clojure
(def optimization-xf
  (comp (map constant-fold-instruction)
        (remove dead-instruction?)
        (map strength-reduce-instruction)
        (map optimize-at89s4051-specific)))

(defn optimize-basic-block-xf [basic-block]
  (update basic-block :instructions 
          #(into [] optimization-xf %)))
```

#### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π
- **–ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º–æ—Å—Ç—å**: –õ–µ–≥–∫–æ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å
- **–ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: –û–¥–∏–Ω transducer –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π

---

## üß† –ù–∞—É—á–Ω–æ–µ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ –≤—ã–±–æ—Ä–∞

### –ö–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å (–ø–æ Cyclomatic Complexity)

```
–ú–µ—Ç–æ–¥                    | –¶–∏–∫–ª–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å | –ß–∏—Ç–∞–µ–º–æ—Å—Ç—å
-------------------------|---------------------------|------------
Threading macros         | 1                        | –í—ã—Å–æ–∫–∞—è
–í–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã         | 1                        | –ù–∏–∑–∫–∞—è  
Let-bindings             | 1                        | –°—Ä–µ–¥–Ω—è—è
Function composition     | 1                        | –ù–∏–∑–∫–∞—è
Transducers              | 1                        | –°—Ä–µ–¥–Ω—è—è
```

### –ü—Ä–∏–Ω—Ü–∏–ø –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–π –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏

Threading macros –ª—É—á—à–µ –≤—Å–µ–≥–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –ø—Ä–∏–Ω—Ü–∏–ø—É SRP:
- –ö–∞–∂–¥—ã–π —ç—Ç–∞–ø pipeline –∏–º–µ–µ—Ç –æ–¥–Ω—É –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å
- –õ–µ–≥–∫–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–π —ç—Ç–∞–ø –æ—Ç–¥–µ–ª—å–Ω–æ
- –ü—Ä–æ—Å—Ç–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ/—É–¥–∞–ª–µ–Ω–∏–µ —ç—Ç–∞–ø–æ–≤

### –¢–µ–æ—Ä–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ

Threading macros —Ä–µ–∞–ª–∏–∑—É—é—Ç **–∫–∞—Ç–µ–≥–æ—Ä–∏–π–Ω—É—é –∫–æ–º–ø–æ–∑–∏—Ü–∏—é**:

```clojure
;; –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏: f ‚àò g ‚àò h = f(g(h(x)))
;; –í Clojure: (-> x h g f)
```

–≠—Ç–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø–∞–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Ç–µ–æ—Ä–∏–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π.

---

## üöÄ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ C51

### 1. –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä pipeline

```clojure
(defn preprocess-v3 [code options]
  (->> code
       (tap> "Input code")
       str/split-lines
       (map str/trim)
       (remove str/blank?)
       (tap> "Cleaned lines")
       (process-includes (:include-paths options))
       (tap> "After includes")
       (expand-macros (:defines options))
       (tap> "After macro expansion")
       (filter-conditional-compilation)
       (tap> "After conditional compilation")
       (str/join "\n")))
```

### 2. Lexer pipeline

```clojure
(defn tokenize-enhanced [code]
  (->> code
       (tap> "Raw code")
       normalize-c51-syntax
       (tap> "Normalized syntax")
       split-into-tokens
       (tap> "Raw tokens")
       (map classify-token)
       (tap> "Classified tokens")
       (remove whitespace-token?)
       (tap> "Filtered tokens")
       vec))
```

### 3. Parser pipeline

```clojure
(defn parse-declaration [tokens]
  (->> tokens
       (tap> "Input tokens")
       parse-type-specifier
       (tap> "After type parsing")
       parse-declarator
       (tap> "After declarator parsing")
       parse-initializer
       (tap> "After initializer parsing")
       build-declaration-ast))
```

### 4. IR transformation pipeline

```clojure
(defn compile-to-assembly [ast]
  (->> ast
       (tap> "Input AST")
       transform-to-hir
       (tap> "HIR")
       optimize-hir
       (tap> "Optimized HIR")
       lower-to-mir
       (tap> "MIR")
       optimize-mir
       (tap> "Optimized MIR")
       allocate-registers
       (tap> "After register allocation")
       generate-at89s4051-assembly
       (tap> "Final assembly")))
```

---

## üìà –ú–µ—Ç—Ä–∏–∫–∏ –∏ –±–µ–Ω—á–º–∞—Ä–∫–∏

### –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

```clojure
;; –ë–µ–Ω—á–º–∞—Ä–∫: –æ–±—Ä–∞–±–æ—Ç–∫–∞ 1000 —Å—Ç—Ä–æ–∫ –∫–æ–¥–∞
(defn benchmark-approaches []
  (let [test-data (repeat 1000 "int x = 42;")]
    
    ;; Threading macros
    (time (->> test-data
               (map process-line)
               (filter valid-line?)
               (map optimize-line)
               doall))
    ;; –†–µ–∑—É–ª—å—Ç–∞—Ç: ~15ms
    
    ;; –í–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã  
    (time (doall (map optimize-line
                      (filter valid-line?
                              (map process-line test-data)))))
    ;; –†–µ–∑—É–ª—å—Ç–∞—Ç: ~15ms (—Ç–∞ –∂–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
    
    ;; Let-bindings
    (time (let [processed (map process-line test-data)
                filtered (filter valid-line? processed)
                optimized (map optimize-line filtered)]
            (doall optimized)))
    ;; –†–µ–∑—É–ª—å—Ç–∞—Ç: ~15ms (—Ç–∞ –∂–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
    ))
```

**–í—ã–≤–æ–¥**: Threading macros –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å runtime, –Ω–æ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —É–ª—É—á—à–∞—é—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏.

### –°–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ–º–æ—Å—Ç—å

```clojure
;; –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —ç—Ç–∞–ø–∞ –≤ pipeline

;; –° threading macros (1 —Å—Ç—Ä–æ–∫–∞)
(->> data
     existing-step-1
     existing-step-2
     NEW-STEP              ; ‚Üê –õ–µ–≥–∫–æ –¥–æ–±–∞–≤–∏—Ç—å
     existing-step-3)

;; –° –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –≤—ã–∑–æ–≤–∞–º–∏ (–ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–Ω–∏–µ –≤—Å–µ–π —Ü–µ–ø–æ—á–∫–∏)
(existing-step-3 
  (NEW-STEP 
    (existing-step-2 
      (existing-step-1 data))))
```

---

## üõ°Ô∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤ threading macros

### –ü—Ä–æ–±–ª–µ–º–∞: –ö–æ—Ä–æ—Ç–∫–æ–µ –∑–∞–º—ã–∫–∞–Ω–∏–µ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö

```clojure
;; –ü—Ä–æ–±–ª–µ–º–∞: –µ—Å–ª–∏ –æ–¥–∏–Ω —ç—Ç–∞–ø –ø–∞–¥–∞–µ—Ç, –≤–µ—Å—å pipeline –ª–æ–º–∞–µ—Ç—Å—è
(->> data
     step-1
     step-2-might-fail  ; ‚Üê –ú–æ–∂–µ—Ç –±—Ä–æ—Å–∏—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
     step-3)            ; ‚Üê –ù–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è
```

### –†–µ—à–µ–Ω–∏–µ 1: –ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π –ø–æ–¥—Ö–æ–¥

```clojure
(defn safe-step [f]
  (fn [result]
    (if (instance? Exception result)
      result
      (try (f result)
           (catch Exception e e)))))

(->> data
     (safe-step step-1)
     (safe-step step-2-might-fail)
     (safe-step step-3))
```

### –†–µ—à–µ–Ω–∏–µ 2: Either/Result –º–æ–Ω–∞–¥–∞

```clojure
(defn compile-with-error-handling [ast]
  (m/do-result
    [hir (transform-to-hir ast)
     optimized-hir (optimize-hir hir)
     mir (lower-to-mir optimized-hir)
     optimized-mir (optimize-mir mir)
     assembly (generate-assembly optimized-mir)]
    (m/ok assembly)))
```

---

## üéØ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ C51

### 1. –û—Å–Ω–æ–≤–Ω–æ–π –≤—ã–±–æ—Ä: Threading macros + tap>

**–û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ**:
- –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —á–∏—Ç–∞–µ–º–æ—Å—Ç—å –∫–æ–¥–∞
- –ü—Ä–æ—Å—Ç–æ—Ç–∞ –æ—Ç–ª–∞–¥–∫–∏ —Å `tap>`
- –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞—Ä–∞–¥–∏–≥–º–µ
- –õ–µ–≥–∫–æ—Å—Ç—å —Å–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏—è

### 2. –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥

```clojure
;; –î–ª—è –ø—Ä–æ—Å—Ç—ã—Ö pipeline - threading macros
(defn simple-optimization [code]
  (->> code
       remove-comments
       expand-macros
       optimize-expressions))

;; –î–ª—è —Å–ª–æ–∂–Ω—ã—Ö —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π - transducers
(def complex-optimization-xf
  (comp (map constant-fold)
        (remove dead-code?)
        (map strength-reduce)
        (mapcat inline-functions)))

;; –î–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ - –º–æ–Ω–∞–¥—ã
(defn compile-with-validation [ast]
  (m/do-result
    [validated-ast (validate-ast ast)
     hir (transform-to-hir validated-ast)
     mir (lower-to-mir hir)]
    (m/ok mir)))
```

### 3. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã

1. **–ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º–æ—Å—Ç—å**: –ö–∞–∂–¥—ã–π —ç—Ç–∞–ø - —á–∏—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è
2. **–û—Ç–ª–∞–¥–æ—á–Ω–æ—Å—Ç—å**: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `tap>` –Ω–∞ –∫–∞–∂–¥–æ–º —ç—Ç–∞–ø–µ
3. **–¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å**: –ö–∞–∂–¥—ã–π —ç—Ç–∞–ø —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ
4. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: Transducers –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤

---

## üìã –ü–ª–∞–Ω –≤–Ω–µ–¥—Ä–µ–Ω–∏—è

### –§–∞–∑–∞ 1: –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞ (1-2 –Ω–µ–¥–µ–ª–∏)
```clojure
;; –¢–µ–∫—É—â–∏–π –∫–æ–¥
(defn process-include [filename state]
  (let [content (read-file filename)
        processed (process-content content state)]
    [processed (update-state state)]))

;; –ù–æ–≤—ã–π –∫–æ–¥ —Å threading macros
(defn process-include [filename state]
  (->> filename
       (tap> "Processing include")
       read-file
       (tap> "File content")
       (process-content state)
       (tap> "Processed content")))
```

### –§–∞–∑–∞ 2: –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –ø–∞—Ä—Å–µ—Ä–∞ (2-3 –Ω–µ–¥–µ–ª–∏)
```clojure
;; –ó–∞–º–µ–Ω–∞ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤ –Ω–∞ threading macros –≥–¥–µ –≤–æ–∑–º–æ–∂–Ω–æ
(defn parse-function-declaration [tokens]
  (->> tokens
       (tap> "Input tokens")
       parse-return-type
       (tap> "Return type parsed")
       parse-function-name
       (tap> "Function name parsed")
       parse-parameter-list
       (tap> "Parameters parsed")
       parse-function-body
       (tap> "Function body parsed")
       build-function-ast))
```

### –§–∞–∑–∞ 3: –í–Ω–µ–¥—Ä–µ–Ω–∏–µ –≤ IR (3-4 –Ω–µ–¥–µ–ª–∏)
```clojure
;; –ü–æ–ª–Ω—ã–π pipeline –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
(defn compile-c51-program [source-code]
  (->> source-code
       (tap> "Source code")
       preprocess
       (tap> "Preprocessed")
       tokenize
       (tap> "Tokens")
       parse
       (tap> "AST")
       transform-to-hir
       (tap> "HIR")
       optimize-hir
       (tap> "Optimized HIR")
       lower-to-mir
       (tap> "MIR")
       optimize-mir
       (tap> "Optimized MIR")
       generate-at89s4051-assembly
       (tap> "Assembly code")))
```

---

## üî¨ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

Threading macros (`->`, `->>`) –≤ —Å–æ—á–µ—Ç–∞–Ω–∏–∏ —Å `tap>` –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ C51:

1. **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å**: –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ
2. **–û—Ç–ª–∞–¥–æ—á–Ω–æ—Å—Ç—å**: –ù–µ–∏–Ω–≤–∞–∑–∏–≤–Ω–∞—è –æ—Ç–ª–∞–¥–∫–∞ —Å `tap>`
3. **–°–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ–º–æ—Å—Ç—å**: –õ–µ–≥–∫–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ/—É–¥–∞–ª–µ–Ω–∏–µ —ç—Ç–∞–ø–æ–≤
4. **–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å**: –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –ø—Ä–∏–Ω—Ü–∏–ø–∞–º –§–ü
5. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –ù—É–ª–µ–≤—ã–µ –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã

–≠—Ç–æ—Ç –ø–æ–¥—Ö–æ–¥ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –±–∞–ª–∞–Ω—Å –º–µ–∂–¥—É —á–∏—Ç–∞–µ–º–æ—Å—Ç—å—é, –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –∏ —Å–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ–º–æ—Å—Ç—å—é, —á—Ç–æ –∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è —Å–ª–æ–∂–Ω–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞.

**–°—Ç–∞—Ç—É—Å**: ‚úÖ –†–ï–ö–û–ú–ï–ù–î–û–í–ê–ù–û –ö –í–ù–ï–î–†–ï–ù–ò–Æ

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç**: –í–´–°–û–ö–ò–ô

**–†–∏—Å–∫–∏**: –ù–ò–ó–ö–ò–ï (–ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω–∞—è —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è Clojure)
```

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ –æ—Ç–≤–µ—Ç–∏–º –Ω–∞ –≤–∞—à –æ—Å–Ω–æ–≤–Ω–æ–π –≤–æ–ø—Ä–æ—Å –æ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–º –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–∏ (IR) –∏ –º–µ—Ç–æ–¥–∞—Ö —Ä–∞–±–æ—Ç—ã —Å –Ω–∏–º.

## üéØ –û—Ç–≤–µ—Ç –Ω–∞ –≤–∞—à –≤–æ–ø—Ä–æ—Å –æ IR

–î–∞, —Å–ª–µ–¥—É—é—â–∏–π —ç—Ç–∞–ø –ø–æ—Å–ª–µ AST - —ç—Ç–æ **–ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ (IR)**. –£—á–∏—Ç—ã–≤–∞—è –≤–∞—à–∏ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è "—Ç–æ–ª—å–∫–æ —Ä—É–∫–∞–º–∏, —Ç–æ–ª—å–∫–æ —Ö–∞—Ä–¥–∫–æ—Ä" –∏ –Ω–∞–ª–∏—á–∏–µ –≤ –ø—Ä–æ–µ–∫—Ç–µ –º–æ–Ω–∞–¥, transducers –∏ protocols, –≤–æ—Ç –∫–æ–º–ø–ª–µ–∫—Å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞:

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ IR –¥–ª—è C51

### 1. **–¢—Ä–µ—Ö—É—Ä–æ–≤–Ω–µ–≤–∞—è IR –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**

```clojure
;; –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ IR (–±–ª–∏–∑–∫–æ –∫ AST)
(defprotocol HIR-Node
  (lower-to-mir [this context])
  (optimize-hir [this])
  (get-type [this]))

;; –°—Ä–µ–¥–Ω–µ—É—Ä–æ–≤–Ω–µ–≤–æ–µ IR (—Ç—Ä–µ—Ö–∞–¥—Ä–µ—Å–Ω—ã–π –∫–æ–¥)  
(defprotocol MIR-Instruction
  (optimize-mir [this])
  (allocate-registers [this register-map])
  (estimate-cost [this]))

;; –ù–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ IR (–±–ª–∏–∑–∫–æ –∫ –∞—Å—Å–µ–º–±–ª–µ—Ä—É AT89S4051)
(defprotocol LIR-Instruction
  (generate-assembly [this])
  (get-register-usage [this]))
```

### 2. **–ú–µ—Ç–æ–¥—ã —Ä–∞–±–æ—Ç—ã —Å IR: –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥**

#### **A. Transducers –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã—Ö –ø—Ä–æ—Ö–æ–¥–æ–≤**

```clojure
;; –ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ transducers
(def optimization-pipeline
  (comp
    (map constant-folding-xf)           ; –°–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
    (remove dead-code-elimination-xf)   ; –£–¥–∞–ª–µ–Ω–∏–µ –º–µ—Ä—Ç–≤–æ–≥–æ –∫–æ–¥–∞
    (map strength-reduction-xf)         ; –£–ø—Ä–æ—â–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
    (map peephole-optimization-xf)      ; Peephole –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    (map at89s4051-specific-xf)))       ; –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è AT89S4051

;; –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ pipeline –∫ –±–∞–∑–æ–≤–æ–º—É –±–ª–æ–∫—É
(defn optimize-basic-block [basic-block]
  (->> basic-block
       :instructions
       (into [] optimization-pipeline)
       (assoc basic-block :instructions)))
```

#### **B. Protocols –¥–ª—è –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π**

```clojure
(defprotocol IRTransformation
  (transform [this ir-node context])
  (can-apply? [this ir-node])
  (get-priority [this]))

(defrecord ConstantFolding []
  IRTransformation
  (transform [_ node context]
    (match node
      {:op :add :left {:type :const :value a} :right {:type :const :value b}}
      {:type :const :value (+ a b)}
      
      :else node))
  
  (can-apply? [_ node]
    (and (= (:op node) :add)
         (const? (:left node))
         (const? (:right node))))
  
  (get-priority [_] 100))
```

#### **C. –ú–æ–Ω–∞–¥—ã –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è**

```clojure
;; State –º–æ–Ω–∞–¥–∞ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
(defn compile-with-context [ast initial-context]
  (m/do-state
    [hir (transform-to-hir ast)
     _ (update-symbol-table hir)
     optimized-hir (optimize-hir hir)
     mir (lower-to-mir optimized-hir)
     optimized-mir (optimize-mir mir)
     assembly (generate-assembly optimized-mir)]
    (m/return assembly)))
```

### 3. **–ê–ª–≥–æ—Ä–∏—Ç–º—ã –∞–Ω–∞–ª–∏–∑–∞ –ø–æ—Ç–æ–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è**

#### **A. –ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ CFG —á–µ—Ä–µ–∑ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã**

```clojure
(defrecord ControlFlowGraph [entry-block exit-block blocks edges])

(defn build-cfg [mir-instructions]
  (->> mir-instructions
       (partition-by branch-instruction?)  ; –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –±–∞–∑–æ–≤—ã–µ –±–ª–æ–∫–∏
       (map create-basic-block)
       (reduce connect-blocks)             ; –°–æ–µ–¥–∏–Ω—è–µ–º –±–ª–æ–∫–∏
       (create-cfg)))
```

#### **B. –ê–Ω–∞–ª–∏–∑ –¥–æ–º–∏–Ω–∞—Ç–æ—Ä–æ–≤ —á–µ—Ä–µ–∑ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω—É—é —Ç–æ—á–∫—É**

```clojure
(defn compute-dominators [cfg]
  (let [initial-state (initialize-dominators cfg)]
    (->> initial-state
         (iterate update-dominators)       ; –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º
         (take-while changed?)             ; –î–æ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏
         last)))                          ; –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

;; –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –¥–æ–º–∏–Ω–∞—Ç–æ—Ä–æ–≤
(defn update-dominators [dom-state]
  (reduce (fn [state block]
            (let [new-doms (compute-block-dominators block state)]
              (assoc state (:label block) new-doms)))
          dom-state
          (:blocks dom-state)))
```

### 4. **–°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è AT89S4051 –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏**

```clojure
;; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä–∞
(defn optimize-accumulator-usage [mir-block]
  (->> mir-block
       :instructions
       (group-by accumulator-operation?)
       (map optimize-accumulator-sequence)
       (apply concat)
       (vec)))

;; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –±–∏—Ç–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
(defn optimize-bit-operations [instruction]
  (match instruction
    {:op :and :src2 {:type :const :value 1}}
    {:op :bit-test :bit 0}  ; –ó–∞–º–µ–Ω–∞ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É –º–ª–∞–¥—à–µ–≥–æ –±–∏—Ç–∞
    
    {:op :mul :src2 {:type :const :value n}} 
    (when (power-of-two? n)
      {:op :shift-left :amount (log2 n)})  ; –ó–∞–º–µ–Ω–∞ —É–º–Ω–æ–∂–µ–Ω–∏—è –Ω–∞ —Å–¥–≤–∏–≥
    
    :else instruction))
```

## ü§î **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã**

### **–í–æ–ø—Ä–æ—Å 1**: –ù–µ —Å–ª–∏—à–∫–æ–º –ª–∏ —Å–ª–æ–∂–Ω–æ –¥–ª—è –º–∏–∫—Ä–æ–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞?

**–ö–æ–Ω—Ç—Ä–∞—Ä–≥—É–º–µ–Ω—Ç**: –°–ª–æ–∂–Ω–æ—Å—Ç—å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ —Ä–∞–∑–º–µ—Ä –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º–æ–≥–æ –∫–æ–¥–∞. –ù–∞–æ–±–æ—Ä–æ—Ç, –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–∞—é—Ç –±–æ–ª–µ–µ –∫–æ–º–ø–∞–∫—Ç–Ω—ã–π –∫–æ–¥ –¥–ª—è AT89S4051.

### **–í–æ–ø—Ä–æ—Å 2**: –°—Ç–æ–∏—Ç –ª–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å SSA —Ñ–æ—Ä–º—É?

**–ê–Ω–∞–ª–∏–∑**:
- **–ó–ê**: –£–ø—Ä–æ—â–∞–µ—Ç –º–Ω–æ–≥–∏–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
- **–ü–†–û–¢–ò–í**: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è –ø—Ä–æ—Å—Ç–æ–≥–æ –º–∏–∫—Ä–æ–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
- **–†–ï–®–ï–ù–ò–ï**: –û–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω–∞—è SSA —Ç–æ–ª—å–∫–æ –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π

### **–í–æ–ø—Ä–æ—Å 3**: –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã?

```clojure
;; 1. –ü—Ä–æ—Å—Ç–æ–π AST ‚Üí Assembly (–±–µ–∑ IR)
;; –ü–õ–Æ–°–´: –ü—Ä–æ—Å—Ç–æ—Ç–∞
;; –ú–ò–ù–£–°–´: –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π

;; 2. –ï–¥–∏–Ω–æ–µ IR (–±–µ–∑ —É—Ä–æ–≤–Ω–µ–π)
;; –ü–õ–Æ–°–´: –ú–µ–Ω—å—à–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π
;; –ú–ò–ù–£–°–´: –°–º–µ—à–µ–Ω–∏–µ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π

;; 3. –ù–∞—à –≤—ã–±–æ—Ä: –¢—Ä–µ—Ö—É—Ä–æ–≤–Ω–µ–≤–æ–µ IR
;; –ü–õ–Æ–°–´: –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ, –≥–∏–±–∫–æ—Å—Ç—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π
;; –ú–ò–ù–£–°–´: –ë–æ–ª—å—à–µ –∫–æ–¥–∞
```

## üéØ **–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**

### **–ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥**:

1. **Threading macros** –¥–ª—è pipeline —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π
2. **Transducers** –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã—Ö –ø—Ä–æ—Ö–æ–¥–æ–≤  
3. **Protocols** –¥–ª—è –ø–æ–ª–∏–º–æ—Ä—Ñ–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
4. **–ú–æ–Ω–∞–¥—ã** –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è

```clojure
;; –ü–æ–ª–Ω—ã–π pipeline –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
(defn compile-c51 [ast]
  (->> ast
       (tap> "Input AST")
       transform-to-hir
       (tap> "HIR")
       (optimize-with-transducers hir-optimizations)
       (tap> "Optimized HIR")
       lower-to-mir
       (tap> "MIR")
       (optimize-with-transducers mir-optimizations)
       (tap> "Optimized MIR")
       allocate-registers
       (tap> "After register allocation")
       generate-at89s4051-assembly
       (tap> "Final assembly")))
```

**–≠—Ç–æ —Ä–µ—à–µ–Ω–∏–µ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç**:
- –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é —á–∏—Ç–∞–µ–º–æ—Å—Ç—å –∏ –æ—Ç–ª–∞–¥–æ—á–Ω–æ—Å—Ç—å
- –í—ã—Å–æ–∫—É—é –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π
- –õ–µ–≥–∫–æ—Å—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤—ã—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π
- –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞—Ä–∞–¥–∏–≥–º–µ

–ì–æ—Ç–æ–≤ –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ª—é–±–æ–π –∞—Å–ø–µ–∫—Ç —ç—Ç–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã!

```clojure
;; –í—ã—Å–æ–∫–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ IR (–±–ª–∏–∑–∫–æ –∫ AST)
(defprotocol HIR-Node
  (lower-to-mir [this context])
  (optimize-hir [this])
  (get-type [this]))

;; –°—Ä–µ–¥–Ω–µ—É—Ä–æ–≤–Ω–µ–≤–æ–µ IR (—Ç—Ä–µ—Ö–∞–¥—Ä–µ—Å–Ω—ã–π –∫–æ–¥)  
(defprotocol MIR-Instruction
  (optimize-mir [this])
  (allocate-registers [this register-map])
  (estimate-cost [this]))

;; –ù–∏–∑–∫–æ—É—Ä–æ–≤–Ω–µ–≤–æ–µ IR (–±–ª–∏–∑–∫–æ –∫ –∞—Å—Å–µ–º–±–ª–µ—Ä—É AT89S4051)
(defprotocol LIR-Instruction
  (generate-assembly [this])
  (get-register-usage [this]))
```

```clojure
;; –ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —á–µ—Ä–µ–∑ transducers
(def optimization-pipeline
  (comp
    (map constant-folding-xf)           ; –°–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
    (remove dead-code-elimination-xf)   ; –£–¥–∞–ª–µ–Ω–∏–µ –º–µ—Ä—Ç–≤–æ–≥–æ –∫–æ–¥–∞
    (map strength-reduction-xf)         ; –£–ø—Ä–æ—â–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
    (map peephole-optimization-xf)      ; Peephole –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    (map at89s4051-specific-xf)))       ; –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è AT89S4051

;; –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ pipeline –∫ –±–∞–∑–æ–≤–æ–º—É –±–ª–æ–∫—É
(defn optimize-basic-block [basic-block]
  (->> basic-block
       :instructions
       (into [] optimization-pipeline)
       (assoc basic-block :instructions)))
```

```clojure
(defprotocol IRTransformation
  (transform [this ir-node context])
  (can-apply? [this ir-node])
  (get-priority [this]))

(defrecord ConstantFolding []
  IRTransformation
  (transform [_ node context]
    (match node
      {:op :add :left {:type :const :value a} :right {:type :const :value b}}
      {:type :const :value (+ a b)}
      
      :else node))
  
  (can-apply? [_ node]
    (and (= (:op node) :add)
         (const? (:left node))
         (const? (:right node))))
  
  (get-priority [_] 100))
```

```clojure
;; State –º–æ–Ω–∞–¥–∞ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
(defn compile-with-context [ast initial-context]
  (m/do-state
    [hir (transform-to-hir ast)
     _ (update-symbol-table hir)
     optimized-hir (optimize-hir hir)
     mir (lower-to-mir optimized-hir)
     optimized-mir (optimize-mir mir)
     assembly (generate-assembly optimized-mir)]
    (m/return assembly)))
```

```clojure
(defrecord ControlFlowGraph [entry-block exit-block blocks edges])

(defn build-cfg [mir-instructions]
  (->> mir-instructions
       (partition-by branch-instruction?)  ; –†–∞–∑–±–∏–≤–∞–µ–º –Ω–∞ –±–∞–∑–æ–≤—ã–µ –±–ª–æ–∫–∏
       (map create-basic-block)
       (reduce connect-blocks)             ; –°–æ–µ–¥–∏–Ω—è–µ–º –±–ª–æ–∫–∏
       (create-cfg)))
```

```clojure
(defn compute-dominators [cfg]
  (let [initial-state (initialize-dominators cfg)]
    (->> initial-state
         (iterate update-dominators)       ; –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º
         (take-while changed?)             ; –î–æ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏
         last)))                          ; –§–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç

;; –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –¥–æ–º–∏–Ω–∞—Ç–æ—Ä–æ–≤
(defn update-dominators [dom-state]
  (reduce (fn [state block]
            (let [new-doms (compute-block-dominators block state)]
              (assoc state (:label block) new-doms)))
          dom-state
          (:blocks dom-state)))
```

```clojure
;; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä–∞
(defn optimize-accumulator-usage [mir-block]
  (->> mir-block
       :instructions
       (group-by accumulator-operation?)
       (map optimize-accumulator-sequence)
       (apply concat)
       (vec)))

;; –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –±–∏—Ç–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
(defn optimize-bit-operations [instruction]
  (match instruction
    {:op :and :src2 {:type :const :value 1}}
    {:op :bit-test :bit 0}  ; –ó–∞–º–µ–Ω–∞ –Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫—É –º–ª–∞–¥—à–µ–≥–æ –±–∏—Ç–∞
    
    {:op :mul :src2 {:type :const :value n}} 
    (when (power-of-two? n)
      {:op :shift-left :amount (log2 n)})  ; –ó–∞–º–µ–Ω–∞ —É–º–Ω–æ–∂–µ–Ω–∏—è –Ω–∞ —Å–¥–≤–∏–≥
    
    :else instruction))
```

```clojure
;; 1. –ü—Ä–æ—Å—Ç–æ–π AST ‚Üí Assembly (–±–µ–∑ IR)
;; –ü–õ–Æ–°–´: –ü—Ä–æ—Å—Ç–æ—Ç–∞
;; –ú–ò–ù–£–°–´: –°–ª–æ–∂–Ω–æ—Å—Ç—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π

;; 2. –ï–¥–∏–Ω–æ–µ IR (–±–µ–∑ —É—Ä–æ–≤–Ω–µ–π)
;; –ü–õ–Æ–°–´: –ú–µ–Ω—å—à–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π
;; –ú–ò–ù–£–°–´: –°–º–µ—à–µ–Ω–∏–µ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π

;; 3. –ù–∞—à –≤—ã–±–æ—Ä: –¢—Ä–µ—Ö—É—Ä–æ–≤–Ω–µ–≤–æ–µ IR
;; –ü–õ–Æ–°–´: –ß–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ, –≥–∏–±–∫–æ—Å—Ç—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π
;; –ú–ò–ù–£–°–´: –ë–æ–ª—å—à–µ –∫–æ–¥–∞
```

```clojure
;; –ü–æ–ª–Ω—ã–π pipeline –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
(defn compile-c51 [ast]
  (->> ast
       (tap> "Input AST")
       transform-to-hir
       (tap> "HIR")
       (optimize-with-transducers hir-optimizations)
       (tap> "Optimized HIR")
       lower-to-mir
       (tap> "MIR")
       (optimize-with-transducers mir-optimizations)
       (tap> "Optimized MIR")
       allocate-registers
       (tap> "After register allocation")
       generate-at89s4051-assembly
       (tap> "Final assembly")))
```

---

**User**

–ù–æ —É –º–µ–Ω—è —É–∂–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω –ø–∞—Ä—Å–µ—Ä —Å –ø–æ–º–æ—â—å—é –º–æ–Ω–∞–¥ –∏ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏ —á–∏—Å—Ç–æ–≥–æ –º–∞–∫—Ä–æ—Å–∞. –ú–Ω–µ –æ–ø—è—Ç—å –µ–≥–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å?!

---

**Cursor**

**–ù–ï–¢!** –ê–±—Å–æ–ª—é—Ç–Ω–æ –Ω–µ –Ω—É–∂–Ω–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å —É–∂–µ —Ä–∞–±–æ—Ç–∞—é—â–∏–π –ø–∞—Ä—Å–µ—Ä —Å –º–æ–Ω–∞–¥–∞–º–∏! –≠—Ç–æ –±—ã–ª–∞ –±—ã –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è –æ—à–∏–±–∫–∞.

## üõ°Ô∏è –ü—Ä–∏–Ω—Ü–∏–ø "–ù–µ —Ç—Ä–æ–≥–∞–π —Ä–∞–±–æ—Ç–∞—é—â–∏–π –∫–æ–¥"

–í–∞—à –ø–∞—Ä—Å–µ—Ä —Å –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–º–∏ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞–º–∏ –∏ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏–º–∏ –º–∞–∫—Ä–æ—Å–∞–º–∏ - —ç—Ç–æ **–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–µ**, –∞ –Ω–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–π –¥–æ–ª–≥. –í–æ—Ç –ø–æ—á–µ–º—É:

### 1. **–ú–æ–Ω–∞–¥—ã –∏–¥–µ–∞–ª—å–Ω—ã –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞**

```clojure
;; –í–∞—à —Ç–µ–∫—É—â–∏–π –ø–∞—Ä—Å–µ—Ä (–û–°–¢–ê–í–õ–Ø–ï–ú –ö–ê–ö –ï–°–¢–¨!)
(defn parse-function-declaration [tokens]
  (do-parse
    [return-type parse-type-specifier
     func-name parse-identifier  
     params (parenthesized (comma-separated parse-parameter))
     body parse-block]
    (return-parser (function-node return-type func-name params body))))
```

**–ü–æ—á–µ–º—É —ç—Ç–æ –æ—Ç–ª–∏—á–Ω–æ**:
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
- –ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º–æ—Å—Ç—å –ø–∞—Ä—Å–µ—Ä–æ–≤
- Backtracking –∏–∑ –∫–æ—Ä–æ–±–∫–∏
- –ß–∏—Ç–∞–µ–º–∞—è –≥—Ä–∞–º–º–∞—Ç–∏–∫–∞

### 2. **Threading macros –ù–ï –ø–æ–¥—Ö–æ–¥—è—Ç –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞**

```clojure
;; –ü–õ–û–•–ê–Ø –∏–¥–µ—è –¥–ª—è –ø–∞—Ä—Å–µ—Ä–∞:
(defn parse-function-bad [tokens]
  (->> tokens
       parse-type-specifier    ; ‚ùå –ê –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å?
       parse-identifier        ; ‚ùå –ö–∞–∫ –ø–µ—Ä–µ–¥–∞—Ç—å –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —Ç–æ–∫–µ–Ω—ã?
       parse-parameters        ; ‚ùå –ö–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫—É?
       build-function-ast))    ; ‚ùå –ü–æ–ª–Ω–∞—è –ø–æ—Ç–µ—Ä—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
```

**–ü—Ä–æ–±–ª–µ–º—ã**:
- –ù–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–µ—É–¥–∞—á–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
- –ù–µ—Ç –ø–µ—Ä–µ–¥–∞—á–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è (–ø–æ–∑–∏—Ü–∏—è –≤ —Ç–æ–∫–µ–Ω–∞—Ö)
- –ù–µ—Ç backtracking
- –ù–µ—Ç –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤

## üéØ **–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è**

### **–ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥**: –ö–∞–∂–¥–æ–º—É –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—É - —Å–≤–æ–µ –º–µ—Å—Ç–æ

```clojure
;; 1. –ü–ê–†–°–ï–†: –ú–æ–Ω–∞–¥—ã (–û–°–¢–ê–í–õ–Ø–ï–ú)
(defn parse [tokens]
  (do-parse
    [declarations (many parse-declaration)]
    (return-parser (program-node declarations))))

;; 2. IR –¢–†–ê–ù–°–§–û–†–ú–ê–¶–ò–ò: Threading macros (–ù–û–í–û–ï)
(defn compile-ast-to-assembly [ast]
  (->> ast
       (tap> "Input AST")
       transform-to-hir
       (tap> "HIR")
       optimize-hir
       (tap> "Optimized HIR")
       lower-to-mir
       (tap> "MIR")
       optimize-mir
       (tap> "Optimized MIR")
       generate-assembly
       (tap> "Assembly")))

;; 3. –ü–†–ï–ü–†–û–¶–ï–°–°–û–†: Transducers + Protocols (–£–ñ–ï –ï–°–¢–¨)
(defn preprocess [code]
  (->> code
       str/split-lines
       (into [] preprocessing-xf)
       (str/join "\n")))
```

## üî¨ **–ù–∞—É—á–Ω–æ–µ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è**

### **–¢–µ–æ—Ä–∏—è —Ç–∏–ø–æ–≤ –∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏**

```clojure
;; –ü–∞—Ä—Å–∏–Ω–≥ = Maybe/Either –º–æ–Ω–∞–¥–∞ (–æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ—É–¥–∞—á)
Parser a = [Token] -> Maybe (a, [Token])

;; IR —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ = Identity –º–æ–Ω–∞–¥–∞ (–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è)  
Transform a = a -> a

;; –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–∏–Ω–≥ = List –º–æ–Ω–∞–¥–∞ (—Ä–∞–±–æ—Ç–∞ —Å –∫–æ–ª–ª–µ–∫—Ü–∏—è–º–∏)
Preprocess = [String] -> [String]
```

**–ö–∞–∂–¥–∞—è –∑–∞–¥–∞—á–∞ —Ç—Ä–µ–±—É–µ—Ç —Å–≤–æ–µ–π –º–æ–Ω–∞–¥—ã!**

### **–ö–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞**

```
–ó–∞–¥–∞—á–∞          | –õ—É—á—à–∏–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç | –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ | –°–ª–æ–∂–Ω–æ—Å—Ç—å
----------------|-------------------|--------------|----------
–ü–∞—Ä—Å–∏–Ω–≥         | –ú–æ–Ω–∞–¥—ã           | Threading    | +300%
IR –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏  | Threading        | –ú–æ–Ω–∞–¥—ã       | +150%
–ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–∏–Ω–≥   | Transducers      | –ú–æ–Ω–∞–¥—ã       | +200%
```

## üöÄ **–ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø–ª–∞–Ω –¥–µ–π—Å—Ç–≤–∏–π**

### **–§–∞–∑–∞ 1: –î–æ–ø–æ–ª–Ω—è–µ–º, –Ω–µ –∑–∞–º–µ–Ω—è–µ–º (1 –Ω–µ–¥–µ–ª—è)**

```clojure
;; –î–æ–±–∞–≤–ª—è–µ–º tap> –≤ –°–£–©–ï–°–¢–í–£–Æ–©–ò–ô –ø–∞—Ä—Å–µ—Ä (–Ω–µ–∏–Ω–≤–∞–∑–∏–≤–Ω–æ)
(defn parse-with-debug [tokens]
  (let [result (parse tokens)]
    (tap> {:stage "parsing" :success (:success result) :ast (:ast result)})
    result))

;; –°–æ–∑–¥–∞–µ–º IR pipeline (–ù–û–í–´–ô –∫–æ–¥)
(defn ast->assembly [ast]
  (->> ast
       (tap> "AST from parser")
       transform-to-hir
       optimize-hir
       lower-to-mir
       optimize-mir
       generate-assembly))
```

### **–§–∞–∑–∞ 2: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è (1 –Ω–µ–¥–µ–ª—è)**

```clojure
;; –ü–æ–ª–Ω—ã–π pipeline –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞
(defn compile-c51 [source-code]
  (->> source-code
       (tap> "Source code")
       preprocess                    ; Transducers (—É–∂–µ –µ—Å—Ç—å)
       (tap> "Preprocessed")
       tokenize                      ; –ü—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è
       (tap> "Tokens")
       parse                         ; –ú–æ–Ω–∞–¥—ã (–ù–ï –¢–†–û–ì–ê–ï–ú!)
       (tap> "Parse result")
       :ast                          ; –ò–∑–≤–ª–µ–∫–∞–µ–º AST
       ast->assembly                 ; Threading macros (–Ω–æ–≤–æ–µ)
       (tap> "Final assembly")))
```

### **–§–∞–∑–∞ 3: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è IR (2-3 –Ω–µ–¥–µ–ª–∏)**

```clojure
;; –§–æ–∫—É—Å–∏—Ä—É–µ–º—Å—è –Ω–∞ IR, –≥–¥–µ threading macros –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω—É–∂–Ω—ã
(defn optimize-mir-block [basic-block]
  (->> basic-block
       :instructions
       (map constant-fold)           ; –°–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
       (remove dead-instruction?)    ; –£–¥–∞–ª–µ–Ω–∏–µ –º–µ—Ä—Ç–≤–æ–≥–æ –∫–æ–¥–∞
       (map strength-reduce)         ; –£–ø—Ä–æ—â–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
       (map optimize-at89s4051)      ; –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
       (vec)
       (assoc basic-block :instructions)))
```

## ü§î **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞**

–ú–æ–π –ø—Ä–µ–¥—ã–¥—É—â–∏–π –¥–æ–∫—É–º–µ–Ω—Ç —Å–æ–¥–µ—Ä–∂–∞–ª **–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—É—é –æ—à–∏–±–∫—É** –≤ —Ä–∞–∑–¥–µ–ª–µ "–ü–ª–∞–Ω –≤–Ω–µ–¥—Ä–µ–Ω–∏—è". –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –ø–∞—Ä—Å–µ—Ä–∞ –±—ã–ª –±—ã:

1. **–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏ –Ω–µ–æ–ø—Ä–∞–≤–¥–∞–Ω**: –ú–æ–Ω–∞–¥—ã –ª—É—á—à–µ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
2. **–≠–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏ –Ω–µ–≤—ã–≥–æ–¥–µ–Ω**: –¢—Ä–∞—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏ –Ω–∞ —Ä–∞–±–æ—Ç–∞—é—â–∏–π –∫–æ–¥
3. **–†–∏—Å–∫–æ–≤–∞–Ω**: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤–Ω–µ—Å–µ–Ω–∏—è –±–∞–≥–æ–≤

## üéØ **–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è**

### **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–π –ø—Ä–∏–Ω—Ü–∏–ø**: "–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∑–∞–¥–∞—á–∏"

```clojure
;; –ü–ê–†–°–ï–†: –ú–æ–Ω–∞–¥—ã (–≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏–µ –º–∞–∫—Ä–æ—Å—ã)
;; ‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
;; ‚úÖ Backtracking  
;; ‚úÖ –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤
;; ‚úÖ –£–ñ–ï –†–ê–ë–û–¢–ê–ï–¢!

;; IR: Threading macros + Transducers
;; ‚úÖ –õ–∏–Ω–µ–π–Ω—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
;; ‚úÖ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–æ—Ö–æ–¥—ã
;; ‚úÖ –û—Ç–ª–∞–¥–∫–∞ —Å tap>

;; –ü–†–ï–ü–†–û–¶–ï–°–°–û–†: Protocols + Transducers  
;; ‚úÖ –ü–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º –¥–∏—Ä–µ–∫—Ç–∏–≤
;; ‚úÖ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
;; ‚úÖ –£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù–û!
```

## üìã **–ù–æ–≤—ã–π –ø–ª–∞–Ω (–±–µ–∑ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ –ø–∞—Ä—Å–µ—Ä–∞)**

### **–ù–µ–¥–µ–ª—è 1-2: IR –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**
- –°–æ–∑–¥–∞—Ç—å HIR/MIR/LIR —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
- –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –±–∞–∑–æ–≤—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
- –î–æ–±–∞–≤–∏—Ç—å `tap>` –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏

### **–ù–µ–¥–µ–ª—è 3-4: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏**
- Constant folding —á–µ—Ä–µ–∑ threading macros
- Dead code elimination
- Strength reduction –¥–ª—è AT89S4051

### **–ù–µ–¥–µ–ª—è 5-6: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–¥–∞**
- –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤
- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—Å—Å–µ–º–±–ª–µ—Ä–∞ AT89S4051
- –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –ø–∞—Ä—Å–µ—Ä–æ–º

**–ü–∞—Ä—Å–µ—Ä –æ—Å—Ç–∞–µ—Ç—Å—è –Ω–µ—Ç—Ä–æ–Ω—É—Ç—ã–º!** 

–í–∞—à–∞ –∏–Ω—Ç—É–∏—Ü–∏—è –∞–±—Å–æ–ª—é—Ç–Ω–æ –≤–µ—Ä–Ω–∞ - –Ω–µ –Ω—É–∂–Ω–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å —Ä–∞–±–æ—Ç–∞—é—â–∏–π, —Ö–æ—Ä–æ—à–æ —Å–ø—Ä–æ–µ–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥. –ú–æ–Ω–∞–¥—ã –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ - —ç—Ç–æ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–µ, –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ.

```clojure
;; –í–∞—à —Ç–µ–∫—É—â–∏–π –ø–∞—Ä—Å–µ—Ä (–û–°–¢–ê–í–õ–Ø–ï–ú –ö–ê–ö –ï–°–¢–¨!)
(defn parse-function-declaration [tokens]
  (do-parse
    [return-type parse-type-specifier
     func-name parse-identifier  
     params (parenthesized (comma-separated parse-parameter))
     body parse-block]
    (return-parser (function-node return-type func-name params body))))
```

```clojure
;; –ü–õ–û–•–ê–Ø –∏–¥–µ—è –¥–ª—è –ø–∞—Ä—Å–µ—Ä–∞:
(defn parse-function-bad [tokens]
  (->> tokens
       parse-type-specifier    ; ‚ùå –ê –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å?
       parse-identifier        ; ‚ùå –ö–∞–∫ –ø–µ—Ä–µ–¥–∞—Ç—å –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —Ç–æ–∫–µ–Ω—ã?
       parse-parameters        ; ‚ùå –ö–∞–∫ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –æ—à–∏–±–∫—É?
       build-function-ast))    ; ‚ùå –ü–æ–ª–Ω–∞—è –ø–æ—Ç–µ—Ä—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
```

```clojure
;; 1. –ü–ê–†–°–ï–†: –ú–æ–Ω–∞–¥—ã (–û–°–¢–ê–í–õ–Ø–ï–ú)
(defn parse [tokens]
  (do-parse
    [declarations (many parse-declaration)]
    (return-parser (program-node declarations))))

;; 2. IR –¢–†–ê–ù–°–§–û–†–ú–ê–¶–ò–ò: Threading macros (–ù–û–í–û–ï)
(defn compile-ast-to-assembly [ast]
  (->> ast
       (tap> "Input AST")
       transform-to-hir
       (tap> "HIR")
       optimize-hir
       (tap> "Optimized HIR")
       lower-to-mir
       (tap> "MIR")
       optimize-mir
       (tap> "Optimized MIR")
       generate-assembly
       (tap> "Assembly")))

;; 3. –ü–†–ï–ü–†–û–¶–ï–°–°–û–†: Transducers + Protocols (–£–ñ–ï –ï–°–¢–¨)
(defn preprocess [code]
  (->> code
       str/split-lines
       (into [] preprocessing-xf)
       (str/join "\n")))
```

```clojure
;; –ü–∞—Ä—Å–∏–Ω–≥ = Maybe/Either –º–æ–Ω–∞–¥–∞ (–æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ—É–¥–∞—á)
Parser a = [Token] -> Maybe (a, [Token])

;; IR —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ = Identity –º–æ–Ω–∞–¥–∞ (–¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è)  
Transform a = a -> a

;; –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–∏–Ω–≥ = List –º–æ–Ω–∞–¥–∞ (—Ä–∞–±–æ—Ç–∞ —Å –∫–æ–ª–ª–µ–∫—Ü–∏—è–º–∏)
Preprocess = [String] -> [String]
```

```plaintext
–ó–∞–¥–∞—á–∞          | –õ—É—á—à–∏–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç | –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ | –°–ª–æ–∂–Ω–æ—Å—Ç—å
----------------|-------------------|--------------|----------
–ü–∞—Ä—Å–∏–Ω–≥         | –ú–æ–Ω–∞–¥—ã           | Threading    | +300%
IR –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏  | Threading        | –ú–æ–Ω–∞–¥—ã       | +150%
–ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–∏–Ω–≥   | Transducers      | –ú–æ–Ω–∞–¥—ã       | +200%
```

```clojure
;; –î–æ–±–∞–≤–ª—è–µ–º tap> –≤ –°–£–©–ï–°–¢–í–£–Æ–©–ò–ô –ø–∞—Ä—Å–µ—Ä (–Ω–µ–∏–Ω–≤–∞–∑–∏–≤–Ω–æ)
(defn parse-with-debug [tokens]
  (let [result (parse tokens)]
    (tap> {:stage "parsing" :success (:success result) :ast (:ast result)})
    result))

;; –°–æ–∑–¥–∞–µ–º IR pipeline (–ù–û–í–´–ô –∫–æ–¥)
(defn ast->assembly [ast]
  (->> ast
       (tap> "AST from parser")
       transform-to-hir
       optimize-hir
       lower-to-mir
       optimize-mir
       generate-assembly))
```

```clojure
;; –ü–æ–ª–Ω—ã–π pipeline –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞
(defn compile-c51 [source-code]
  (->> source-code
       (tap> "Source code")
       preprocess                    ; Transducers (—É–∂–µ –µ—Å—Ç—å)
       (tap> "Preprocessed")
       tokenize                      ; –ü—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è
       (tap> "Tokens")
       parse                         ; –ú–æ–Ω–∞–¥—ã (–ù–ï –¢–†–û–ì–ê–ï–ú!)
       (tap> "Parse result")
       :ast                          ; –ò–∑–≤–ª–µ–∫–∞–µ–º AST
       ast->assembly                 ; Threading macros (–Ω–æ–≤–æ–µ)
       (tap> "Final assembly")))
```

```clojure
;; –§–æ–∫—É—Å–∏—Ä—É–µ–º—Å—è –Ω–∞ IR, –≥–¥–µ threading macros –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω—É–∂–Ω—ã
(defn optimize-mir-block [basic-block]
  (->> basic-block
       :instructions
       (map constant-fold)           ; –°–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
       (remove dead-instruction?)    ; –£–¥–∞–ª–µ–Ω–∏–µ –º–µ—Ä—Ç–≤–æ–≥–æ –∫–æ–¥–∞
       (map strength-reduce)         ; –£–ø—Ä–æ—â–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
       (map optimize-at89s4051)      ; –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
       (vec)
       (assoc basic-block :instructions)))
```

```clojure
;; –ü–ê–†–°–ï–†: –ú–æ–Ω–∞–¥—ã (–≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏–µ –º–∞–∫—Ä–æ—Å—ã)
;; ‚úÖ –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
;; ‚úÖ Backtracking  
;; ‚úÖ –ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤
;; ‚úÖ –£–ñ–ï –†–ê–ë–û–¢–ê–ï–¢!

;; IR: Threading macros + Transducers
;; ‚úÖ –õ–∏–Ω–µ–π–Ω—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
;; ‚úÖ –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø—Ä–æ—Ö–æ–¥—ã
;; ‚úÖ –û—Ç–ª–∞–¥–∫–∞ —Å tap>

;; –ü–†–ï–ü–†–û–¶–ï–°–°–û–†: Protocols + Transducers  
;; ‚úÖ –ü–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º –¥–∏—Ä–µ–∫—Ç–∏–≤
;; ‚úÖ –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
;; ‚úÖ –£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù–û!
```

---

**User**

—Ç–æ–≥–¥–∞ –ø–µ—Ä–µ–ø–∏—à–∏ –ø–ª–∞–Ω –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –¥–æ–∫—É–º–µ–Ω—Ç, –∏ –∏—Å–ø—Ä–∞–≤—å THREADING_MACROS_ANALYSIS.md

---

**Cursor**

```markdown
# –ü–ª–∞–Ω —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è (IR) –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ C51

## üéØ –¶–µ–ª—å –∏ –ø—Ä–∏–Ω—Ü–∏–ø—ã

**–û—Å–Ω–æ–≤–Ω–æ–π –ø—Ä–∏–Ω—Ü–∏–ø**: "–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∑–∞–¥–∞—á–∏"

- **–ü–∞—Ä—Å–µ—Ä**: –ú–æ–Ω–∞–¥—ã + –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏–µ –º–∞–∫—Ä–æ—Å—ã (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù - –ù–ï –¢–†–û–ì–ê–ï–ú!)
- **IR —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏**: Threading macros + `tap>` (–ù–û–í–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø)
- **–ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä**: Transducers + Protocols (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù)

---

## üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ IR

### –¢—Ä–µ—Ö—É—Ä–æ–≤–Ω–µ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

```
AST ‚Üí HIR ‚Üí MIR ‚Üí LIR ‚Üí AT89S4051 Assembly
      ‚Üë     ‚Üë     ‚Üë
   –í—ã—Å–æ–∫–∏–π –°—Ä–µ–¥–Ω–∏–π –ù–∏–∑–∫–∏–π
   —É—Ä–æ–≤–µ–Ω—å —É—Ä–æ–≤–µ–Ω—å —É—Ä–æ–≤–µ–Ω—å
```

### –ü—Ä–æ—Ç–æ–∫–æ–ª—ã –¥–ª—è IR —É–∑–ª–æ–≤

```clojure
;; –ë–∞–∑–æ–≤—ã–π –ø—Ä–æ—Ç–æ–∫–æ–ª –¥–ª—è –≤—Å–µ—Ö IR —É–∑–ª–æ–≤
(defprotocol IRNode
  (get-type [this] "–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–∏–ø —É–∑–ª–∞")
  (get-children [this] "–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–æ—á–µ—Ä–Ω–∏–µ —É–∑–ª—ã")
  (transform [this f] "–ü—Ä–∏–º–µ–Ω—è–µ—Ç —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—é"))

;; –ü—Ä–æ—Ç–æ–∫–æ–ª –¥–ª—è HIR (High-level IR)
(defprotocol HIRNode
  (lower-to-mir [this context] "–ü–æ–Ω–∏–∂–∞–µ—Ç HIR –¥–æ MIR")
  (optimize-hir [this] "–û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –Ω–∞ —É—Ä–æ–≤–Ω–µ HIR"))

;; –ü—Ä–æ—Ç–æ–∫–æ–ª –¥–ª—è MIR (Mid-level IR)  
(defprotocol MIRInstruction
  (optimize-mir [this] "–û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é MIR")
  (estimate-cost [this] "–û—Ü–µ–Ω–∏–≤–∞–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏")
  (lower-to-lir [this context] "–ü–æ–Ω–∏–∂–∞–µ—Ç –¥–æ LIR"))

;; –ü—Ä–æ—Ç–æ–∫–æ–ª –¥–ª—è LIR (Low-level IR)
(defprotocol LIRInstruction
  (allocate-registers [this register-map] "–†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ä–µ–≥–∏—Å—Ç—Ä—ã")
  (generate-assembly [this] "–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞—Å—Å–µ–º–±–ª–µ—Ä AT89S4051"))
```

---

## üìã –î–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

### **–§–∞–∑–∞ 1: –ë–∞–∑–æ–≤–∞—è –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ IR (–ù–µ–¥–µ–ª—è 1-2)**

#### –ù–µ–¥–µ–ª—è 1: –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –∏ –ø—Ä–æ—Ç–æ–∫–æ–ª—ã

```clojure
;; –§–∞–π–ª: src/c51cc/ir/core.clj
(ns c51cc.ir.core
  "–ë–∞–∑–æ–≤—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω–æ–≥–æ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è")

;; HIR —É–∑–ª—ã
(defrecord HIRFunction [name params return-type body])
(defrecord HIRAssignment [dest src])
(defrecord HIRBinaryOp [op left right])
(defrecord HIRCall [function args])
(defrecord HIRIf [condition then-branch else-branch])
(defrecord HIRWhile [condition body])

;; MIR –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
(defrecord MIRAdd [dest src1 src2])
(defrecord MIRLoad [dest src])
(defrecord MIRStore [dest src])
(defrecord MIRJump [label])
(defrecord MIRBranch [condition true-label false-label])

;; LIR –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ (–±–ª–∏–∑–∫–æ –∫ AT89S4051)
(defrecord LIRMovA [src])      ; MOV A, src
(defrecord LIRAddA [src])      ; ADD A, src
(defrecord LIRMovReg [reg src]) ; MOV Rn, src
(defrecord LIRJmp [addr])      ; JMP addr
```

#### –ù–µ–¥–µ–ª—è 2: AST ‚Üí HIR —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è

```clojure
;; –§–∞–π–ª: src/c51cc/ir/ast_to_hir.clj
(defn transform-ast-to-hir [ast]
  "–¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç AST –≤ HIR —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º threading macros"
  (->> ast
       (tap> "Input AST")
       normalize-ast-structure
       (tap> "Normalized AST")
       transform-declarations
       (tap> "HIR declarations")
       transform-statements
       (tap> "HIR statements")
       transform-expressions
       (tap> "Complete HIR")))

;; –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏
(defn transform-function-declaration [ast-node]
  (-> ast-node
      extract-function-signature
      (transform-parameter-list)
      (transform-function-body)
      (create-hir-function)))
```

### **–§–∞–∑–∞ 2: HIR –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (–ù–µ–¥–µ–ª—è 3)**

```clojure
;; –§–∞–π–ª: src/c51cc/ir/hir_optimizations.clj
(defn optimize-hir [hir]
  "–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ HIR"
  (->> hir
       (tap> "HIR before optimization")
       inline-simple-functions
       (tap> "After function inlining")
       constant-propagation
       (tap> "After constant propagation")
       dead-code-elimination-hir
       (tap> "After dead code elimination")
       simplify-control-flow
       (tap> "Optimized HIR")))

;; –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
(defn inline-simple-functions [hir]
  "–ò–Ω–ª–∞–π–Ω–∏–Ω–≥ –ø—Ä–æ—Å—Ç—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏ AT89S4051"
  (->> hir
       :functions
       (map inline-if-simple)
       (assoc hir :functions)))
```

### **–§–∞–∑–∞ 3: HIR ‚Üí MIR –ø–æ–Ω–∏–∂–µ–Ω–∏–µ (–ù–µ–¥–µ–ª—è 4)**

```clojure
;; –§–∞–π–ª: src/c51cc/ir/hir_to_mir.clj
(defn lower-hir-to-mir [hir]
  "–ü–æ–Ω–∏–∂–∞–µ—Ç HIR –¥–æ MIR (—Ç—Ä–µ—Ö–∞–¥—Ä–µ—Å–Ω—ã–π –∫–æ–¥)"
  (->> hir
       (tap> "HIR input")
       linearize-control-flow
       (tap> "Linearized control flow")
       convert-to-three-address
       (tap> "Three-address code")
       create-basic-blocks
       (tap> "Basic blocks")
       build-control-flow-graph
       (tap> "Control flow graph")))

;; –°–æ–∑–¥–∞–Ω–∏–µ —Ç—Ä–µ—Ö–∞–¥—Ä–µ—Å–Ω–æ–≥–æ –∫–æ–¥–∞
(defn convert-expression-to-mir [expr temp-counter]
  (match expr
    {:type :binary-op :op op :left left :right right}
    (let [left-mir (convert-expression-to-mir left temp-counter)
          right-mir (convert-expression-to-mir right (+ temp-counter 1))
          result-temp (str "t" (+ temp-counter 2))]
      [(->MIRAdd result-temp (:result left-mir) (:result right-mir))
       {:result result-temp :instructions (concat (:instructions left-mir)
                                                 (:instructions right-mir))}])
    
    {:type :constant :value val}
    [[] {:result val :instructions []}]))
```

### **–§–∞–∑–∞ 4: MIR –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (–ù–µ–¥–µ–ª—è 5)**

```clojure
;; –§–∞–π–ª: src/c51cc/ir/mir_optimizations.clj
(defn optimize-mir [mir-cfg]
  "–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –Ω–∞ —É—Ä–æ–≤–Ω–µ MIR"
  (->> mir-cfg
       (tap> "MIR before optimization")
       optimize-basic-blocks
       (tap> "After basic block optimization")
       eliminate-common-subexpressions
       (tap> "After CSE")
       optimize-for-at89s4051
       (tap> "After AT89S4051 optimizations")))

(defn optimize-basic-block [basic-block]
  "–û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –æ–¥–∏–Ω –±–∞–∑–æ–≤—ã–π –±–ª–æ–∫"
  (->> basic-block
       :instructions
       (map constant-fold-instruction)
       (remove dead-instruction?)
       (map strength-reduce-instruction)
       (map optimize-at89s4051-specific)
       (vec)
       (assoc basic-block :instructions)))

;; –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è AT89S4051 –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
(defn optimize-at89s4051-specific [instruction]
  "–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–ª—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã AT89S4051"
  (match instruction
    {:op :mul :src2 {:type :const :value n}}
    (when (power-of-two? n)
      {:op :shift-left :amount (log2 n)})  ; x * 2^n ‚Üí x << n
    
    {:op :add :src2 {:type :const :value 0}}
    {:op :nop}  ; x + 0 ‚Üí nop (–±—É–¥–µ—Ç —É–¥–∞–ª–µ–Ω–æ)
    
    :else instruction))
```

### **–§–∞–∑–∞ 5: –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ (–ù–µ–¥–µ–ª—è 6)**

```clojure
;; –§–∞–π–ª: src/c51cc/ir/register_allocation.clj
(defn allocate-registers [mir-cfg]
  "–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ –¥–ª—è AT89S4051"
  (->> mir-cfg
       (tap> "MIR before register allocation")
       compute-liveness-analysis
       (tap> "Liveness analysis complete")
       build-interference-graph
       (tap> "Interference graph built")
       color-graph-at89s4051
       (tap> "Register allocation complete")
       rewrite-with-registers
       (tap> "MIR with allocated registers")))

;; –†–µ–≥–∏—Å—Ç—Ä—ã AT89S4051
(def at89s4051-registers
  {:accumulator :A
   :general [:R0 :R1 :R2 :R3 :R4 :R5 :R6 :R7]
   :special [:DPTR :SP :PSW]})

(defn color-graph-at89s4051 [interference-graph]
  "–†–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ—Ä–µ–Ω—Ü–∏–∏ –¥–ª—è AT89S4051"
  (let [available-colors (concat [:A] (:general at89s4051-registers))]
    (->> interference-graph
         (sort-by degree >)  ; –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å—Ç–µ–ø–µ–Ω–∏ (–±–æ–ª—å—à–µ —Å–æ—Å–µ–¥–µ–π = —Ä–∞–Ω—å—à–µ)
         (reduce assign-register available-colors))))
```

### **–§–∞–∑–∞ 6: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—Å—Å–µ–º–±–ª–µ—Ä–∞ (–ù–µ–¥–µ–ª—è 7)**

```clojure
;; –§–∞–π–ª: src/c51cc/ir/code_generation.clj
(defn generate-assembly [mir-with-registers]
  "–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∞—Å—Å–µ–º–±–ª–µ—Ä AT89S4051"
  (->> mir-with-registers
       (tap> "MIR with registers")
       convert-to-lir
       (tap> "LIR instructions")
       optimize-lir
       (tap> "Optimized LIR")
       generate-at89s4051-assembly
       (tap> "Final assembly code")))

(defn convert-mir-to-lir [mir-instruction]
  "–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç MIR –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é –≤ LIR"
  (match mir-instruction
    {:op :add :dest dest :src1 src1 :src2 src2}
    [(->LIRMovA src1)
     (->LIRAddA src2)
     (->LIRMovReg dest :A)]
    
    {:op :load :dest dest :src src}
    [(->LIRMovReg dest src)]
    
    {:op :jump :label label}
    [(->LIRJmp label)]))

(defn generate-at89s4051-instruction [lir-instruction]
  "–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç—Ä–æ–∫—É –∞—Å—Å–µ–º–±–ª–µ—Ä–∞ –¥–ª—è AT89S4051"
  (match lir-instruction
    (->LIRMovA src)
    (str "MOV A, " (format-operand src))
    
    (->LIRAddA src)
    (str "ADD A, " (format-operand src))
    
    (->LIRMovReg reg src)
    (str "MOV " (name reg) ", " (format-operand src))))
```

### **–§–∞–∑–∞ 7: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –ø–∞—Ä—Å–µ—Ä–æ–º (–ù–µ–¥–µ–ª—è 8)**

```clojure
;; –§–∞–π–ª: src/c51cc/compiler.clj
(defn compile-c51 [source-code options]
  "–ü–æ–ª–Ω—ã–π pipeline –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ C51"
  (->> source-code
       (tap> "Source code")
       
       ;; –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù)
       (preprocess-v2 options)
       :result
       (tap> "Preprocessed code")
       
       ;; –õ–µ–∫—Å–µ—Ä (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù)
       tokenize
       (tap> "Tokens")
       
       ;; –ü–∞—Ä—Å–µ—Ä (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù - –ù–ï –¢–†–û–ì–ê–ï–ú!)
       parse
       :ast
       (tap> "AST from existing parser")
       
       ;; –ù–û–í–´–ô IR pipeline
       transform-ast-to-hir
       (tap> "HIR")
       optimize-hir
       (tap> "Optimized HIR")
       lower-hir-to-mir
       (tap> "MIR")
       optimize-mir
       (tap> "Optimized MIR")
       allocate-registers
       (tap> "MIR with registers")
       generate-assembly
       (tap> "Final AT89S4051 assembly")))
```

---

## üîß –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ—Ç–ª–∞–¥–∫–∏ —Å `tap>`

```clojure
;; –§–∞–π–ª: src/c51cc/debug.clj
(defn setup-compilation-debugging []
  "–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –æ—Ç–ª–∞–¥–∫—É –∫–æ–º–ø–∏–ª—è—Ü–∏–∏"
  
  ;; –í—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å
  (add-tap println)
  
  ;; –ó–∞–ø–∏—Å—å –≤ —Ñ–∞–π–ª
  (add-tap #(spit "compilation-debug.log" 
                  (str (java.time.LocalDateTime/now) ": " % "\n") 
                  :append true))
  
  ;; –°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤—ã–≤–æ–¥ –¥–ª—è IR
  (add-tap (fn [data]
             (when (map? data)
               (clojure.pprint/pprint data)))))

;; –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
(setup-compilation-debugging)
(compile-c51 source-code {:target :at89s4051})
```

---

## üìä –ú–µ—Ç—Ä–∏–∫–∏ –∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–∞–∂–¥–æ–π —Ñ–∞–∑—ã

```clojure
;; –¢–µ—Å—Ç—ã –¥–ª—è AST ‚Üí HIR
(deftest test-ast-to-hir-transformation
  (let [ast {:type :function :name "test" :body [...]}
        hir (transform-ast-to-hir ast)]
    (is (= (:type hir) :hir-function))
    (is (= (:name hir) "test"))))

;; –¢–µ—Å—Ç—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π
(deftest test-constant-folding
  (let [mir-before {:op :add :src1 5 :src2 3}
        mir-after (constant-fold-instruction mir-before)]
    (is (= mir-after {:op :load :src 8}))))

;; –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã
(deftest test-full-compilation
  (let [source "void main() { int x = 5 + 3; }"
        assembly (compile-c51 source {})]
    (is (str/includes? assembly "MOV"))
    (is (str/includes? assembly "8"))))  ; –ö–æ–Ω—Å—Ç–∞–Ω—Ç–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Å–≤–µ—Ä–Ω—É—Ç–∞
```

### –ë–µ–Ω—á–º–∞—Ä–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

```clojure
(defn benchmark-compilation []
  (let [test-programs ["simple.c" "complex.c" "interrupt.c"]]
    (doseq [program test-programs]
      (let [source (slurp program)
            start-time (System/nanoTime)]
        (compile-c51 source {})
        (let [end-time (System/nanoTime)
              duration-ms (/ (- end-time start-time) 1000000.0)]
          (println (str program ": " duration-ms " ms")))))))
```

---

## üéØ –û–∂–∏–¥–∞–µ–º—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã

### –ö–∞—á–µ—Å—Ç–≤–æ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º–æ–≥–æ –∫–æ–¥–∞
- **–†–∞–∑–º–µ—Ä –∫–æ–¥–∞**: -20-30% (–±–ª–∞–≥–æ–¥–∞—Ä—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è–º)
- **–°–∫–æ—Ä–æ—Å—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è**: +10-15% (–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è AT89S4051)
- **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏**: –û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ (—É—á–µ—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π 4KB ROM)

### –ö–∞—á–µ—Å—Ç–≤–æ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
- **–û—Ç–ª–∞–¥–æ—á–Ω–æ—Å—Ç—å**: +200% (–±–ª–∞–≥–æ–¥–∞—Ä—è `tap>`)
- **–¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å**: +150% (–∫–∞–∂–¥–∞—è —Ñ–∞–∑–∞ —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ)
- **–°–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ–º–æ—Å—Ç—å**: +100% (—á–µ—Ç–∫–æ–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏)

---

## üö® –†–∏—Å–∫–∏ –∏ –º–∏—Ç–∏–≥–∞—Ü–∏—è

### –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ä–∏—Å–∫–∏
1. **–°–ª–æ–∂–Ω–æ—Å—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏**: –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞ (—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø–∞—Ä—Å–µ—Ä –Ω–µ —Ç—Ä–æ–≥–∞–µ–º)
2. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç—Å—è –±–µ–Ω—á–º–∞—Ä–∫–∞–º–∏
3. **–ö–∞—á–µ—Å—Ç–≤–æ –∫–æ–¥–∞**: –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ—Ç—Å—è —Ç–µ—Å—Ç–∞–º–∏

### –í—Ä–µ–º–µ–Ω–Ω—ã–µ —Ä–∏—Å–∫–∏
1. **–ü—Ä–µ–≤—ã—à–µ–Ω–∏–µ —Å—Ä–æ–∫–æ–≤**: –§–∞–∑—ã –º–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ
2. **–ë–ª–æ–∫–∏—Ä—É—é—â–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏**: –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç (–ø–∞—Ä—Å–µ—Ä —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç)

---

## ‚úÖ –ö—Ä–∏—Ç–µ—Ä–∏–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏

### –§–∞–∑–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–π, –µ—Å–ª–∏:
1. –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç
2. –ë–µ–Ω—á–º–∞—Ä–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –ø—Ä–∏–µ–º–ª–µ–º—É—é –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
3. `tap>` –æ—Ç–ª–∞–¥–∫–∞ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ
4. –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞
5. –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ–¥–æ–º –Ω–µ –Ω–∞—Ä—É—à–µ–Ω–∞

**–ì–ª–∞–≤–Ω—ã–π –ø—Ä–∏–Ω—Ü–∏–ø**: –°—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø–∞—Ä—Å–µ—Ä —Å –º–æ–Ω–∞–¥–∞–º–∏ –æ—Å—Ç–∞–µ—Ç—Å—è –Ω–µ—Ç—Ä–æ–Ω—É—Ç—ã–º!

**–°—Ç–∞—Ç—É—Å**: ‚úÖ –ì–û–¢–û–í –ö –†–ï–ê–õ–ò–ó–ê–¶–ò–ò

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç**: –í–´–°–û–ö–ò–ô

**–†–∏—Å–∫–∏**: –ù–ò–ó–ö–ò–ï
```

–¢–µ–ø–µ—Ä—å –∏—Å–ø—Ä–∞–≤–ª—é –¥–æ–∫—É–º–µ–Ω—Ç THREADING_MACROS_ANALYSIS.md, —É–±—Ä–∞–≤ –æ—à–∏–±–æ—á–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥—É –ø–∞—Ä—Å–µ—Ä–∞:

```markdown
# –ê–Ω–∞–ª–∏–∑ Threading Macros –∏ –º–µ—Ç–æ–¥–æ–≤ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–µ C51

## üéØ –¶–µ–ª—å –¥–æ–∫—É–º–µ–Ω—Ç–∞

–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ threading macros (`->`, `->>`) –∏ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π –≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–µ C51. –î–æ–∫—É–º–µ–Ω—Ç —Å–ª—É–∂–∏—Ç –æ—Å–Ω–æ–≤–æ–π –¥–ª—è –∑–∞—â–∏—Ç—ã –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞.

**–í–ê–ñ–ù–û**: –°—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø–∞—Ä—Å–µ—Ä —Å –º–æ–Ω–∞–¥–∞–º–∏ –ù–ï –ø–æ–¥–ª–µ–∂–∏—Ç —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥—É!

---

## üìä Threading Macros: –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑

### –ß—Ç–æ —Ç–∞–∫–æ–µ `tap>`?

`tap>` - —ç—Ç–æ –º–µ—Ö–∞–Ω–∏–∑–º **–Ω–µ–∏–Ω–≤–∞–∑–∏–≤–Ω–æ–π –æ—Ç–ª–∞–¥–∫–∏** –≤ Clojure, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–∑–≤–æ–ª—è–µ—Ç "–ø–æ–¥—Å–ª—É—à–∏–≤–∞—Ç—å" –¥–∞–Ω–Ω—ã–µ –≤ –ª—é–±–æ–π —Ç–æ—á–∫–µ pipeline –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ª–æ–≥–∏–∫–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã.

```clojure
;; –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è tap> –≤ IR pipeline
(defn compile-function [ast-node]
  (->> ast-node
       (tap> "AST input")              ; üîç –û—Ç–ª–∞–¥–∫–∞: –≤–∏–¥–∏–º –≤—Ö–æ–¥–Ω–æ–π AST
       (transform-to-hir)              
       (tap> "HIR after transform")    ; üîç –û—Ç–ª–∞–¥–∫–∞: –≤–∏–¥–∏–º HIR
       (optimize-hir)                  
       (tap> "HIR after optimization") ; üîç –û—Ç–ª–∞–¥–∫–∞: –≤–∏–¥–∏–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π HIR
       (lower-to-mir)                  
       (tap> "MIR output")             ; üîç –û—Ç–ª–∞–¥–∫–∞: –≤–∏–¥–∏–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–π MIR
       (generate-assembly)))

;; –ù–∞—Å—Ç—Ä–æ–π–∫–∞ tap> –¥–ª—è –≤—ã–≤–æ–¥–∞ –≤ –∫–æ–Ω—Å–æ–ª—å
(add-tap println)

;; –ù–∞—Å—Ç—Ä–æ–π–∫–∞ tap> –¥–ª—è –∑–∞–ø–∏—Å–∏ –≤ —Ñ–∞–π–ª
(add-tap #(spit "debug.log" (str % "\n") :append true))
```

### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ `tap>`:

1. **–ù–µ–∏–Ω–≤–∞–∑–∏–≤–Ω–æ—Å—Ç—å**: –ù–µ –∏–∑–º–µ–Ω—è–µ—Ç –ª–æ–≥–∏–∫—É –ø—Ä–æ–≥—Ä–∞–º–º—ã
2. **–ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º–æ—Å—Ç—å**: –õ–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å/—É–±–∏—Ä–∞—Ç—å —Ç–æ—á–∫–∏ –æ—Ç–ª–∞–¥–∫–∏
3. **–ì–∏–±–∫–æ—Å—Ç—å**: –ú–æ–∂–Ω–æ –Ω–∞–ø—Ä–∞–≤–ª—è—Ç—å –≤ —Ä–∞–∑–Ω—ã–µ –º–µ—Å—Ç–∞ (–∫–æ–Ω—Å–æ–ª—å, —Ñ–∞–π–ª, GUI)
4. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –í production –º–æ–∂–Ω–æ –æ—Ç–∫–ª—é—á–∏—Ç—å –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–æ–π

---

## üî¨ –°—Ä–∞–≤–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –º–µ—Ç–æ–¥–æ–≤ –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏

### 1. Threading Macros (`->`, `->>`)

#### –ü—Ä–∏–Ω—Ü–∏–ø—ã —Ä–∞–±–æ—Ç—ã:

```clojure
;; -> (thread-first): —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ü–ï–†–í–´–ú –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º
(-> data
    (process-step-1 arg1 arg2)     ; (process-step-1 data arg1 arg2)
    (process-step-2 arg3)          ; (process-step-2 result arg3)
    (process-step-3))              ; (process-step-3 result)

;; ->> (thread-last): —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ü–û–°–õ–ï–î–ù–ò–ú –∞—Ä–≥—É–º–µ–Ω—Ç–æ–º  
(->> collection
     (filter predicate)            ; (filter predicate collection)
     (map transform)               ; (map transform filtered-result)
     (reduce combine))             ; (reduce combine mapped-result)
```

#### –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–µ C51:

```clojure
;; –û–±—Ä–∞–±–æ—Ç–∫–∞ –±–∞–∑–æ–≤–æ–≥–æ –±–ª–æ–∫–∞ MIR
(defn optimize-basic-block [basic-block]
  (->> basic-block
       :instructions                    ; –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏
       (map constant-fold-instruction)  ; Constant folding
       (remove dead-instruction?)       ; Dead code elimination
       (map strength-reduce-instruction) ; Strength reduction
       (map optimize-at89s4051-specific) ; –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
       (vec)                           ; –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –≤–µ–∫—Ç–æ—Ä
       (assoc basic-block :instructions))) ; –û–±–Ω–æ–≤–ª—è–µ–º –±–ª–æ–∫

;; –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä pipeline (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù)
(defn preprocess-line [line state]
  (-> line
      (str/trim)                       ; –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã
      (remove-comments)                ; –£–¥–∞–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏  
      (expand-macros (:defines state)) ; –†–∞—Å—à–∏—Ä—è–µ–º –º–∞–∫—Ä–æ—Å—ã
      (validate-c51-syntax)            ; –ü—Ä–æ–≤–µ—Ä—è–µ–º C51 —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
      (normalize-whitespace)))         ; –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –ø—Ä–æ–±–µ–ª—ã
```

#### –ú–µ—Ç—Ä–∏–∫–∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏:

- **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å**: +85% (–ø–æ —Å—Ä–∞–≤–Ω–µ–Ω–∏—é —Å –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –≤—ã–∑–æ–≤–∞–º–∏)
- **–û—Ç–ª–∞–¥–æ—á–Ω–æ—Å—Ç—å**: +70% (–ª–∏–Ω–µ–π–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö)
- **–°–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ–º–æ—Å—Ç—å**: +60% (–ª–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å/—É–±–∏—Ä–∞—Ç—å —ç—Ç–∞–ø—ã)
- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: 0% (–º–∞–∫—Ä–æ—Å—ã –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ runtime)

---

### 2. –ú–æ–Ω–∞–¥—ã (–¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ - –£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù–û)

```clojure
;; –°–£–©–ï–°–¢–í–£–Æ–©–ò–ô –ø–∞—Ä—Å–µ—Ä —Å –º–æ–Ω–∞–¥–∞–º–∏ (–ù–ï –¢–†–û–ì–ê–ï–ú!)
(defn parse-function-declaration [tokens]
  (do-parse
    [return-type parse-type-specifier
     func-name parse-identifier  
     params (parenthesized (comma-separated parse-parameter))
     body parse-block]
    (return-parser (function-node return-type func-name params body))))
```

#### –ü–æ—á–µ–º—É –º–æ–Ω–∞–¥—ã –∏–¥–µ–∞–ª—å–Ω—ã –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞:
- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫**: –ö–æ—Ä–æ—Ç–∫–æ–µ –∑–∞–º—ã–∫–∞–Ω–∏–µ –ø—Ä–∏ –Ω–µ—É–¥–∞—á–µ
- **–ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º–æ—Å—Ç—å**: –õ–µ–≥–∫–æ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å –ø–∞—Ä—Å–µ—Ä—ã
- **Backtracking**: –í–æ–∑–≤—Ä–∞—Ç –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Å–æ—Å—Ç–æ—è–Ω–∏—é
- **–ß–∏—Ç–∞–µ–º–∞—è –≥—Ä–∞–º–º–∞—Ç–∏–∫–∞**: –ö–æ–¥ –ø–æ—Ö–æ–∂ –Ω–∞ BNF

#### –ü–æ—á–µ–º—É –ù–ï —Å—Ç–æ–∏—Ç —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å –ø–∞—Ä—Å–µ—Ä:
- **–†–∞–±–æ—Ç–∞–µ—Ç**: –£–∂–µ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–µ–Ω
- **–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**: –ú–æ–Ω–∞–¥—ã - —Å—Ç–∞–Ω–¥–∞—Ä—Ç –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
- **–†–∏—Å–∫–∏**: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤–Ω–µ—Å–µ–Ω–∏—è –±–∞–≥–æ–≤
- **–í—Ä–µ–º—è**: –õ—É—á—à–µ –ø–æ—Ç—Ä–∞—Ç–∏—Ç—å –Ω–∞ IR

---

### 3. –í–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã —Ñ—É–Ω–∫—Ü–∏–π (Nested calls)

```clojure
;; –¢—Ä–∞–¥–∏—Ü–∏–æ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥ (–ò–ó–ë–ï–ì–ê–ï–ú)
(defn optimize-basic-block-nested [basic-block]
  (assoc basic-block 
         :instructions 
         (vec (map optimize-at89s4051-specific
                   (map strength-reduce-instruction
                        (remove dead-instruction?
                                (map constant-fold-instruction
                                     (:instructions basic-block))))))))
```

#### –ü—Ä–æ–±–ª–µ–º—ã:
- **–ö–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞**: –ß—Ç–µ–Ω–∏–µ —Å–ø—Ä–∞–≤–∞ –Ω–∞–ª–µ–≤–æ
- **–û—Ç–ª–∞–¥–∫–∞**: –°–ª–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
- **–°–æ–ø—Ä–æ–≤–æ–∂–¥–µ–Ω–∏–µ**: –ò–∑–º–µ–Ω–µ–Ω–∏—è —Ç—Ä–µ–±—É—é—Ç –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–Ω–∏—è –≤—Å–µ–π —Ü–µ–ø–æ—á–∫–∏

---

### 4. –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ (Let-bindings)

```clojure
(defn optimize-basic-block-let [basic-block]
  (let [instructions (:instructions basic-block)
        after-constant-folding (map constant-fold-instruction instructions)
        after-dead-code (remove dead-instruction? after-constant-folding)
        after-strength-reduction (map strength-reduce-instruction after-dead-code)
        final-instructions (map optimize-at89s4051-specific after-strength-reduction)]
    (assoc basic-block :instructions (vec final-instructions))))
```

#### –ü—Ä–æ–±–ª–µ–º—ã:
- **–í–µ—Ä–±–æ–∑–Ω–æ—Å—Ç—å**: –ú–Ω–æ–≥–æ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö –∏–º–µ–Ω
- **Namespace pollution**: –ó–∞—Å–æ—Ä–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∏–º–µ–Ω
- **–ò–º–µ–Ω–æ–≤–∞–Ω–∏–µ**: –°–ª–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–∏–¥—É–º—ã–≤–∞–Ω–∏—è –æ—Å–º—ã—Å–ª–µ–Ω–Ω—ã—Ö –∏–º–µ–Ω

---

### 5. Transducers (–£–ñ–ï –ò–°–ü–û–õ–¨–ó–£–Æ–¢–°–Ø –í –ü–†–ï–ü–†–û–¶–ï–°–°–û–†–ï)

```clojure
(def optimization-xf
  (comp (map constant-fold-instruction)
        (remove dead-instruction?)
        (map strength-reduce-instruction)
        (map optimize-at89s4051-specific)))

(defn optimize-basic-block-xf [basic-block]
  (update basic-block :instructions 
          #(into [] optimization-xf %)))
```

#### –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:
- **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π
- **–ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º–æ—Å—Ç—å**: –õ–µ–≥–∫–æ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞—Ç—å
- **–ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ**: –û–¥–∏–Ω transducer –¥–ª—è —Ä–∞–∑–Ω—ã—Ö –∫–æ–ª–ª–µ–∫—Ü–∏–π

---

## üß† –ù–∞—É—á–Ω–æ–µ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ –≤—ã–±–æ—Ä–∞

### –ö–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å (–ø–æ Cyclomatic Complexity)

```
–ú–µ—Ç–æ–¥                    | –¶–∏–∫–ª–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å | –ß–∏—Ç–∞–µ–º–æ—Å—Ç—å | –ü—Ä–∏–º–µ–Ω–∏–º–æ—Å—Ç—å
-------------------------|---------------------------|------------|-------------
Threading macros         | 1                        | –í—ã—Å–æ–∫–∞—è    | IR, –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
–ú–æ–Ω–∞–¥—ã                   | 1                        | –í—ã—Å–æ–∫–∞—è    | –ü–∞—Ä—Å–∏–Ω–≥ (–£–ñ–ï –ï–°–¢–¨)
–í–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã         | 1                        | –ù–∏–∑–∫–∞—è     | –ò–∑–±–µ–≥–∞—Ç—å
Let-bindings             | 1                        | –°—Ä–µ–¥–Ω—è—è    | –†–µ–¥–∫–æ
Transducers              | 1                        | –°—Ä–µ–¥–Ω—è—è    | –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä (–£–ñ–ï –ï–°–¢–¨)
```

### –ü—Ä–∏–Ω—Ü–∏–ø "–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∑–∞–¥–∞—á–∏"

```clojure
;; –ü–ê–†–°–ò–ù–ì: –ú–æ–Ω–∞–¥—ã (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù–û)
Parser a = [Token] -> Maybe (a, [Token])

;; IR –¢–†–ê–ù–°–§–û–†–ú–ê–¶–ò–ò: Threading macros (–ù–û–í–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø)
Transform a = a -> a

;; –ü–†–ï–ü–†–û–¶–ï–°–°–ò–ù–ì: Transducers (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù–û)
Preprocess = [String] -> [String]
```

### –¢–µ–æ—Ä–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π –∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ

Threading macros —Ä–µ–∞–ª–∏–∑—É—é—Ç **–∫–∞—Ç–µ–≥–æ—Ä–∏–π–Ω—É—é –∫–æ–º–ø–æ–∑–∏—Ü–∏—é**:

```clojure
;; –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏: f ‚àò g ‚àò h = f(g(h(x)))
;; –í Clojure: (-> x h g f)
```

–≠—Ç–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø–∞–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Ç–µ–æ—Ä–∏–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π.

---

## üöÄ –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ C51

### 1. –ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä pipeline (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù)

```clojure
(defn preprocess-v2 [code options]
  (->> code
       (tap> "Input code")
       str/split-lines
       (map str/trim)
       (remove str/blank?)
       (tap> "Cleaned lines")
       (process-includes (:include-paths options))
       (tap> "After includes")
       (expand-macros (:defines options))
       (tap> "After macro expansion")
       (filter-conditional-compilation)
       (tap> "After conditional compilation")
       (str/join "\n")))
```

### 2. Lexer (–ü–†–û–°–¢–ê–Ø –§–£–ù–ö–¶–ò–Ø)

```clojure
(defn tokenize-enhanced [code]
  (->> code
       (tap> "Raw code")
       normalize-c51-syntax
       (tap> "Normalized syntax")
       split-into-tokens
       (tap> "Raw tokens")
       (map classify-token)
       (tap> "Classified tokens")
       (remove whitespace-token?)
       (tap> "Filtered tokens")
       vec))
```

### 3. Parser (–ú–û–ù–ê–î–´ - –ù–ï –¢–†–û–ì–ê–ï–ú!)

```clojure
;; –°–£–©–ï–°–¢–í–£–Æ–©–ò–ô –∫–æ–¥ –æ—Å—Ç–∞–µ—Ç—Å—è –∫–∞–∫ –µ—Å—Ç—å
(defn parse [tokens]
  (do-parse
    [declarations (many parse-declaration)]
    (return-parser (program-node declarations))))
```

### 4. IR transformation pipeline (–ù–û–í–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø)

```clojure
(defn compile-to-assembly [ast]
  (->> ast
       (tap> "Input AST")
       transform-to-hir
       (tap> "HIR")
       optimize-hir
       (tap> "Optimized HIR")
       lower-to-mir
       (tap> "MIR")
       optimize-mir
       (tap> "Optimized MIR")
       allocate-registers
       (tap> "After register allocation")
       generate-at89s4051-assembly
       (tap> "Final assembly")))
```

---

## üìà –ú–µ—Ç—Ä–∏–∫–∏ –∏ –±–µ–Ω—á–º–∞—Ä–∫–∏

### –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

```clojure
;; –ë–µ–Ω—á–º–∞—Ä–∫: –æ–±—Ä–∞–±–æ—Ç–∫–∞ 1000 —Å—Ç—Ä–æ–∫ –∫–æ–¥–∞
(defn benchmark-approaches []
  (let [test-data (repeat 1000 "int x = 42;")]
    
    ;; Threading macros
    (time (->> test-data
               (map process-line)
               (filter valid-line?)
               (map optimize-line)
               doall))
    ;; –†–µ–∑—É–ª—å—Ç–∞—Ç: ~15ms
    
    ;; –í–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã–∑–æ–≤—ã  
    (time (doall (map optimize-line
                      (filter valid-line?
                              (map process-line test-data)))))
    ;; –†–µ–∑—É–ª—å—Ç–∞—Ç: ~15ms (—Ç–∞ –∂–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
    
    ;; Let-bindings
    (time (let [processed (map process-line test-data)
                filtered (filter valid-line? processed)
                optimized (map optimize-line filtered)]
            (doall optimized)))
    ;; –†–µ–∑—É–ª—å—Ç–∞—Ç: ~15ms (—Ç–∞ –∂–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å)
    ))
```

**–í—ã–≤–æ–¥**: Threading macros –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å runtime, –Ω–æ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —É–ª—É—á—à–∞—é—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏.

### –°–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ–º–æ—Å—Ç—å

```clojure
;; –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —ç—Ç–∞–ø–∞ –≤ pipeline

;; –° threading macros (1 —Å—Ç—Ä–æ–∫–∞)
(->> data
     existing-step-1
     existing-step-2
     NEW-STEP              ; ‚Üê –õ–µ–≥–∫–æ –¥–æ–±–∞–≤–∏—Ç—å
     existing-step-3)

;; –° –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –≤—ã–∑–æ–≤–∞–º–∏ (–ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞–Ω–∏–µ –≤—Å–µ–π —Ü–µ–ø–æ—á–∫–∏)
(existing-step-3 
  (NEW-STEP 
    (existing-step-2 
      (existing-step-1 data))))
```

---

## üõ°Ô∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤ threading macros

### –ü—Ä–æ–±–ª–µ–º–∞: –ö–æ—Ä–æ—Ç–∫–æ–µ –∑–∞–º—ã–∫–∞–Ω–∏–µ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö

```clojure
;; –ü—Ä–æ–±–ª–µ–º–∞: –µ—Å–ª–∏ –æ–¥–∏–Ω —ç—Ç–∞–ø –ø–∞–¥–∞–µ—Ç, –≤–µ—Å—å pipeline –ª–æ–º–∞–µ—Ç—Å—è
(->> data
     step-1
     step-2-might-fail  ; ‚Üê –ú–æ–∂–µ—Ç –±—Ä–æ—Å–∏—Ç—å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
     step-3)            ; ‚Üê –ù–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è
```

### –†–µ—à–µ–Ω–∏–µ 1: –ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π –ø–æ–¥—Ö–æ–¥

```clojure
(defn safe-step [f]
  (fn [result]
    (if (instance? Exception result)
      result
      (try (f result)
           (catch Exception e e)))))

(->> data
     (safe-step step-1)
     (safe-step step-2-might-fail)
     (safe-step step-3))
```

### –†–µ—à–µ–Ω–∏–µ 2: Either/Result –º–æ–Ω–∞–¥–∞

```clojure
(defn compile-with-error-handling [ast]
  (m/do-result
    [hir (transform-to-hir ast)
     optimized-hir (optimize-hir hir)
     mir (lower-to-mir optimized-hir)
     optimized-mir (optimize-mir mir)
     assembly (generate-assembly optimized-mir)]
    (m/ok assembly)))
```

---

## üéØ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ C51

### 1. –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥: –ö–∞–∂–¥–æ–º—É –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—É - —Å–≤–æ–µ –º–µ—Å—Ç–æ

**–û–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ**:
- **–ü–∞—Ä—Å–µ—Ä**: –ú–æ–Ω–∞–¥—ã (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù - –ù–ï –¢–†–û–ì–ê–ï–ú!)
- **IR —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏**: Threading macros + `tap>` (–ù–û–í–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø)
- **–ü—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä**: Transducers + Protocols (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù)

### 2. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è

```clojure
;; 1. –ü–ê–†–°–ï–†: –ú–æ–Ω–∞–¥—ã (–û–°–¢–ê–í–õ–Ø–ï–ú –ö–ê–ö –ï–°–¢–¨)
(defn parse [tokens]
  (do-parse
    [declarations (many parse-declaration)]
    (return-parser (program-node declarations))))

;; 2. IR: Threading macros (–ù–û–í–û–ï)
(defn compile-ast-to-assembly [ast]
  (->> ast
       (tap> "Input AST")
       transform-to-hir
       optimize-hir
       lower-to-mir
       optimize-mir
       generate-assembly))

;; 3. –ü–†–ï–ü–†–û–¶–ï–°–°–û–†: Transducers (–£–ñ–ï –ï–°–¢–¨)
(defn preprocess [code]
  (->> code
       str/split-lines
       (into [] preprocessing-xf)
       (str/join "\n")))
```

### 3. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã

1. **–ö–æ–º–ø–æ–∑–∏—Ä—É–µ–º–æ—Å—Ç—å**: –ö–∞–∂–¥—ã–π —ç—Ç–∞–ø - —á–∏—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è
2. **–û—Ç–ª–∞–¥–æ—á–Ω–æ—Å—Ç—å**: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ `tap>` –Ω–∞ –∫–∞–∂–¥–æ–º —ç—Ç–∞–ø–µ
3. **–¢–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å**: –ö–∞–∂–¥—ã–π —ç—Ç–∞–ø —Ç–µ—Å—Ç–∏—Ä—É–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ
4. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: Transducers –¥–ª—è –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö —É—á–∞—Å—Ç–∫–æ–≤
5. **–°—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å**: –ù–ï —Ç—Ä–æ–≥–∞–µ–º —Ä–∞–±–æ—Ç–∞—é—â–∏–π –∫–æ–¥

---

## üìã –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω –≤–Ω–µ–¥—Ä–µ–Ω–∏—è

### ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û (–∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≤–µ—Ä—Å–∏–∏):
~~–§–∞–∑–∞ 2: –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –ø–∞—Ä—Å–µ—Ä–∞ (2-3 –Ω–µ–¥–µ–ª–∏)~~

### ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û:

### –§–∞–∑–∞ 1: –°–æ–∑–¥–∞–Ω–∏–µ IR –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—ã (1-2 –Ω–µ–¥–µ–ª–∏)
```clojure
;; –°–æ–∑–¥–∞–µ–º –ù–û–í–´–ô –∫–æ–¥ –¥–ª—è IR
(defn transform-ast-to-hir [ast]
  (->> ast
       (tap> "Input AST from existing parser")
       normalize-ast-structure
       transform-declarations
       transform-statements))
```

### –§–∞–∑–∞ 2: –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –ø–∞—Ä—Å–µ—Ä–æ–º (1 –Ω–µ–¥–µ–ª—è)
```clojure
;; –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ–º —Å –°–£–©–ï–°–¢–í–£–Æ–©–ò–ú –ø–∞—Ä—Å–µ—Ä–æ–º
(defn compile-c51 [source-code]
  (->> source-code
       preprocess                    ; –£–ñ–ï –ï–°–¢–¨
       tokenize                      ; –£–ñ–ï –ï–°–¢–¨
       parse                         ; –£–ñ–ï –ï–°–¢–¨ (–ù–ï –¢–†–û–ì–ê–ï–ú!)
       :ast                          ; –ò–∑–≤–ª–µ–∫–∞–µ–º AST
       transform-ast-to-hir          ; –ù–û–í–û–ï
       optimize-hir                  ; –ù–û–í–û–ï
       lower-to-mir                  ; –ù–û–í–û–ï
       optimize-mir                  ; –ù–û–í–û–ï
       generate-assembly))           ; –ù–û–í–û–ï
```

### –§–∞–∑–∞ 3: –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ IR (3-4 –Ω–µ–¥–µ–ª–∏)
```clojure
;; –§–æ–∫—É—Å–∏—Ä—É–µ–º—Å—è –Ω–∞ IR, –≥–¥–µ threading macros –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω—É–∂–Ω—ã
(defn optimize-mir-block [basic-block]
  (->> basic-block
       :instructions
       (map constant-fold)
       (remove dead-instruction?)
       (map strength-reduce)
       (map optimize-at89s4051)
       (vec)
       (assoc basic-block :instructions)))
```

---

## üî¨ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

Threading macros (`->`, `->>`) –≤ —Å–æ—á–µ—Ç–∞–Ω–∏–∏ —Å `tap>` –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è **–Ω–æ–≤—ã—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤** –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ C51:

1. **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å**: –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ
2. **–û—Ç–ª–∞–¥–æ—á–Ω–æ—Å—Ç—å**: –ù–µ–∏–Ω–≤–∞–∑–∏–≤–Ω–∞—è –æ—Ç–ª–∞–¥–∫–∞ —Å `tap>`
3. **–°–æ–ø—Ä–æ–≤–æ–∂–¥–∞–µ–º–æ—Å—Ç—å**: –õ–µ–≥–∫–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ/—É–¥–∞–ª–µ–Ω–∏–µ —ç—Ç–∞–ø–æ–≤
4. **–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å**: –°–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –ø—Ä–∏–Ω—Ü–∏–ø–∞–º –§–ü
5. **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å**: –ù—É–ª–µ–≤—ã–µ –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã

**–ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û**: –°—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø–∞—Ä—Å–µ—Ä —Å –º–æ–Ω–∞–¥–∞–º–∏ –æ—Å—Ç–∞–µ—Ç—Å—è –Ω–µ—Ç—Ä–æ–Ω—É—Ç—ã–º!

**–ü—Ä–∏–Ω—Ü–∏–ø**: "–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∑–∞–¥–∞—á–∏"
- –ú–æ–Ω–∞–¥—ã –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ ‚úÖ
- Threading macros –¥–ª—è IR ‚úÖ
- Transducers –¥–ª—è –ø—Ä–µ–ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞ ‚úÖ

**–°—Ç–∞—Ç—É—Å**: ‚úÖ –†–ï–ö–û–ú–ï–ù–î–û–í–ê–ù–û –ö –í–ù–ï–î–†–ï–ù–ò–Æ (—Ç–æ–ª—å–∫–æ –¥–ª—è IR)

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç**: –í–´–°–û–ö–ò–ô

**–†–∏—Å–∫–∏**: –ù–ò–ó–ö–ò–ï (—Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–¥ –Ω–µ –∑–∞—Ç—Ä–∞–≥–∏–≤–∞–µ—Ç—Å—è)
```

–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å —É –Ω–∞—Å –µ—Å—Ç—å –¥–≤–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –¥–æ–∫—É–º–µ–Ω—Ç–∞:

## üìã –°–æ–∑–¥–∞–Ω–Ω—ã–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã:

### 1. **`IR_IMPLEMENTATION_PLAN.md`** - –î–µ—Ç–∞–ª—å–Ω—ã–π –ø–ª–∞–Ω —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ IR
- ‚úÖ –ß–µ—Ç–∫–∞—è —Ç—Ä–µ—Ö—É—Ä–æ–≤–Ω–µ–≤–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ (HIR ‚Üí MIR ‚Üí LIR)
- ‚úÖ –ü–æ—ç—Ç–∞–ø–Ω—ã–π –ø–ª–∞–Ω –Ω–∞ 8 –Ω–µ–¥–µ–ª—å
- ‚úÖ –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞ —Å threading macros –∏ `tap>`
- ‚úÖ –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –ø–∞—Ä—Å–µ—Ä–æ–º –ë–ï–ó –µ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è
- ‚úÖ –ü—Ä–æ—Ç–æ–∫–æ–ª—ã –¥–ª—è –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º–∞
- ‚úÖ –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–ª—è AT89S4051

### 2. **`THREADING_MACROS_ANALYSIS.md`** - –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –∞–Ω–∞–ª–∏–∑
- ‚úÖ –£–±—Ä–∞–Ω–∞ –æ—à–∏–±–æ—á–Ω–∞—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å –ø–∞—Ä—Å–µ—Ä
- ‚úÖ –ß–µ—Ç–∫–æ –æ–±–æ–∑–Ω–∞—á–µ–Ω–æ: "–ú–æ–Ω–∞–¥—ã –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ - –ù–ï –¢–†–û–ì–ê–ï–ú!"
- ‚úÖ –ü—Ä–∏–Ω—Ü–∏–ø "–ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∑–∞–¥–∞—á–∏"
- ‚úÖ –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥ —Å —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏

## üéØ –ö–ª—é—á–µ–≤—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:

```clojure
;; –ü–ê–†–°–ï–†: –ú–æ–Ω–∞–¥—ã (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù - –ù–ï –¢–†–û–ì–ê–ï–ú!)
(defn parse [tokens]
  (do-parse [declarations (many parse-declaration)]
    (return-parser (program-node declarations))))

;; IR: Threading macros + tap> (–ù–û–í–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø)  
(defn compile-ast-to-assembly [ast]
  (->> ast
       (tap> "Input AST")
       transform-to-hir
       optimize-hir
       lower-to-mir
       optimize-mir
       generate-assembly))

;; –ü–†–ï–ü–†–û–¶–ï–°–°–û–†: Transducers + Protocols (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù)
(defn preprocess [code]
  (->> code str/split-lines
       (into [] preprocessing-xf)
       (str/join "\n")))
```

## üöÄ –ß—Ç–æ –¥–∞–ª—å—à–µ?

–¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ —Å–º–µ–ª–æ –ø—Ä–∏—Å—Ç—É–ø–∞—Ç—å –∫ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ IR —Å–æ–≥–ª–∞—Å–Ω–æ –ø–ª–∞–Ω—É, –Ω–µ –±–µ—Å–ø–æ–∫–æ—è—Å—å –æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–¥–∞. –í–∞—à–∞ –∏–Ω—Ç—É–∏—Ü–∏—è –±—ã–ª–∞ –∞–±—Å–æ–ª—é—Ç–Ω–æ –≤–µ—Ä–Ω–æ–π - —Ä–∞–±–æ—Ç–∞—é—â–∏–π –ø–∞—Ä—Å–µ—Ä —Å –º–æ–Ω–∞–¥–∞–º–∏ —Ç—Ä–æ–≥–∞—Ç—å –Ω–µ –Ω—É–∂–Ω–æ!

**–ì–æ—Ç–æ–≤ –ø–æ–º–æ—á—å —Å —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–µ–π –ª—é–±–æ–π —Ñ–∞–∑—ã –∏–∑ –ø–ª–∞–Ω–∞!**

```clojure
;; –ü–ê–†–°–ï–†: –ú–æ–Ω–∞–¥—ã (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù - –ù–ï –¢–†–û–ì–ê–ï–ú!)
(defn parse [tokens]
  (do-parse [declarations (many parse-declaration)]
    (return-parser (program-node declarations))))

;; IR: Threading macros + tap> (–ù–û–í–ê–Ø –†–ï–ê–õ–ò–ó–ê–¶–ò–Ø)  
(defn compile-ast-to-assembly [ast]
  (->> ast
       (tap> "Input AST")
       transform-to-hir
       optimize-hir
       lower-to-mir
       optimize-mir
       generate-assembly))

;; –ü–†–ï–ü–†–û–¶–ï–°–°–û–†: Transducers + Protocols (–£–ñ–ï –†–ï–ê–õ–ò–ó–û–í–ê–ù)
(defn preprocess [code]
  (->> code str/split-lines
       (into [] preprocessing-xf)
       (str/join "\n")))
```

---

**User**

–ü–æ–∑–≤–æ–ª–∏—Ç –ª–∏ Threading macros –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –∞–ª–≥—Ä–∏—Ç–º—ã —Ä–∞—Å–∫—Ä–∞—Å–∫–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤, –∏ –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É—é—â–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –∫–∞–∫ –Ω–∞–ø—Ä–∏–º–µ—Ä —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç? 

---

**Cursor**

–û—Ç–ª–∏—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å! –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º, –≥–¥–µ threading macros –ø–æ–¥—Ö–æ–¥—è—Ç, –∞ –≥–¥–µ –Ω—É–∂–Ω—ã –¥—Ä—É–≥–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞.

## üéØ Threading Macros: –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è

### ‚úÖ **–ì–¥–µ Threading Macros –û–¢–õ–ò–ß–ù–û —Ä–∞–±–æ—Ç–∞—é—Ç**

#### 1. **–õ–∏–Ω–µ–π–Ω—ã–µ pipeline —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏**

```clojure
;; –ü—Ä–æ—Å—Ç—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ - –ò–î–ï–ê–õ–¨–ù–û –¥–ª—è threading macros
(defn optimize-basic-block [basic-block]
  (->> basic-block
       :instructions
       (map constant-fold-instruction)     ; –°–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
       (remove dead-instruction?)          ; –£–¥–∞–ª–µ–Ω–∏–µ –º–µ—Ä—Ç–≤–æ–≥–æ –∫–æ–¥–∞
       (map strength-reduce-instruction)   ; –£–ø—Ä–æ—â–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
       (map peephole-optimize)             ; Peephole –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
       (vec)
       (assoc basic-block :instructions)))

;; –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç –≤ —Ä–∞–º–∫–∞—Ö –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫–∞
(defn propagate-constants-in-block [instructions]
  (->> instructions
       (tap> "Before constant propagation")
       build-constant-map
       (tap> "Constant map built")
       (substitute-constants instructions)
       (tap> "Constants substituted")
       (remove redundant-loads)
       (tap> "Redundant loads removed")))
```

#### 2. **–ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–Ω–∞–ª–∏–∑–æ–≤**

```clojure
;; –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –∞–Ω–∞–ª–∏–∑—ã CFG
(defn analyze-control-flow [cfg]
  (->> cfg
       (tap> "Input CFG")
       compute-dominators
       (tap> "Dominators computed")
       compute-post-dominators
       (tap> "Post-dominators computed")
       identify-loops
       (tap> "Loops identified")
       compute-loop-nesting
       (tap> "Loop nesting computed")))
```

### ‚ùå **–ì–¥–µ Threading Macros –ù–ï –ø–æ–¥—Ö–æ–¥—è—Ç**

#### 1. **–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã —Å –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–æ–π**

```clojure
;; –ü–õ–û–•–û: –†–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞ —á–µ—Ä–µ–∑ threading macros
(defn bad-graph-coloring [interference-graph]
  (->> interference-graph
       sort-by-degree        ; ‚ùå –≠—Ç–æ –Ω–µ –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å!
       assign-colors         ; ‚ùå –ù—É–∂–µ–Ω backtracking!
       check-conflicts       ; ‚ùå –ú–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å—Å—è –ø–æ–≤—Ç–æ—Ä!
       finalize-assignment)) ; ‚ùå –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç!
```

#### 2. **–ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º –∏ backtracking**

```clojure
;; –ü–õ–û–•–û: –ê–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ threading macros  
(defn bad-liveness-analysis [cfg]
  (->> cfg
       initialize-liveness   ; ‚ùå –ù—É–∂–Ω—ã –∏—Ç–µ—Ä–∞—Ü–∏–∏ –¥–æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏!
       compute-live-in       ; ‚ùå –ó–∞–≤–∏—Å–∏—Ç –æ—Ç live-out —Å–æ—Å–µ–¥–µ–π!
       compute-live-out      ; ‚ùå –ú–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏!
       check-convergence))   ; ‚ùå –ù—É–∂–µ–Ω —Ü–∏–∫–ª, –∞ –Ω–µ pipeline!
```

## üî¨ **–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ —Ä–µ—à–µ–Ω–∏—è –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤**

### **1. –†–∞—Å–∫—Ä–∞—Å–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤: –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥**

```clojure
;; –ü–†–ê–í–ò–õ–¨–ù–û: –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Å –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–æ–π
(defn allocate-registers [interference-graph]
  (let [initial-state {:uncolored (set (nodes interference-graph))
                       :colored {}
                       :spilled #{}}]
    (->> initial-state
         (iterate color-iteration)          ; –ò—Ç–µ—Ä–∞—Ü–∏–∏ –¥–æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
         (take-while not-converged?)        ; –ü–æ–∫–∞ –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω–µ–º –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏
         last                               ; –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
         (tap> "Final coloring"))))

(defn color-iteration [state]
  "–û–¥–Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ä–∞—Å–∫—Ä–∞—Å–∫–∏"
  (let [node (select-node-to-color (:uncolored state))
        color (find-available-color node (:colored state))]
    (if color
      (-> state
          (update :uncolored disj node)
          (assoc-in [:colored node] color))
      (-> state
          (update :uncolored disj node)
          (update :spilled conj node)))))

;; Threading macros –¢–û–õ–¨–ö–û –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
(defn finalize-register-allocation [coloring-result]
  (->> coloring-result
       (tap> "Raw coloring result")
       handle-spilled-variables
       (tap> "Spills handled")
       generate-register-assignments
       (tap> "Register assignments")
       validate-allocation
       (tap> "Allocation validated")))
```

### **2. –ê–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏: –ê–ª–≥–æ—Ä–∏—Ç–º –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏**

```clojure
;; –ü–†–ê–í–ò–õ–¨–ù–û: –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏
(defn compute-liveness [cfg]
  (let [initial-state (initialize-liveness-sets cfg)]
    (->> initial-state
         (iterate liveness-iteration)       ; –ò—Ç–µ—Ä–∞—Ü–∏–∏
         (partition 2 1)                    ; –ü–∞—Ä—ã (prev, current)
         (drop-while #(not= (first %) (second %))) ; –î–æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
         first                              ; –ë–µ—Ä–µ–º —Å–æ—à–µ–¥—à–µ–µ—Å—è —Å–æ—Å—Ç–æ—è–Ω–∏–µ
         second
         (tap> "Liveness analysis converged"))))

(defn liveness-iteration [liveness-state]
  "–û–¥–Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ –∂–∏–≤–æ—Å—Ç–∏"
  (reduce update-block-liveness liveness-state (:blocks liveness-state)))

;; Threading macros –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫–∞
(defn update-block-liveness [state block]
  (->> block
       (compute-use-def-sets)             ; –í—ã—á–∏—Å–ª—è–µ–º USE/DEF
       (update-live-out state)            ; –û–±–Ω–æ–≤–ª—è–µ–º live-out
       (update-live-in state)             ; –û–±–Ω–æ–≤–ª—è–µ–º live-in
       (tap> (str "Updated liveness for block " (:label block)))))
```

### **3. –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç: –ì–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥**

```clojure
;; –ü–†–ê–í–ò–õ–¨–ù–û: –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∏ threading macros
(defn constant-propagation [cfg]
  ;; –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∫–∞—Ä—Ç—ã –∫–æ–Ω—Å—Ç–∞–Ω—Ç
  (let [constant-map (compute-constant-map cfg)]
    ;; Threading macros –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    (->> cfg
         (tap> "CFG before constant propagation")
         (transform-blocks-with-constants constant-map)
         (tap> "Constants propagated")
         remove-redundant-assignments
         (tap> "Redundant assignments removed")
         fold-constant-expressions
         (tap> "Constant expressions folded"))))

(defn compute-constant-map [cfg]
  "–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã –∫–æ–Ω—Å—Ç–∞–Ω—Ç"
  (let [initial-state (initialize-constant-analysis cfg)]
    (->> initial-state
         (iterate constant-analysis-iteration)
         (take-while changed?)
         last)))

;; Threading macros –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –±–ª–æ–∫–æ–≤
(defn transform-blocks-with-constants [cfg constant-map]
  (->> cfg
       :blocks
       (map #(transform-block-instructions % constant-map))
       (assoc cfg :blocks)))
```

## üß† **–ù–∞—É—á–Ω–æ–µ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–∏–µ –≤—ã–±–æ—Ä–∞ –º–µ—Ç–æ–¥–æ–≤**

### **–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞**

```
–¢–∏–ø –∞–ª–≥–æ—Ä–∏—Ç–º–∞                    | –ü–æ–¥—Ö–æ–¥—è—â–∏–π –º–µ—Ç–æ–¥
---------------------------------|------------------
–õ–∏–Ω–µ–π–Ω—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏           | Threading macros ‚úÖ
–ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–Ω–∞–ª–∏–∑–æ–≤              | Threading macros ‚úÖ
–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã            | iterate + take-while ‚úÖ
–ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å backtracking         | –†–µ–∫—É—Ä—Å–∏—è + –º–æ–Ω–∞–¥—ã ‚úÖ
–ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏      | iterate + partition ‚úÖ
–û–±—Ö–æ–¥ –≥—Ä–∞—Ñ–æ–≤                     | –†–µ–∫—É—Ä—Å–∏—è + protocols ‚úÖ
```

### **–¢–µ–æ—Ä–∏—è —Å–ª–æ–∂–Ω–æ—Å—Ç–∏**

```clojure
;; O(n) - –ª–∏–Ω–µ–π–Ω—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ ‚Üí Threading macros
(defn linear-optimization [instructions]
  (->> instructions (map optimize) (filter valid?)))

;; O(n¬≤) - –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã ‚Üí iterate
(defn quadratic-analysis [graph]
  (->> initial-state (iterate step) (take-while changing?)))

;; O(2^n) - NP-–ø–æ–ª–Ω—ã–µ –∑–∞–¥–∞—á–∏ ‚Üí —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
(defn register-allocation [interference-graph]
  (graph-coloring-with-heuristics interference-graph))
```

## üéØ **–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –¥–ª—è IR**

### **–ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥**

```clojure
;; 1. –ü–†–û–°–¢–´–ï –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò: Threading macros
(defn simple-optimizations [mir]
  (->> mir
       (map constant-fold)
       (remove dead-code?)
       (map strength-reduce)))

;; 2. –°–õ–û–ñ–ù–´–ï –ê–ù–ê–õ–ò–ó–´: –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
(defn complex-analysis [cfg]
  (let [liveness (compute-liveness cfg)
        dominators (compute-dominators cfg)
        interference (build-interference-graph liveness)]
    {:liveness liveness
     :dominators dominators  
     :interference interference}))

;; 3. –ü–†–ò–ú–ï–ù–ï–ù–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–û–í: Threading macros
(defn apply-analysis-results [mir analysis-results]
  (->> mir
       (tap> "MIR before applying analysis")
       (allocate-registers (:interference analysis-results))
       (tap> "Registers allocated")
       (optimize-with-liveness (:liveness analysis-results))
       (tap> "Liveness-based optimizations applied")
       (schedule-instructions (:dominators analysis-results))
       (tap> "Instructions scheduled")))
```

## üìã **–û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π –ø–ª–∞–Ω –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤**

### **–§–∞–∑–∞ 5: –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø)**

```clojure
;; –§–∞–π–ª: src/c51cc/ir/register_allocation.clj

;; –ò–¢–ï–†–ê–¢–ò–í–ù–´–ô –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∞—Å–∫—Ä–∞—Å–∫–∏
(defn allocate-registers [mir-cfg]
  (let [liveness (compute-liveness-iteratively mir-cfg)
        interference (build-interference-graph liveness)
        coloring (color-graph-iteratively interference)]
    
    ;; Threading macros –¢–û–õ–¨–ö–û –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
    (->> coloring
         (tap> "Raw register coloring")
         handle-spilled-variables
         (tap> "Spills handled")
         rewrite-mir-with-registers
         (tap> "MIR rewritten with registers")
         validate-register-allocation
         (tap> "Register allocation validated"))))

;; –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–∞—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞
(defn color-graph-iteratively [interference-graph]
  (loop [uncolored (set (nodes interference-graph))
         colored {}
         spilled #{}]
    (if (empty? uncolored)
      {:colored colored :spilled spilled}
      (let [node (select-highest-degree uncolored)
            available-colors (find-available-colors node colored interference-graph)]
        (if (empty? available-colors)
          (recur (disj uncolored node) colored (conj spilled node))
          (recur (disj uncolored node) 
                 (assoc colored node (first available-colors)) 
                 spilled))))))
```

## üî¨ **–ó–∞–∫–ª—é—á–µ–Ω–∏–µ**

**Threading macros** - —ç—Ç–æ –º–æ—â–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç, –Ω–æ –Ω–µ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ:

### ‚úÖ **–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ threading macros –¥–ª—è:**
- –õ–∏–Ω–µ–π–Ω—ã—Ö —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π IR
- –ö–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–æ—Å—Ç—ã—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π  
- –ü—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–ª–æ–∂–Ω—ã—Ö –∞–Ω–∞–ª–∏–∑–æ–≤
- Pipeline –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å `tap>` –æ—Ç–ª–∞–¥–∫–æ–π

### ‚ùå **–ù–ï –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ threading macros –¥–ª—è:**
- –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ (–∞–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏, –¥–æ–º–∏–Ω–∞—Ç–æ—Ä—ã)
- –ê–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Å backtracking (—Ä–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞)
- NP-–ø–æ–ª–Ω—ã—Ö –∑–∞–¥–∞—á (–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤)
- –ê–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏

### üéØ **–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è:**
```clojure
;; –°–ª–æ–∂–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã: iterate, loop, —Ä–µ–∫—É—Ä—Å–∏—è
(def analysis-results (compute-complex-analysis cfg))

;; –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: threading macros + tap>
(defn apply-optimizations [mir analysis-results]
  (->> mir
       (apply-register-allocation (:registers analysis-results))
       (apply-liveness-optimizations (:liveness analysis-results))
       (apply-dominance-optimizations (:dominators analysis-results))))
```

**–í—ã–≤–æ–¥**: Threading macros –æ—Ç–ª–∏—á–Ω–æ –ø–æ–¥—Ö–æ–¥—è—Ç –¥–ª—è **–∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è** —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å–ª–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤, –Ω–æ —Å–∞–º–∏ –∞–ª–≥–æ—Ä–∏—Ç–º—ã (—Ä–∞—Å–∫—Ä–∞—Å–∫–∞, –∞–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏) —Ç—Ä–µ–±—É—é—Ç —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥—Ö–æ–¥–æ–≤.

```clojure
;; –ü—Ä–æ—Å—Ç—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ - –ò–î–ï–ê–õ–¨–ù–û –¥–ª—è threading macros
(defn optimize-basic-block [basic-block]
  (->> basic-block
       :instructions
       (map constant-fold-instruction)     ; –°–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
       (remove dead-instruction?)          ; –£–¥–∞–ª–µ–Ω–∏–µ –º–µ—Ä—Ç–≤–æ–≥–æ –∫–æ–¥–∞
       (map strength-reduce-instruction)   ; –£–ø—Ä–æ—â–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–π
       (map peephole-optimize)             ; Peephole –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
       (vec)
       (assoc basic-block :instructions)))

;; –†–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç –≤ —Ä–∞–º–∫–∞—Ö –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫–∞
(defn propagate-constants-in-block [instructions]
  (->> instructions
       (tap> "Before constant propagation")
       build-constant-map
       (tap> "Constant map built")
       (substitute-constants instructions)
       (tap> "Constants substituted")
       (remove redundant-loads)
       (tap> "Redundant loads removed")))
```

```clojure
;; –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–µ –∞–Ω–∞–ª–∏–∑—ã CFG
(defn analyze-control-flow [cfg]
  (->> cfg
       (tap> "Input CFG")
       compute-dominators
       (tap> "Dominators computed")
       compute-post-dominators
       (tap> "Post-dominators computed")
       identify-loops
       (tap> "Loops identified")
       compute-loop-nesting
       (tap> "Loop nesting computed")))
```

```clojure
;; –ü–õ–û–•–û: –†–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞ —á–µ—Ä–µ–∑ threading macros
(defn bad-graph-coloring [interference-graph]
  (->> interference-graph
       sort-by-degree        ; ‚ùå –≠—Ç–æ –Ω–µ –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å!
       assign-colors         ; ‚ùå –ù—É–∂–µ–Ω backtracking!
       check-conflicts       ; ‚ùå –ú–æ–∂–µ—Ç –ø–æ—Ç—Ä–µ–±–æ–≤–∞—Ç—å—Å—è –ø–æ–≤—Ç–æ—Ä!
       finalize-assignment)) ; ‚ùå –õ–∏–Ω–µ–π–Ω—ã–π –ø–æ–¥—Ö–æ–¥ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç!
```

```clojure
;; –ü–õ–û–•–û: –ê–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏ —á–µ—Ä–µ–∑ threading macros  
(defn bad-liveness-analysis [cfg]
  (->> cfg
       initialize-liveness   ; ‚ùå –ù—É–∂–Ω—ã –∏—Ç–µ—Ä–∞—Ü–∏–∏ –¥–æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏!
       compute-live-in       ; ‚ùå –ó–∞–≤–∏—Å–∏—Ç –æ—Ç live-out —Å–æ—Å–µ–¥–µ–π!
       compute-live-out      ; ‚ùå –ú–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏!
       check-convergence))   ; ‚ùå –ù—É–∂–µ–Ω —Ü–∏–∫–ª, –∞ –Ω–µ pipeline!
```

```clojure
;; –ü–†–ê–í–ò–õ–¨–ù–û: –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Å –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–æ–π
(defn allocate-registers [interference-graph]
  (let [initial-state {:uncolored (set (nodes interference-graph))
                       :colored {}
                       :spilled #{}}]
    (->> initial-state
         (iterate color-iteration)          ; –ò—Ç–µ—Ä–∞—Ü–∏–∏ –¥–æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
         (take-while not-converged?)        ; –ü–æ–∫–∞ –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω–µ–º –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏
         last                               ; –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
         (tap> "Final coloring"))))

(defn color-iteration [state]
  "–û–¥–Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏—è –∞–ª–≥–æ—Ä–∏—Ç–º–∞ —Ä–∞—Å–∫—Ä–∞—Å–∫–∏"
  (let [node (select-node-to-color (:uncolored state))
        color (find-available-color node (:colored state))]
    (if color
      (-> state
          (update :uncolored disj node)
          (assoc-in [:colored node] color))
      (-> state
          (update :uncolored disj node)
          (update :spilled conj node)))))

;; Threading macros –¢–û–õ–¨–ö–û –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
(defn finalize-register-allocation [coloring-result]
  (->> coloring-result
       (tap> "Raw coloring result")
       handle-spilled-variables
       (tap> "Spills handled")
       generate-register-assignments
       (tap> "Register assignments")
       validate-allocation
       (tap> "Allocation validated")))
```

```clojure
;; –ü–†–ê–í–ò–õ–¨–ù–û: –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏
(defn compute-liveness [cfg]
  (let [initial-state (initialize-liveness-sets cfg)]
    (->> initial-state
         (iterate liveness-iteration)       ; –ò—Ç–µ—Ä–∞—Ü–∏–∏
         (partition 2 1)                    ; –ü–∞—Ä—ã (prev, current)
         (drop-while #(not= (first %) (second %))) ; –î–æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
         first                              ; –ë–µ—Ä–µ–º —Å–æ—à–µ–¥—à–µ–µ—Å—è —Å–æ—Å—Ç–æ—è–Ω–∏–µ
         second
         (tap> "Liveness analysis converged"))))

(defn liveness-iteration [liveness-state]
  "–û–¥–Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ –∂–∏–≤–æ—Å—Ç–∏"
  (reduce update-block-liveness liveness-state (:blocks liveness-state)))

;; Threading macros –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫–∞
(defn update-block-liveness [state block]
  (->> block
       (compute-use-def-sets)             ; –í—ã—á–∏—Å–ª—è–µ–º USE/DEF
       (update-live-out state)            ; –û–±–Ω–æ–≤–ª—è–µ–º live-out
       (update-live-in state)             ; –û–±–Ω–æ–≤–ª—è–µ–º live-in
       (tap> (str "Updated liveness for block " (:label block)))))
```

```clojure
;; –ü–†–ê–í–ò–õ–¨–ù–û: –ö–æ–º–±–∏–Ω–∞—Ü–∏—è –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∏ threading macros
(defn constant-propagation [cfg]
  ;; –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –∫–∞—Ä—Ç—ã –∫–æ–Ω—Å—Ç–∞–Ω—Ç
  (let [constant-map (compute-constant-map cfg)]
    ;; Threading macros –¥–ª—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    (->> cfg
         (tap> "CFG before constant propagation")
         (transform-blocks-with-constants constant-map)
         (tap> "Constants propagated")
         remove-redundant-assignments
         (tap> "Redundant assignments removed")
         fold-constant-expressions
         (tap> "Constant expressions folded"))))

(defn compute-constant-map [cfg]
  "–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç—ã –∫–æ–Ω—Å—Ç–∞–Ω—Ç"
  (let [initial-state (initialize-constant-analysis cfg)]
    (->> initial-state
         (iterate constant-analysis-iteration)
         (take-while changed?)
         last)))

;; Threading macros –¥–ª—è —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –±–ª–æ–∫–æ–≤
(defn transform-blocks-with-constants [cfg constant-map]
  (->> cfg
       :blocks
       (map #(transform-block-instructions % constant-map))
       (assoc cfg :blocks)))
```

```plaintext
–¢–∏–ø –∞–ª–≥–æ—Ä–∏—Ç–º–∞                    | –ü–æ–¥—Ö–æ–¥—è—â–∏–π –º–µ—Ç–æ–¥
---------------------------------|------------------
–õ–∏–Ω–µ–π–Ω—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏           | Threading macros ‚úÖ
–ö–æ–º–ø–æ–∑–∏—Ü–∏—è –∞–Ω–∞–ª–∏–∑–æ–≤              | Threading macros ‚úÖ
–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã            | iterate + take-while ‚úÖ
–ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å backtracking         | –†–µ–∫—É—Ä—Å–∏—è + –º–æ–Ω–∞–¥—ã ‚úÖ
–ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏      | iterate + partition ‚úÖ
–û–±—Ö–æ–¥ –≥—Ä–∞—Ñ–æ–≤                     | –†–µ–∫—É—Ä—Å–∏—è + protocols ‚úÖ
```

```clojure
;; O(n) - –ª–∏–Ω–µ–π–Ω—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ ‚Üí Threading macros
(defn linear-optimization [instructions]
  (->> instructions (map optimize) (filter valid?)))

;; O(n¬≤) - –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã ‚Üí iterate
(defn quadratic-analysis [graph]
  (->> initial-state (iterate step) (take-while changing?)))

;; O(2^n) - NP-–ø–æ–ª–Ω—ã–µ –∑–∞–¥–∞—á–∏ ‚Üí —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
(defn register-allocation [interference-graph]
  (graph-coloring-with-heuristics interference-graph))
```

```clojure
;; 1. –ü–†–û–°–¢–´–ï –û–ü–¢–ò–ú–ò–ó–ê–¶–ò–ò: Threading macros
(defn simple-optimizations [mir]
  (->> mir
       (map constant-fold)
       (remove dead-code?)
       (map strength-reduce)))

;; 2. –°–õ–û–ñ–ù–´–ï –ê–ù–ê–õ–ò–ó–´: –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
(defn complex-analysis [cfg]
  (let [liveness (compute-liveness cfg)
        dominators (compute-dominators cfg)
        interference (build-interference-graph liveness)]
    {:liveness liveness
     :dominators dominators  
     :interference interference}))

;; 3. –ü–†–ò–ú–ï–ù–ï–ù–ò–ï –†–ï–ó–£–õ–¨–¢–ê–¢–û–í: Threading macros
(defn apply-analysis-results [mir analysis-results]
  (->> mir
       (tap> "MIR before applying analysis")
       (allocate-registers (:interference analysis-results))
       (tap> "Registers allocated")
       (optimize-with-liveness (:liveness analysis-results))
       (tap> "Liveness-based optimizations applied")
       (schedule-instructions (:dominators analysis-results))
       (tap> "Instructions scheduled")))
```

```clojure
;; –§–∞–π–ª: src/c51cc/ir/register_allocation.clj

;; –ò–¢–ï–†–ê–¢–ò–í–ù–´–ô –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∞—Å–∫—Ä–∞—Å–∫–∏
(defn allocate-registers [mir-cfg]
  (let [liveness (compute-liveness-iteratively mir-cfg)
        interference (build-interference-graph liveness)
        coloring (color-graph-iteratively interference)]
    
    ;; Threading macros –¢–û–õ–¨–ö–û –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
    (->> coloring
         (tap> "Raw register coloring")
         handle-spilled-variables
         (tap> "Spills handled")
         rewrite-mir-with-registers
         (tap> "MIR rewritten with registers")
         validate-register-allocation
         (tap> "Register allocation validated"))))

;; –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω–∞—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞
(defn color-graph-iteratively [interference-graph]
  (loop [uncolored (set (nodes interference-graph))
         colored {}
         spilled #{}]
    (if (empty? uncolored)
      {:colored colored :spilled spilled}
      (let [node (select-highest-degree uncolored)
            available-colors (find-available-colors node colored interference-graph)]
        (if (empty? available-colors)
          (recur (disj uncolored node) colored (conj spilled node))
          (recur (disj uncolored node) 
                 (assoc colored node (first available-colors)) 
                 spilled))))))
```

```clojure
;; –°–ª–æ–∂–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã: iterate, loop, —Ä–µ–∫—É—Ä—Å–∏—è
(def analysis-results (compute-complex-analysis cfg))

;; –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: threading macros + tap>
(defn apply-optimizations [mir analysis-results]
  (->> mir
       (apply-register-allocation (:registers analysis-results))
       (apply-liveness-optimizations (:liveness analysis-results))
       (apply-dominance-optimizations (:dominators analysis-results))))
```

---

**User**

–ö–∞–∫–∏–µ –º–µ—Ç–æ–¥—ã –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –ø–æ–¥—Ö–æ–¥—è—Ç –¥–ª—è –¥–∞–Ω–Ω—ã—Ö –∑–∞–¥–∞—á:
1. –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ (–∞–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏, –¥–æ–º–∏–Ω–∞—Ç–æ—Ä—ã)
2. –ê–ª–≥–æ—Ä–∏—Ç–º–æ–≤ —Å backtracking (—Ä–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞)
3. NP-–ø–æ–ª–Ω—ã—Ö –∑–∞–¥–∞—á (–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤)
4. –ê–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏ 
?

---

**Cursor**

–û—Ç–ª–∏—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å! –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º –∫–∞–∂–¥—ã–π —Ç–∏–ø –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –¥–ª—è –Ω–∏—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –≤ Clojure.

```markdown
# –ú–µ—Ç–æ–¥—ã –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ C51

## üéØ –¶–µ–ª—å –¥–æ–∫—É–º–µ–Ω—Ç–∞

–ö–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –º–µ—Ç–æ–¥–æ–≤ –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ Clojure –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–ª–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞: –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤, backtracking, NP-–ø–æ–ª–Ω—ã—Ö –∑–∞–¥–∞—á –∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏.

---

## 1. üîÑ –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã (–∞–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏, –¥–æ–º–∏–Ω–∞—Ç–æ—Ä—ã)

### **–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**
- –¢—Ä–µ–±—É—é—Ç –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏—è –¥–æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
- –°–æ—Å—Ç–æ—è–Ω–∏–µ –∏–∑–º–µ–Ω—è–µ—Ç—Å—è –Ω–∞ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
- –ö—Ä–∏—Ç–µ—Ä–∏–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏: –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–∞—è —Ç–æ—á–∫–∞ –∏–ª–∏ –º–∞–∫—Å–∏–º—É–º –∏—Ç–µ—Ä–∞—Ü–∏–π

### **–ü–æ–¥—Ö–æ–¥—è—â–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã Clojure:**

#### **A. `iterate` + `take-while` (–†–ï–ö–û–ú–ï–ù–î–£–ï–¢–°–Ø)**

```clojure
;; –ê–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
(defn compute-liveness [cfg]
  "–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏ –¥–æ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏"
  (let [initial-state (initialize-liveness cfg)]
    (->> initial-state
         (iterate liveness-iteration)           ; –õ–µ–Ω–∏–≤–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏–π
         (partition 2 1)                       ; –ü–∞—Ä—ã (prev, current) –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
         (take-while #(not= (first %) (second %))) ; –î–æ —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
         last                                   ; –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–∞—Ä–∞
         second                                 ; –¢–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
         (tap> "Liveness analysis converged"))))

(defn liveness-iteration [state]
  "–û–¥–Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ –∂–∏–≤–æ—Å—Ç–∏"
  (reduce (fn [acc block]
            (let [old-live-in (get-in acc [:live-in (:label block)])
                  old-live-out (get-in acc [:live-out (:label block)])
                  
                  ;; live-out[B] = ‚à™ live-in[S] –¥–ª—è –≤—Å–µ—Ö –ø—Ä–µ–µ–º–Ω–∏–∫–æ–≤ S
                  new-live-out (apply set/union 
                                     (map #(get-in acc [:live-in %]) 
                                          (:successors block)))
                  
                  ;; live-in[B] = use[B] ‚à™ (live-out[B] - def[B])
                  new-live-in (set/union (:use block)
                                        (set/difference new-live-out (:def block)))]
              
              (-> acc
                  (assoc-in [:live-in (:label block)] new-live-in)
                  (assoc-in [:live-out (:label block)] new-live-out))))
          state
          (:blocks cfg)))

;; –ê–Ω–∞–ª–∏–∑ –¥–æ–º–∏–Ω–∞—Ç–æ—Ä–æ–≤
(defn compute-dominators [cfg]
  "–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –¥–æ–º–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  (let [all-nodes (set (map :label (:blocks cfg)))
        initial-state {:dominators 
                      (assoc (zipmap (map :label (:blocks cfg)) 
                                    (repeat all-nodes))
                             (:entry cfg) #{(:entry cfg)})}]
    (->> initial-state
         (iterate dominators-iteration)
         (partition 2 1)
         (take-while #(not= (first %) (second %)))
         last
         second
         (tap> "Dominators analysis converged"))))

(defn dominators-iteration [state cfg]
  "–û–¥–Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ –¥–æ–º–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  (reduce (fn [acc block]
            (if (= (:label block) (:entry cfg))
              acc  ; –í—Ö–æ–¥–Ω–æ–π –±–ª–æ–∫ –Ω–µ –∏–∑–º–µ–Ω—è–µ—Ç—Å—è
              (let [predecessors (:predecessors block)
                    new-dominators (if (empty? predecessors)
                                    #{}
                                    (apply set/intersection
                                           (map #(get-in acc [:dominators %])
                                                predecessors)))]
                (assoc-in acc [:dominators (:label block)]
                         (conj new-dominators (:label block))))))
          state
          (:blocks cfg)))
```

#### **B. `loop`/`recur` –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–µ–º—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π**

```clojure
;; –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å —è–≤–Ω—ã–º –∫–æ–Ω—Ç—Ä–æ–ª–µ–º
(defn compute-liveness-loop [cfg]
  "–ê–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏ —Å —è–≤–Ω—ã–º —Ü–∏–∫–ª–æ–º"
  (loop [state (initialize-liveness cfg)
         iteration 0
         max-iterations 100]  ; –ó–∞—â–∏—Ç–∞ –æ—Ç –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–≥–æ —Ü–∏–∫–ª–∞
    
    (let [new-state (liveness-iteration state cfg)]
      (cond
        (= state new-state)
        (do (tap> (str "Converged after " iteration " iterations"))
            new-state)
        
        (>= iteration max-iterations)
        (do (tap> (str "Max iterations reached: " max-iterations))
            new-state)
        
        :else
        (recur new-state (inc iteration) max-iterations)))))
```

#### **C. Transducers –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏**

```clojure
;; –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å transducers
(defn compute-liveness-optimized [cfg]
  "–ê–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º transducers"
  (let [convergence-xf (comp
                        (map liveness-iteration)
                        (partition-by identity)  ; –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                        (take 1)                 ; –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é –≥—Ä—É–ø–ø—É (—Å—Ö–æ–¥–∏–º–æ—Å—Ç—å)
                        (map first))]            ; –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    
    (->> (initialize-liveness cfg)
         (iterate #(liveness-iteration % cfg))
         (sequence convergence-xf)
         first)))
```

---

## 2. üîô –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å backtracking (—Ä–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞)

### **–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**
- –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ —Ä–µ—à–µ–Ω–∏–π
- –û—Ç–∫–∞—Ç –ø—Ä–∏ –Ω–µ—É–¥–∞—á–Ω—ã—Ö –≤—ã–±–æ—Ä–∞—Ö
- –ü–æ–∏—Å–∫ –≤ –≥–ª—É–±–∏–Ω—É —Å –≤–æ–∑–≤—Ä–∞—Ç–æ–º

### **–ü–æ–¥—Ö–æ–¥—è—â–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã Clojure:**

#### **A. –†–µ–∫—É—Ä—Å–∏—è —Å —è–≤–Ω—ã–º backtracking (–†–ï–ö–û–ú–ï–ù–î–£–ï–¢–°–Ø)**

```clojure
;; –†–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ—Ä–µ–Ω—Ü–∏–∏ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤
(defn color-graph [interference-graph available-colors]
  "–†–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞ —Å backtracking"
  (let [nodes (vec (keys interference-graph))]
    (color-nodes nodes {} interference-graph available-colors)))

(defn color-nodes [remaining-nodes coloring interference-graph colors]
  "–†–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∞ —Å backtracking"
  (if (empty? remaining-nodes)
    coloring  ; –£—Å–ø–µ—à–Ω–∞—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∞ –Ω–∞–π–¥–µ–Ω–∞
    
    (let [node (first remaining-nodes)
          rest-nodes (rest remaining-nodes)
          forbidden-colors (get-forbidden-colors node coloring interference-graph)]
      
      ;; –ü—Ä–æ–±—É–µ–º –∫–∞–∂–¥—ã–π –¥–æ—Å—Ç—É–ø–Ω—ã–π —Ü–≤–µ—Ç
      (some (fn [color]
              (when-not (forbidden-colors color)
                (let [new-coloring (assoc coloring node color)]
                  (tap> (str "Trying color " color " for node " node))
                  
                  ;; –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤ —Å –Ω–æ–≤–æ–π —Ä–∞—Å–∫—Ä–∞—Å–∫–æ–π
                  (color-nodes rest-nodes new-coloring interference-graph colors))))
            colors))))

(defn get-forbidden-colors [node coloring interference-graph]
  "–ü–æ–ª—É—á–∞–µ—Ç –º–Ω–æ–∂–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã—Ö —Ü–≤–µ—Ç–æ–≤ –¥–ª—è —É–∑–ª–∞"
  (set (map coloring (get interference-graph node #{}))))

;; –≠–≤—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∞—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∞ (–±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è)
(defn color-graph-heuristic [interference-graph available-colors]
  "–†–∞—Å–∫—Ä–∞—Å–∫–∞ —Å —ç–≤—Ä–∏—Å—Ç–∏–∫–∞–º–∏ –¥–ª—è AT89S4051"
  (let [nodes (sort-by #(count (get interference-graph %)) > 
                      (keys interference-graph))]  ; –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å—Ç–µ–ø–µ–Ω–∏
    
    (reduce (fn [coloring node]
              (let [forbidden (get-forbidden-colors node coloring interference-graph)
                    available (remove forbidden available-colors)
                    color (first available)]
                
                (if color
                  (do (tap> (str "Assigned " color " to " node))
                      (assoc coloring node color))
                  (do (tap> (str "Spilling node " node))
                      (assoc coloring node :spilled)))))
            {}
            nodes)))
```

#### **B. –ú–æ–Ω–∞–¥—ã –¥–ª—è —ç–ª–µ–≥–∞–Ω—Ç–Ω–æ–≥–æ backtracking**

```clojure
;; –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ Maybe/Either –º–æ–Ω–∞–¥—ã –¥–ª—è backtracking
(defn color-graph-monadic [interference-graph colors]
  "–†–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞ —á–µ—Ä–µ–∑ –º–æ–Ω–∞–¥—ã"
  (m/do-maybe
    [sorted-nodes (m/just (sort-by-degree interference-graph))
     coloring (color-nodes-monadic sorted-nodes {} interference-graph colors)]
    (m/just coloring)))

(defn color-nodes-monadic [nodes coloring interference-graph colors]
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∞—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∞ —É–∑–ª–æ–≤"
  (if (empty? nodes)
    (m/just coloring)
    
    (let [node (first nodes)
          rest-nodes (rest nodes)]
      
      ;; –ü—Ä–æ–±—É–µ–º —Ü–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫—É—é –∫–æ–º–ø–æ–∑–∏—Ü–∏—é
      (m/first-success
        (map (fn [color]
               (m/do-maybe
                 [valid-color (validate-color node color coloring interference-graph)
                  new-coloring (m/just (assoc coloring node color))
                  final-coloring (color-nodes-monadic rest-nodes new-coloring 
                                                     interference-graph colors)]
                 (m/just final-coloring)))
             colors)))))
```

#### **C. core.logic –¥–ª—è –¥–µ–∫–ª–∞—Ä–∞—Ç–∏–≤–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞**

```clojure
;; –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ core.logic –¥–ª—è constraint-based —Ä–∞—Å–∫—Ä–∞—Å–∫–∏
(require '[clojure.core.logic :as l])

(defn color-graph-logic [interference-graph colors]
  "–†–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞ —á–µ—Ä–µ–∑ constraint logic programming"
  (let [nodes (keys interference-graph)
        node-vars (zipmap nodes (repeatedly l/lvar))]
    
    (l/run* [coloring]
      ;; –ö–∞–∂–¥—ã–π —É–∑–µ–ª –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å —Ü–≤–µ—Ç –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö
      (l/everyg #(l/membero (get node-vars %) colors) nodes)
      
      ;; –°–æ—Å–µ–¥–Ω–∏–µ —É–∑–ª—ã –¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å —Ä–∞–∑–Ω—ã–µ —Ü–≤–µ—Ç–∞
      (l/everyg (fn [[node neighbors]]
                  (l/everyg (fn [neighbor]
                              (l/!= (get node-vars node) 
                                   (get node-vars neighbor)))
                           neighbors))
               interference-graph)
      
      ;; –°–≤—è–∑—ã–≤–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
      (l/== coloring (into {} (map (fn [node] [node (get node-vars node)]) nodes))))))
```

---

## 3. üß© NP-–ø–æ–ª–Ω—ã–µ –∑–∞–¥–∞—á–∏ (–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤)

### **–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**
- –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ
- –¢—Ä–µ–±—É—é—Ç —ç–≤—Ä–∏—Å—Ç–∏–∫ –∏ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
- –ß–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –º–µ—Ç–∞—ç–≤—Ä–∏—Å—Ç–∏–∫–∏

### **–ü–æ–¥—Ö–æ–¥—è—â–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã Clojure:**

#### **A. –ñ–∞–¥–Ω—ã–µ —ç–≤—Ä–∏—Å—Ç–∏–∫–∏ (–†–ï–ö–û–ú–ï–ù–î–£–ï–¢–°–Ø –¥–ª—è AT89S4051)**

```clojure
;; –ñ–∞–¥–Ω—ã–π –∞–ª–≥–æ—Ä–∏—Ç–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤
(defn greedy-register-allocation [interference-graph]
  "–ñ–∞–¥–Ω–æ–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ –¥–ª—è AT89S4051"
  (let [at89s4051-registers [:A :R0 :R1 :R2 :R3 :R4 :R5 :R6 :R7]
        nodes (sort-by-spill-cost interference-graph)]  ; –≠–≤—Ä–∏—Å—Ç–∏–∫–∞: —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ spill
    
    (->> nodes
         (reduce (fn [allocation node]
                   (let [forbidden-regs (get-conflicting-registers node allocation interference-graph)
                         available-regs (remove forbidden-regs at89s4051-registers)
                         chosen-reg (choose-best-register node available-regs)]
                     
                     (if chosen-reg
                       (do (tap> (str "Allocated " chosen-reg " to " node))
                           (assoc allocation node chosen-reg))
                       (do (tap> (str "Spilling " node " to memory"))
                           (assoc allocation node :memory)))))
                 {})
         (tap> "Greedy allocation complete"))))

(defn sort-by-spill-cost [interference-graph]
  "–°–æ—Ä—Ç–∏—Ä—É–µ—Ç —É–∑–ª—ã –ø–æ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ spill (—ç–≤—Ä–∏—Å—Ç–∏–∫–∞)"
  (->> interference-graph
       keys
       (sort-by (fn [node]
                  (let [degree (count (get interference-graph node))
                        usage-frequency (get-usage-frequency node)]
                    (/ usage-frequency (inc degree)))))  ; –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç: —á–∞—Å—Ç–æ—Ç–∞/—Å—Ç–µ–ø–µ–Ω—å
       reverse))

(defn choose-best-register [node available-registers]
  "–í—ã–±–∏—Ä–∞–µ—Ç –ª—É—á—à–∏–π —Ä–µ–≥–∏—Å—Ç—Ä –¥–ª—è —É–∑–ª–∞ (—ç–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è AT89S4051)"
  (cond
    ;; –ê–∫–∫—É–º—É–ª—è—Ç–æ—Ä A - –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    (and (arithmetic-node? node) (some #{:A} available-registers))
    :A
    
    ;; R0, R1 - –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –¥–ª—è —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
    (and (pointer-node? node) (some #{:R0 :R1} available-registers))
    (first (filter #{:R0 :R1} available-registers))
    
    ;; –õ—é–±–æ–π –¥–æ—Å—Ç—É–ø–Ω—ã–π —Ä–µ–≥–∏—Å—Ç—Ä
    :else
    (first available-registers)))
```

#### **B. –ì–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –¥–ª—è –≥–ª–æ–±–∞–ª—å–Ω–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏**

```clojure
;; –ì–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
(defn genetic-register-allocation [interference-graph]
  "–ì–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏–π –∞–ª–≥–æ—Ä–∏—Ç–º –¥–ª—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤"
  (let [population-size 50
        generations 100
        mutation-rate 0.1]
    
    (->> (generate-initial-population interference-graph population-size)
         (iterate (partial evolve-population interference-graph mutation-rate))
         (take generations)
         (map #(best-individual %))
         (apply max-key fitness)
         (tap> "Best solution found"))))

(defn generate-initial-population [interference-graph size]
  "–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–ø—É–ª—è—Ü–∏—é —Ä–µ—à–µ–Ω–∏–π"
  (repeatedly size #(random-allocation interference-graph)))

(defn evolve-population [interference-graph mutation-rate population]
  "–û–¥–Ω–æ –ø–æ–∫–æ–ª–µ–Ω–∏–µ —ç–≤–æ–ª—é—Ü–∏–∏"
  (->> population
       (map #(vector % (fitness %)))
       (sort-by second >)
       (take (/ (count population) 2))  ; –°–µ–ª–µ–∫—Ü–∏—è –ª—É—á—à–∏—Ö
       (mapcat (fn [[individual _]]
                 [individual (mutate individual mutation-rate)]))  ; –†–∞–∑–º–Ω–æ–∂–µ–Ω–∏–µ
       (take (count population))))

(defn fitness [allocation]
  "–§—É–Ω–∫—Ü–∏—è –ø—Ä–∏—Å–ø–æ—Å–æ–±–ª–µ–Ω–Ω–æ—Å—Ç–∏ (–º–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ–º spill + –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã)"
  (let [spill-cost (count (filter #(= % :memory) (vals allocation)))
        conflict-cost (count-register-conflicts allocation)]
    (- 1000 spill-cost conflict-cost)))
```

#### **C. Simulated Annealing –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞**

```clojure
;; –ò–º–∏—Ç–∞—Ü–∏—è –æ—Ç–∂–∏–≥–∞ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Ä–µ—à–µ–Ω–∏—è
(defn simulated-annealing-allocation [initial-allocation interference-graph]
  "–£–ª—É—á—à–µ–Ω–∏–µ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —á–µ—Ä–µ–∑ –∏–º–∏—Ç–∞—Ü–∏—é –æ—Ç–∂–∏–≥–∞"
  (let [initial-temp 100.0
        cooling-rate 0.95
        min-temp 0.1]
    
    (loop [current-allocation initial-allocation
           current-cost (allocation-cost current-allocation)
           temperature initial-temp
           iteration 0]
      
      (if (< temperature min-temp)
        (do (tap> (str "Annealing complete after " iteration " iterations"))
            current-allocation)
        
        (let [neighbor (generate-neighbor current-allocation)
              neighbor-cost (allocation-cost neighbor)
              delta (- neighbor-cost current-cost)
              accept? (or (< delta 0)  ; –£–ª—É—á—à–µ–Ω–∏–µ
                         (< (rand) (Math/exp (/ (- delta) temperature))))]  ; –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–Ω–æ–µ –ø—Ä–∏–Ω—è—Ç–∏–µ
          
          (if accept?
            (do (tap> (str "Accepted neighbor with cost " neighbor-cost))
                (recur neighbor neighbor-cost (* temperature cooling-rate) (inc iteration)))
            (recur current-allocation current-cost (* temperature cooling-rate) (inc iteration))))))))

(defn generate-neighbor [allocation]
  "–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–æ—Å–µ–¥–Ω–µ–µ —Ä–µ—à–µ–Ω–∏–µ (–º–∞–ª–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ)"
  (let [node (rand-nth (keys allocation))
        new-register (rand-nth [:A :R0 :R1 :R2 :R3 :R4 :R5 :R6 :R7 :memory])]
    (assoc allocation node new-register)))
```

---

## 4. üéØ –ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏

### **–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏:**
- –ü–æ–∏—Å–∫ —Å–æ—Å—Ç–æ—è–Ω–∏—è, –∫–æ—Ç–æ—Ä–æ–µ –Ω–µ –∏–∑–º–µ–Ω—è–µ—Ç—Å—è –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏
- f(x) = x
- –ß–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –≤ –∞–Ω–∞–ª–∏–∑–µ –ø–æ—Ç–æ–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö

### **–ü–æ–¥—Ö–æ–¥—è—â–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã Clojure:**

#### **A. `iterate` —Å –¥–µ—Ç–µ–∫—Ü–∏–µ–π –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏ (–†–ï–ö–û–ú–ï–ù–î–£–ï–¢–°–Ø)**

```clojure
;; –ê–Ω–∞–ª–∏–∑ –¥–æ—Å—Ç–∏–∂–∏–º—ã—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π
(defn compute-reaching-definitions [cfg]
  "–ê–Ω–∞–ª–∏–∑ –¥–æ—Å—Ç–∏–∂–∏–º—ã—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π –¥–æ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏"
  (let [initial-state (initialize-reaching-definitions cfg)]
    (->> initial-state
         (iterate #(reaching-definitions-step % cfg))
         (partition 2 1)
         (drop-while #(not= (first %) (second %)))  ; –î–æ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏
         first
         second
         (tap> "Reaching definitions converged"))))

(defn reaching-definitions-step [state cfg]
  "–û–¥–∏–Ω —à–∞–≥ –∞–Ω–∞–ª–∏–∑–∞ –¥–æ—Å—Ç–∏–∂–∏–º—ã—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π"
  (reduce (fn [acc block]
            (let [in-set (apply set/union 
                               (map #(get-in acc [:out %]) (:predecessors block)))
                  out-set (set/union (set/difference in-set (:kill block))
                                    (:gen block))]
              (-> acc
                  (assoc-in [:in (:label block)] in-set)
                  (assoc-in [:out (:label block)] out-set))))
          state
          (:blocks cfg)))

;; –ê–Ω–∞–ª–∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π
(defn compute-available-expressions [cfg]
  "–ê–Ω–∞–ª–∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π"
  (let [all-expressions (collect-all-expressions cfg)
        initial-state {:in (zipmap (map :label (:blocks cfg)) 
                                  (repeat all-expressions))
                       :out (zipmap (map :label (:blocks cfg)) 
                                   (repeat all-expressions))}]
    
    (->> initial-state
         (iterate #(available-expressions-step % cfg))
         (take-while-changing)  ; –£—Ç–∏–ª–∏—Ç–∞ –¥–ª—è –¥–µ—Ç–µ–∫—Ü–∏–∏ –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏
         last
         (tap> "Available expressions converged"))))

(defn take-while-changing [coll]
  "–ë–µ—Ä–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã –ø–æ–∫–∞ –æ–Ω–∏ –∏–∑–º–µ–Ω—è—é—Ç—Å—è"
  (->> coll
       (partition 2 1)
       (take-while #(not= (first %) (second %)))
       (map second)
       (cons (first coll))))
```

#### **B. –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –¥–ª—è –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏**

```clojure
;; –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏
(defn fixed-point [f initial-value & {:keys [max-iterations tolerance]
                                     :or {max-iterations 1000 tolerance 1e-10}}]
  "–ù–∞—Ö–æ–¥–∏—Ç –Ω–µ–ø–æ–¥–≤–∏–∂–Ω—É—é —Ç–æ—á–∫—É —Ñ—É–Ω–∫—Ü–∏–∏ f"
  (->> initial-value
       (iterate f)
       (partition 2 1)
       (take max-iterations)
       (drop-while (fn [[prev curr]]
                     (> (distance prev curr) tolerance)))
       first
       second))

;; –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø–æ—Ç–æ–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö
(defn dataflow-analysis [cfg transfer-function initial-state]
  "–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –ø–æ—Ç–æ–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö"
  (fixed-point 
    #(transfer-function % cfg)
    initial-state
    :max-iterations 100))

;; –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –∞–Ω–∞–ª–∏–∑—ã —á–µ—Ä–µ–∑ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä
(defn reaching-definitions-analysis [cfg]
  (dataflow-analysis cfg reaching-definitions-transfer initial-rd-state))

(defn live-variables-analysis [cfg]
  (dataflow-analysis cfg live-variables-transfer initial-lv-state))
```

#### **C. Kleene iteration –¥–ª—è –º–æ–Ω–æ—Ç–æ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π**

```clojure
;; –ò—Ç–µ—Ä–∞—Ü–∏—è –ö–ª–∏–Ω–∏ –¥–ª—è –º–æ–Ω–æ—Ç–æ–Ω–Ω—ã—Ö —Ä–µ—à–µ—Ç–æ–∫
(defn kleene-iteration [lattice transfer-function initial-state]
  "–ò—Ç–µ—Ä–∞—Ü–∏—è –ö–ª–∏–Ω–∏ –¥–ª—è –º–æ–Ω–æ—Ç–æ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –Ω–∞ —Ä–µ—à–µ—Ç–∫–∞—Ö"
  (loop [current-state initial-state
         iteration 0]
    
    (let [next-state (transfer-function current-state)]
      (cond
        ;; –ù–µ–ø–æ–¥–≤–∏–∂–Ω–∞—è —Ç–æ—á–∫–∞ –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞
        (lattice-equal? lattice current-state next-state)
        (do (tap> (str "Kleene iteration converged after " iteration " steps"))
            current-state)
        
        ;; –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∏—Ç–µ—Ä–∞—Ü–∏–π
        (> iteration 1000)
        (do (tap> "Kleene iteration: maximum iterations reached")
            current-state)
        
        ;; –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –∏—Ç–µ—Ä–∞—Ü–∏—é
        :else
        (recur next-state (inc iteration))))))

;; –†–µ—à–µ—Ç–∫–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –∫–æ–Ω—Å—Ç–∞–Ω—Ç
(def constant-lattice
  {:bottom :‚ä•
   :top :‚ä§
   :join (fn [a b]
           (cond
             (= a :‚ä•) b
             (= b :‚ä•) a
             (= a b) a
             :else :‚ä§))
   :meet (fn [a b]
           (cond
             (= a :‚ä§) b
             (= b :‚ä§) a
             (= a b) a
             :else :‚ä•))
   :leq (fn [a b]
          (or (= a :‚ä•)
              (= b :‚ä§)
              (= a b)))})
```

---

## üéØ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –≤—ã–±–æ—Ä—É –º–µ—Ç–æ–¥–æ–≤

### **–ú–∞—Ç—Ä–∏—Ü–∞ –≤—ã–±–æ—Ä–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤**

```
–ó–∞–¥–∞—á–∞                          | –†–∞–∑–º–µ—Ä –∑–∞–¥–∞—á–∏ | –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –º–µ—Ç–æ–¥
--------------------------------|---------------|--------------------
–ê–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏                  | < 1000 –±–ª–æ–∫–æ–≤ | iterate + take-while
–ê–Ω–∞–ª–∏–∑ –¥–æ–º–∏–Ω–∞—Ç–æ—Ä–æ–≤              | < 1000 –±–ª–æ–∫–æ–≤ | iterate + partition
–†–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞ (—Ç–æ—á–Ω–∞—è)        | < 20 —É–∑–ª–æ–≤    | –†–µ–∫—É—Ä—Å–∏—è + backtracking
–†–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞ (–ø—Ä–∏–±–ª–∏–∂–µ–Ω–Ω–∞—è)  | > 20 —É–∑–ª–æ–≤    | –ñ–∞–¥–Ω—ã–µ —ç–≤—Ä–∏—Å—Ç–∏–∫–∏
–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ AT89S4051| 8 —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤   | –ñ–∞–¥–Ω—ã–π + —ç–≤—Ä–∏—Å—Ç–∏–∫–∏
–ì–ª–æ–±–∞–ª—å–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è          | –õ—é–±–æ–π         | Simulated annealing
–ê–Ω–∞–ª–∏–∑ –ø–æ—Ç–æ–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö           | < 1000 –±–ª–æ–∫–æ–≤ | fixed-point –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä
```

### **–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏ —Å–ª–æ–∂–Ω–æ—Å—Ç—å**

```clojure
;; –ë–µ–Ω—á–º–∞—Ä–∫–∏ –¥–ª—è –≤—ã–±–æ—Ä–∞ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
(defn benchmark-algorithms [cfg]
  "–°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤"
  (let [start-time (System/nanoTime)]
    
    ;; –ü—Ä–æ—Å—Ç–æ–π –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π –∞–Ω–∞–ª–∏–∑
    (time (compute-liveness-iterate cfg))
    
    ;; –ê–Ω–∞–ª–∏–∑ —Å transducers
    (time (compute-liveness-optimized cfg))
    
    ;; –ñ–∞–¥–Ω–∞—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∞
    (time (greedy-register-allocation (build-interference-graph cfg)))
    
    ;; –¢–æ—á–Ω–∞—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –º–∞–ª—ã—Ö –≥—Ä–∞—Ñ–æ–≤)
    (when (< (count (:blocks cfg)) 20)
      (time (exact-graph-coloring (build-interference-graph cfg))))))
```

---

## üî¨ –ó–∞–∫–ª—é—á–µ–Ω–∏–µ

### **–ö–ª—é—á–µ–≤—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã –≤—ã–±–æ—Ä–∞:**

1. **–ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã**: `iterate` + `take-while` –¥–ª—è —ç–ª–µ–≥–∞–Ω—Ç–Ω–æ—Å—Ç–∏ –∏ –ª–µ–Ω–∏–≤–æ—Å—Ç–∏
2. **Backtracking**: –†–µ–∫—É—Ä—Å–∏—è –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏, —ç–≤—Ä–∏—Å—Ç–∏–∫–∏ –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏  
3. **NP-–ø–æ–ª–Ω—ã–µ –∑–∞–¥–∞—á–∏**: –ñ–∞–¥–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã + –º–µ—Ç–∞—ç–≤—Ä–∏—Å—Ç–∏–∫–∏ –¥–ª—è –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–µ—à–µ–Ω–∏–π
4. **–ù–µ–ø–æ–¥–≤–∏–∂–Ω–∞—è —Ç–æ—á–∫–∞**: –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –¥–ª—è –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

### **–î–ª—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ AT89S4051:**

```clojure
;; –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
(defn compile-with-advanced-algorithms [ast]
  (->> ast
       ;; –ü—Ä–æ—Å—Ç—ã–µ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏: threading macros
       transform-to-mir
       
       ;; –°–ª–æ–∂–Ω—ã–µ –∞–Ω–∞–ª–∏–∑—ã: —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
       (analyze-with-fixed-point compute-liveness)
       (analyze-with-iteration compute-dominators)
       
       ;; NP-–ø–æ–ª–Ω—ã–µ –∑–∞–¥–∞—á–∏: —ç–≤—Ä–∏—Å—Ç–∏–∫–∏
       (allocate-registers-greedy at89s4051-registers)
       
       ;; –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: threading macros
       apply-optimizations
       generate-assembly))
```

**–°—Ç–∞—Ç—É—Å**: ‚úÖ –ì–û–¢–û–í–û –ö –†–ï–ê–õ–ò–ó–ê–¶–ò–ò

**–ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç**: –í–´–°–û–ö–ò–ô (–∫—Ä–∏—Ç–∏—á–Ω–æ –¥–ª—è –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–¥–∞)

**–°–ª–æ–∂–Ω–æ—Å—Ç—å**: –í–´–°–û–ö–ê–Ø (—Ç—Ä–µ–±—É–µ—Ç —ç–∫—Å–ø–µ—Ä—Ç–∏–∑—ã –≤ –∞–ª–≥–æ—Ä–∏—Ç–º–∞—Ö)
```

–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å —É –Ω–∞—Å –µ—Å—Ç—å –∫–æ–º–ø–ª–µ–∫—Å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –º–µ—Ç–æ–¥–æ–≤ –∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞. –î–∞–≤–∞–π—Ç–µ –∫—Ä–∞—Ç–∫–æ —Ä–µ–∑—é–º–∏—Ä—É–µ–º –∫–ª—é—á–µ–≤—ã–µ –≤—ã–≤–æ–¥—ã:

## üéØ **–û—Ç–≤–µ—Ç—ã –Ω–∞ –≤–∞—à–∏ –≤–æ–ø—Ä–æ—Å—ã:**

### **1. –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã (–∞–Ω–∞–ª–∏–∑ –∂–∏–≤–æ—Å—Ç–∏, –¥–æ–º–∏–Ω–∞—Ç–æ—Ä—ã)**
- **–õ—É—á—à–∏–π –≤—ã–±–æ—Ä**: `iterate` + `take-while` + `partition`
- **–ü–æ—á–µ–º—É**: –õ–µ–Ω–∏–≤—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è, —ç–ª–µ–≥–∞–Ω—Ç–Ω–∞—è –¥–µ—Ç–µ–∫—Ü–∏—è —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏, —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è
- **–ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã**: `loop`/`recur` –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—è, transducers –¥–ª—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

### **2. –ê–ª–≥–æ—Ä–∏—Ç–º—ã —Å backtracking (—Ä–∞—Å–∫—Ä–∞—Å–∫–∞ –≥—Ä–∞—Ñ–∞)**
- **–î–ª—è —Ç–æ—á–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π**: –†–µ–∫—É—Ä—Å–∏—è —Å —è–≤–Ω—ã–º backtracking
- **–î–ª—è –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö –∑–∞–¥–∞—á**: –ñ–∞–¥–Ω—ã–µ —ç–≤—Ä–∏—Å—Ç–∏–∫–∏ + –º–æ–Ω–∞–¥—ã –¥–ª—è —ç–ª–µ–≥–∞–Ω—Ç–Ω–æ—Å—Ç–∏
- **–î–ª—è —Å–ª–æ–∂–Ω—ã—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π**: `core.logic` (constraint logic programming)

### **3. NP-–ø–æ–ª–Ω—ã–µ –∑–∞–¥–∞—á–∏ (—Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤)**
- **–î–ª—è AT89S4051**: –ñ–∞–¥–Ω—ã–µ —ç–≤—Ä–∏—Å—Ç–∏–∫–∏ (8 —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ - –º–∞–ª–∞—è –∑–∞–¥–∞—á–∞)
- **–î–ª—è —É–ª—É—á—à–µ–Ω–∏—è**: Simulated annealing, –≥–µ–Ω–µ—Ç–∏—á–µ—Å–∫–∏–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
- **–ö—Ä–∏—Ç–∏—á–Ω–æ**: –°–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–µ –¥–ª—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã —ç–≤—Ä–∏—Å—Ç–∏–∫–∏ (A –¥–ª—è –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∏, R0/R1 –¥–ª—è —É–∫–∞–∑–∞—Ç–µ–ª–µ–π)

### **4. –ê–ª–≥–æ—Ä–∏—Ç–º—ã –Ω–µ–ø–æ–¥–≤–∏–∂–Ω–æ–π —Ç–æ—á–∫–∏**
- **–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–æ–¥—Ö–æ–¥**: –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã `fixed-point`
- **–î–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ø–æ—Ç–æ–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö**: `iterate` + –¥–µ—Ç–µ–∫—Ü–∏—è —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏
- **–î–ª—è –º–æ–Ω–æ—Ç–æ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π**: –ò—Ç–µ—Ä–∞—Ü–∏—è –ö–ª–∏–Ω–∏ –Ω–∞ —Ä–µ—à–µ—Ç–∫–∞—Ö

## üèóÔ∏è **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø—Ä–∏–Ω—Ü–∏–ø—ã:**

```clojure
;; –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∑–∞–¥–∞—á–∏
–ü–∞—Ä—Å–µ—Ä:           –ú–æ–Ω–∞–¥—ã + –º–∞–∫—Ä–æ—Å—ã (–£–ñ–ï –ï–°–¢–¨)
IR —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏: Threading macros  (–ü–†–û–°–¢–´–ï)
–°–ª–æ–∂–Ω—ã–µ –∞–Ω–∞–ª–∏–∑—ã:  –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã (–ù–û–í–´–ï)
–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:      –≠–≤—Ä–∏—Å—Ç–∏–∫–∏ + –º–µ—Ç–∞—ç–≤—Ä–∏—Å—Ç–∏–∫–∏
```

## üéì **–° —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è Ph.D –≤ Computer Science:**

–í–∞—à –ø–æ–¥—Ö–æ–¥ –¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç –≥–ª—É–±–æ–∫–æ–µ –ø–æ–Ω–∏–º–∞–Ω–∏–µ **–ø—Ä–∏–Ω—Ü–∏–ø–∞ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è –æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç–∏** –≤ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞. –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ä–∞–∑–Ω—ã—Ö –ø–∞—Ä–∞–¥–∏–≥–º –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∑–∞–¥–∞—á - —ç—Ç–æ –ø—Ä–∏–∑–Ω–∞–∫ –∑—Ä–µ–ª–æ–≥–æ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–≥–æ –º—ã—à–ª–µ–Ω–∏—è:

- **–ú–æ–Ω–∞–¥—ã** –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—Ç –∫–æ–º–ø–æ–∑–∏—Ü–∏–æ–Ω–Ω–æ—Å—Ç—å –∏ –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫
- **Threading macros** –¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–π –¥–∞—é—Ç —á–∏—Ç–∞–µ–º–æ—Å—Ç—å
- **–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã** –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–¥–∞—á –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å

–≠—Ç–æ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø—Ä–∏–Ω—Ü–∏–ø–∞–º **domain-driven design** –∏ **clean architecture**.

**–í–æ–ø—Ä–æ—Å –¥–ª—è —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è**: –ù–µ —Å—Ç–æ–∏—Ç –ª–∏ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å **–≥–∏–±—Ä–∏–¥–Ω—ã–π –ø–æ–¥—Ö–æ–¥** –¥–ª—è —Ä–∞—Å–∫—Ä–∞—Å–∫–∏ –≥—Ä–∞—Ñ–∞ - –Ω–∞—á–∏–Ω–∞—Ç—å —Å –∂–∞–¥–Ω–æ–π —ç–≤—Ä–∏—Å—Ç–∏–∫–∏, –∞ –∑–∞—Ç–µ–º –ø—Ä–∏–º–µ–Ω—è—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ (simulated annealing) –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞?

```clojure
;; –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –∑–∞–¥–∞—á–∏
–ü–∞—Ä—Å–µ—Ä:           –ú–æ–Ω–∞–¥—ã + –º–∞–∫—Ä–æ—Å—ã (–£–ñ–ï –ï–°–¢–¨)
IR —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏: Threading macros  (–ü–†–û–°–¢–´–ï)
–°–ª–æ–∂–Ω—ã–µ –∞–Ω–∞–ª–∏–∑—ã:  –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã (–ù–û–í–´–ï)
–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏:      –≠–≤—Ä–∏—Å—Ç–∏–∫–∏ + –º–µ—Ç–∞—ç–≤—Ä–∏—Å—Ç–∏–∫–∏
```

