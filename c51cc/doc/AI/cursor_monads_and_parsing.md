# –û–±—ä—è—Å–Ω–µ–Ω–∏–µ –º–æ–Ω–∞–¥ –∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
_Exported on 5/27/2025 at 16:12:38 GMT+3 from Cursor (0.50.5)_

---

**User**

–∞ –≤–æ—Ç —Ç–µ–ø–µ—Ä—å –æ–±—ä—è—Å–Ω–∏ –º–Ω–µ –º–æ–Ω–∞–¥—ã –∏ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –ø–∞—Ä—Å–∏–Ω–≥–∞.
—Ç.–∫ —ç—Ç–æ –æ—Å–Ω–æ–≤–Ω–∞—è —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è –∏ —è –µ–µ –Ω–µ –ø–æ–Ω–∏–º–∞—é

---

**Cursor**

–û—Ç–ª–∏—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å! –ú–æ–Ω–∞–¥—ã –∏ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –ø–∞—Ä—Å–∏–Ω–≥–∞ - —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–∞—è —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—è, –∫–æ—Ç–æ—Ä–∞—è –ª–µ–∂–∏—Ç –≤ –æ—Å–Ω–æ–≤–µ —ç–ª–µ–≥–∞–Ω—Ç–Ω–æ–≥–æ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞. –î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º —ç—Ç–æ –ø–æ—à–∞–≥–æ–≤–æ, –∫–∞–∫ –Ω–∞—Å—Ç–æ—è—â–∏–µ computer scientists.

–ü—Ä–µ–≤–æ—Å—Ö–æ–¥–Ω–æ! –¢–µ–ø–µ—Ä—å —è –º–æ–≥—É –¥–∞—Ç—å –≤–∞–º –≥–ª—É–±–æ–∫–æ–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ –º–æ–Ω–∞–¥ –∏ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤ –ø–∞—Ä—Å–∏–Ω–≥–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –≤–∞—à–µ–≥–æ –∫–æ–¥–∞. –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —ç–ª–µ–≥–∞–Ω—Ç–Ω–∞—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–æ–Ω—Ü–µ–ø—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è —Ä–µ—à–∞–µ—Ç —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–π.

## üß† –ß—Ç–æ —Ç–∞–∫–æ–µ –º–æ–Ω–∞–¥—ã? (–¢–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∞—è –æ—Å–Ω–æ–≤–∞)

**–ú–æ–Ω–∞–¥–∞** - —ç—Ç–æ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∏–∑ —Ç–µ–æ—Ä–∏–∏ –∫–∞—Ç–µ–≥–æ—Ä–∏–π, –∫–æ—Ç–æ—Ä–∞—è –∏–Ω–∫–∞–ø—Å—É–ª–∏—Ä—É–µ—Ç –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º. –í –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –º–æ–Ω–∞–¥—ã —Ä–µ—à–∞—é—Ç –ø—Ä–æ–±–ª–µ–º—É –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç "–æ–±–æ–≥–∞—â–µ–Ω–Ω—ã–µ" –∑–Ω–∞—á–µ–Ω–∏—è (–Ω–µ –ø—Ä–æ—Å—Ç–æ `A ‚Üí B`, –∞ `A ‚Üí M<B>`).

### –ó–∞–∫–æ–Ω—ã –º–æ–Ω–∞–¥ (Category Theory)

–õ—é–±–∞—è –º–æ–Ω–∞–¥–∞ –¥–æ–ª–∂–Ω–∞ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—Ç—å —Ç—Ä–µ–º –∑–∞–∫–æ–Ω–∞–º:

1. **Left Identity**: `return(a) >>= f ‚â° f(a)`
2. **Right Identity**: `m >>= return ‚â° m`  
3. **Associativity**: `(m >>= f) >>= g ‚â° m >>= (Œªx. f(x) >>= g)`

–ì–¥–µ `>>=` - —ç—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏—è bind, –∞ `return` - –æ–ø–µ—Ä–∞—Ü–∏—è "–ø–æ–¥–Ω—è—Ç–∏—è" –∑–Ω–∞—á–µ–Ω–∏—è –≤ –º–æ–Ω–∞–¥—É.

## üîç –ê–Ω–∞–ª–∏–∑ –≤–∞—à–µ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

–î–∞–≤–∞–π—Ç–µ —Ä–∞–∑–±–µ—Ä–µ–º, –∫–∞–∫ —ç—Ç–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –≤ –≤–∞—à–µ–º –ø–∞—Ä—Å–µ—Ä–µ:

```12:15:c51cc/src/c51cc/parser.clj
(defrecord ParseState [tokens position])
(defrecord ParseResult [success? value state error])
```

**ParseResult** - —ç—Ç–æ –≤–∞—à–∞ –º–æ–Ω–∞–¥–∞! –û–Ω–∞ –∏–Ω–∫–∞–ø—Å—É–ª–∏—Ä—É–µ—Ç:
- –ö–æ–Ω—Ç–µ–∫—Å—Ç —É—Å–ø–µ—Ö–∞/–Ω–µ—É–¥–∞—á–∏ (`success?`)
- –ó–Ω–∞—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (`value`) 
- –ù–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ (`state`)
- –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –æ—à–∏–±–∫–µ (`error`)

```35:40:c51cc/src/c51cc/parser.clj
(defn bind 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è bind –¥–ª—è –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤"
  [parser-result parser-fn]
  (if (:success? parser-result)
    (parser-fn (:value parser-result) (:state parser-result))
    parser-result))
```

**–≠—Ç–æ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è bind (>>=)**! –û–Ω–∞:
1. –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è
2. –ï—Å–ª–∏ —É—Å–ø–µ—à–Ω–æ - –ø—Ä–∏–º–µ–Ω—è–µ—Ç —Å–ª–µ–¥—É—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é –∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
3. –ï—Å–ª–∏ –Ω–µ—É—Å–ø–µ—à–Ω–æ - –ø—Ä–æ–±—Ä–∞—Å—ã–≤–∞–µ—Ç –æ—à–∏–±–∫—É –¥–∞–ª—å—à–µ

```42:45:c51cc/src/c51cc/parser.clj
(defn return-parser 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è return - –≤—Å–µ–≥–¥–∞ —É—Å–ø–µ—à–Ω—ã–π –ø–∞—Ä—Å–µ—Ä"
  [value]
  (fn [state] (success value state)))
```

**–≠—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏—è return** - –ø–æ–¥–Ω–∏–º–∞–µ—Ç –æ–±—ã—á–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç.

## üéØ –ü–æ—á–µ–º—É —ç—Ç–æ –≥–µ–Ω–∏–∞–ª—å–Ω–æ?

### –ü—Ä–æ–±–ª–µ–º–∞ –±–µ–∑ –º–æ–Ω–∞–¥

–ü—Ä–µ–¥—Å—Ç–∞–≤—å—Ç–µ –ø–∞—Ä—Å–∏–Ω–≥ –±–µ–∑ –º–æ–Ω–∞–¥ - –∫–∞–∂–¥–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã–ª–∞ –±—ã:

```clojure
(defn parse-if-statement-imperative [tokens position]
  (let [if-result (expect-if tokens position)]
    (if (:success if-result)
      (let [open-result (expect-open-paren (:tokens if-result) (:position if-result))]
        (if (:success open-result)
          (let [condition-result (parse-expression (:tokens open-result) (:position open-result))]
            (if (:success condition-result)
              ;; –ò —Ç–∞–∫ –¥–∞–ª–µ–µ... –ö–û–®–ú–ê–†!
              ))))
```

### –†–µ—à–µ–Ω–∏–µ —Å –º–æ–Ω–∞–¥–∞–º–∏

```47:58:c51cc/src/c51cc/parser.clj
(defmacro do-parse 
  "–ú–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤ —Å—Ç–∏–ª–µ do-notation"
  [& bindings]
  (if (empty? bindings)
    `(return-parser nil)
    (let [[binding expr & rest] bindings]
      (if (symbol? binding)
        `(bind ~expr (fn [~binding state#] 
                       ((do-parse ~@rest) state#)))
        `(bind ~expr (fn [_# state#] 
                       ((do-parse ~@rest) state#)))))))
```

–≠—Ç–æ—Ç –º–∞–∫—Ä–æ—Å –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–∏—Å–∞—Ç—å:

```clojure
(do-parse
  if-token (expect-token-value :if)
  open-paren (expect-token-value :open-round)
  condition (parse-expression)
  close-paren (expect-token-value :close-round)
  then-branch (parse-statement)
  (return-parser (if-statement-node condition then-branch)))
```

## üîß –ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã - —Å—Ç—Ä–æ–∏—Ç–µ–ª—å–Ω—ã–µ –±–ª–æ–∫–∏

```200:210:c51cc/src/c51cc/parser.clj
(defn choice 
  "–ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä –≤—ã–±–æ—Ä–∞ - –ø—Ä–æ–±—É–µ—Ç –ø–∞—Ä—Å–µ—Ä—ã –ø–æ –ø–æ—Ä—è–¥–∫—É"
  [& parsers]
  (fn [state]
    (loop [remaining-parsers parsers]
      (if (empty? remaining-parsers)
        (failure "–ù–∏ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –Ω–µ –ø–æ–¥–æ—à–µ–ª" state)
        (let [result ((first remaining-parsers) state)]
          (if (:success? result)
            result
            (recur (rest remaining-parsers))))))))
```

**Choice** - —ç—Ç–æ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π `Alternative`. –ü—Ä–æ–±—É–µ—Ç –ø–∞—Ä—Å–µ—Ä—ã –ø–æ –ø–æ—Ä—è–¥–∫—É –¥–æ –ø–µ—Ä–≤–æ–≥–æ —É—Å–ø–µ—à–Ω–æ–≥–æ.

```212:221:c51cc/src/c51cc/parser.clj
(defn many 
  "–ü–∞—Ä—Å–µ—Ä, –ø—Ä–∏–º–µ–Ω—è—é—â–∏–π –¥—Ä—É–≥–æ–π –ø–∞—Ä—Å–µ—Ä –Ω–æ–ª—å –∏–ª–∏ –±–æ–ª–µ–µ —Ä–∞–∑"
  [parser]
  (fn [state]
    (loop [current-state state
           results []]
      (let [result (parser current-state)]
        (if (:success? result)
          (recur (:state result) (conj results (:value result)))
          (success results current-state))))))
```

**Many** - –ø—Ä–∏–º–µ–Ω—è–µ—Ç –ø–∞—Ä—Å–µ—Ä –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ, —Å–æ–±–∏—Ä–∞—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ —Å–ø–∏—Å–æ–∫.

## üé® –≠–ª–µ–≥–∞–Ω—Ç–Ω–æ—Å—Ç—å –≤ –¥–µ–π—Å—Ç–≤–∏–∏

–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ –ø–∞—Ä—Å–∏–Ω–≥ –≤—ã—Ä–∞–∂–µ–Ω–∏–π –≤ —Å–∫–æ–±–∫–∞—Ö:

```365:375:c51cc/src/c51cc/parser.clj
    ;; –í—ã—Ä–∞–∂–µ–Ω–∏—è –≤ —Å–∫–æ–±–∫–∞—Ö
    (fn [state]
      (let [open-result ((expect-token-value :open-round) state)]
        (if (:success? open-result)
          (let [expr-result (parse-expression (:state open-result))]
            (if (:success? expr-result)
              (let [close-result ((expect-token-value :close-round) (:state expr-result))]
                (if (:success? close-result)
                  (success (:value expr-result) (:state close-result))
                  close-result))
              expr-result))
          open-result)))
```

–≠—Ç–æ –º–æ–∂–Ω–æ –±—ã–ª–æ –±—ã –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å —Å `do-parse`:

```clojure
(do-parse
  _ (expect-token-value :open-round)
  expr (parse-expression)
  _ (expect-token-value :close-round)
  (return-parser expr))
```

## üöÄ –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–¥—Ö–æ–¥–∞

1. **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫** - –µ—Å–ª–∏ –ª—é–±–æ–π –ø–∞—Ä—Å–µ—Ä –≤ —Ü–µ–ø–æ—á–∫–µ –ø–∞–¥–∞–µ—Ç, –≤—Å—è —Ü–µ–ø–æ—á–∫–∞ –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç—Å—è
2. **–ö–æ–º–ø–æ–∑–∏—Ü–∏–æ–Ω–Ω–æ—Å—Ç—å** - —Å–ª–æ–∂–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã —Å—Ç—Ä–æ—è—Ç—Å—è –∏–∑ –ø—Ä–æ—Å—Ç—ã—Ö
3. **–ß–∏—Ç–∞–µ–º–æ—Å—Ç—å** - –∫–æ–¥ –±–ª–∏–∑–æ–∫ –∫ BNF –≥—Ä–∞–º–º–∞—Ç–∏–∫–µ
4. **–ü–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ** - –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã
5. **–ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å** - –∑–∞–∫–æ–Ω—ã –º–æ–Ω–∞–¥ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ

## ü§î –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –ø–æ–¥—Ö–æ–¥—ã (–∏ –ø–æ—á–µ–º—É –æ–Ω–∏ —Ö—É–∂–µ)

1. **Recursive Descent –±–µ–∑ –º–æ–Ω–∞–¥** - –º–Ω–æ–≥–æ boilerplate –∫–æ–¥–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫
2. **Parser Generators (yacc/bison)** - –º–µ–Ω–µ–µ –≥–∏–±–∫–∏–µ, —Å–ª–æ–∂–Ω–µ–µ –æ—Ç–ª–∞–¥–∫–∞
3. **Imperative parsing** - —Å–æ—Å—Ç–æ—è–Ω–∏–µ –º—É—Ç–∞–±–µ–ª—å–Ω–æ, —Å–ª–æ–∂–Ω–µ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å

## üí° –í–æ–ø—Ä–æ—Å –¥–ª—è —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è

–ü–æ—á–µ–º—É –≤—ã –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ `do-parse` –º–∞–∫—Ä–æ—Å –≤ —Å–≤–æ–µ–º –∫–æ–¥–µ? –≠—Ç–æ —Å–¥–µ–ª–∞–ª–æ –±—ã –ø–∞—Ä—Å–µ—Ä—ã –µ—â–µ –±–æ–ª–µ–µ —á–∏—Ç–∞–µ–º—ã–º–∏. –í–æ–∑–º–æ–∂–Ω–æ, —Å—Ç–æ–∏—Ç —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å–ª–æ–∂–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã —Å –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º?

–ú–æ–Ω–∞–¥—ã - —ç—Ç–æ –Ω–µ –ø—Ä–æ—Å—Ç–æ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏—è —Ä–∞–¥–∏ –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–∏. –≠—Ç–æ –º–æ—â–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å—é –≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏–∏, –æ—Å–æ–±–µ–Ω–Ω–æ –∫–æ–≥–¥–∞ –Ω—É–∂–Ω–æ –∫–æ–º–ø–æ–∑–∏—Ä–æ–≤–∞—Ç—å –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º (–æ—à–∏–±–∫–∏, —Å–æ—Å—Ç–æ—è–Ω–∏–µ, –Ω–µ–¥–µ—Ç–µ—Ä–º–∏–Ω–∏–∑–º).

```plaintext
(defrecord ParseState [tokens position])
(defrecord ParseResult [success? value state error])
```

```plaintext
(defn bind 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è bind –¥–ª—è –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤"
  [parser-result parser-fn]
  (if (:success? parser-result)
    (parser-fn (:value parser-result) (:state parser-result))
    parser-result))
```

```plaintext
(defn return-parser 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è return - –≤—Å–µ–≥–¥–∞ —É—Å–ø–µ—à–Ω—ã–π –ø–∞—Ä—Å–µ—Ä"
  [value]
  (fn [state] (success value state)))
```

```clojure
(defn parse-if-statement-imperative [tokens position]
  (let [if-result (expect-if tokens position)]
    (if (:success if-result)
      (let [open-result (expect-open-paren (:tokens if-result) (:position if-result))]
        (if (:success open-result)
          (let [condition-result (parse-expression (:tokens open-result) (:position open-result))]
            (if (:success condition-result)
              ;; –ò —Ç–∞–∫ –¥–∞–ª–µ–µ... –ö–û–®–ú–ê–†!
              ))))
```

```plaintext
(defmacro do-parse 
  "–ú–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤ —Å—Ç–∏–ª–µ do-notation"
  [& bindings]
  (if (empty? bindings)
    `(return-parser nil)
    (let [[binding expr & rest] bindings]
      (if (symbol? binding)
        `(bind ~expr (fn [~binding state#] 
                       ((do-parse ~@rest) state#)))
        `(bind ~expr (fn [_# state#] 
                       ((do-parse ~@rest) state#)))))))
```

```clojure
(do-parse
  if-token (expect-token-value :if)
  open-paren (expect-token-value :open-round)
  condition (parse-expression)
  close-paren (expect-token-value :close-round)
  then-branch (parse-statement)
  (return-parser (if-statement-node condition then-branch)))
```

```plaintext
(defn choice 
  "–ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä –≤—ã–±–æ—Ä–∞ - –ø—Ä–æ–±—É–µ—Ç –ø–∞—Ä—Å–µ—Ä—ã –ø–æ –ø–æ—Ä—è–¥–∫—É"
  [& parsers]
  (fn [state]
    (loop [remaining-parsers parsers]
      (if (empty? remaining-parsers)
        (failure "–ù–∏ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –Ω–µ –ø–æ–¥–æ—à–µ–ª" state)
        (let [result ((first remaining-parsers) state)]
          (if (:success? result)
            result
            (recur (rest remaining-parsers))))))))
```

```plaintext
(defn many 
  "–ü–∞—Ä—Å–µ—Ä, –ø—Ä–∏–º–µ–Ω—è—é—â–∏–π –¥—Ä—É–≥–æ–π –ø–∞—Ä—Å–µ—Ä –Ω–æ–ª—å –∏–ª–∏ –±–æ–ª–µ–µ —Ä–∞–∑"
  [parser]
  (fn [state]
    (loop [current-state state
           results []]
      (let [result (parser current-state)]
        (if (:success? result)
          (recur (:state result) (conj results (:value result)))
          (success results current-state))))))
```

```plaintext
    ;; –í—ã—Ä–∞–∂–µ–Ω–∏—è –≤ —Å–∫–æ–±–∫–∞—Ö
    (fn [state]
      (let [open-result ((expect-token-value :open-round) state)]
        (if (:success? open-result)
          (let [expr-result (parse-expression (:state open-result))]
            (if (:success? expr-result)
              (let [close-result ((expect-token-value :close-round) (:state expr-result))]
                (if (:success? close-result)
                  (success (:value expr-result) (:state close-result))
                  close-result))
              expr-result))
          open-result)))
```

```clojure
(do-parse
  _ (expect-token-value :open-round)
  expr (parse-expression)
  _ (expect-token-value :close-round)
  (return-parser expr))
```

---

**User**

–ü–æ—á–µ–º—É –≤—ã –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ do-parse –º–∞–∫—Ä–æ—Å –≤ —Å–≤–æ–µ–º –∫–æ–¥–µ? –≠—Ç–æ —Å–¥–µ–ª–∞–ª–æ –±—ã –ø–∞—Ä—Å–µ—Ä—ã –µ—â–µ –±–æ–ª–µ–µ —á–∏—Ç–∞–µ–º—ã–º–∏. –í–æ–∑–º–æ–∂–Ω–æ, —Å—Ç–æ–∏—Ç —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å–ª–æ–∂–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã —Å –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º?

–ü–æ—è—Å–Ω–∏

---

**Cursor**

–û—Ç–ª–∏—á–Ω—ã–π –≤–æ–ø—Ä–æ—Å! –í—ã –∞–±—Å–æ–ª—é—Ç–Ω–æ –ø—Ä–∞–≤—ã - —ç—Ç–æ —Å–µ—Ä—å–µ–∑–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã. –î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º, –ø–æ—á–µ–º—É `do-parse` –º–∞–∫—Ä–æ—Å –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, –∏ –ø–æ–∫–∞–∂—É, –∫–∞–∫ –º–æ–∂–Ω–æ –∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω–æ —É–ª—É—á—à–∏—Ç—å —á–∏—Ç–∞–µ–º–æ—Å—Ç—å –∫–æ–¥–∞.

## üéØ –ü—Ä–æ–±–ª–µ–º–∞: "Callback Hell" –≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–º —Å—Ç–∏–ª–µ

–í—ã –∞–±—Å–æ–ª—é—Ç–Ω–æ –ø—Ä–∞–≤—ã! –ö–æ–¥ —Å—Ç—Ä–∞–¥–∞–µ—Ç –æ—Ç –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–±–ª–µ–º—ã - **–º–æ–Ω–∞–¥–∏—á–µ—Å–∫–æ–≥–æ "callback hell"**. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ —ç—Ç–æ—Ç –∫–æ—à–º–∞—Ä:

```811:833:c51cc/src/c51cc/parser.clj
(defn parse-if-statement 
  "–ü–∞—Ä—Å–∏—Ç —É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if"
  [state]
  (let [if-result ((expect-token-value :if) state)]
    (if (:success? if-result)
      (let [open-result ((expect-token-value :open-round) (:state if-result))]
        (if (:success? open-result)
          (let [condition-result (parse-expression (:state open-result))]
            (if (:success? condition-result)
              (let [close-result ((expect-token-value :close-round) (:state condition-result))]
                (if (:success? close-result)
                  (let [then-result (parse-statement (:state close-result))]
                    (if (:success? then-result)
                      (let [else-result ((optional (fn [state]
                                                    (let [else-kw-result ((expect-token-value :else) state)]
                                                      (if (:success? else-kw-result)
                                                        (parse-statement (:state else-kw-result))
                                                        else-kw-result))))
                                        (:state then-result))]
                        (if (:success? else-result)
                          (success (if-statement-node (:value condition-result) 
                                                     (:value then-result) 
                                                     (:value else-result))
                                  (:state else-result))
                          else-result))
```

**–≠—Ç–æ 7 —É—Ä–æ–≤–Ω–µ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏!** –ö–æ–¥ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–µ—á–∏—Ç–∞–µ–º.

## üöÄ –†–µ—à–µ–Ω–∏–µ: –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ —Å `do-parse`

–î–∞–≤–∞–π—Ç–µ –ø–æ–∫–∞–∂—É, –∫–∞–∫ –¥–æ–ª–∂–µ–Ω –≤—ã–≥–ª—è–¥–µ—Ç—å —ç—Ç–æ—Ç –∫–æ–¥:

```plaintext
(defn parse-if-statement 
  "–ü–∞—Ä—Å–∏—Ç —É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if"
  [state]
  (let [if-result ((expect-token-value :if) state)]
    (if (:success? if-result)
      (let [open-result ((expect-token-value :open-round) (:state if-result))]
        (if (:success? open-result)
          (let [condition-result (parse-expression (:state open-result))]
            (if (:success? condition-result)
              (let [close-result ((expect-token-value :close-round) (:state condition-result))]
                (if (:success? close-result)
                  (let [then-result (parse-statement (:state close-result))]
                    (if (:success? then-result)
                      (let [else-result ((optional (fn [state]
                                                    (let [else-kw-result ((expect-token-value :else) state)]
                                                      (if (:success? else-kw-result)
                                                        (parse-statement (:state else-kw-result))
                                                        else-kw-result))))
                                        (:state then-result))]
                        (if (:success? else-result)
                          (success (if-statement-node (:value condition-result) 
                                                     (:value then-result) 
                                                     (:value else-result))
                                  (:state else-result))
                          else-result))
```

```clojure
(ns c51cc.parser-refactored-example
  "–ü—Ä–∏–º–µ—Ä—ã —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ –ø–∞—Ä—Å–µ—Ä–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º do-parse –º–∞–∫—Ä–æ—Å–∞
   –î–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä—É–µ—Ç, –∫–∞–∫ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –¥–µ–ª–∞—é—Ç –∫–æ–¥ —á–∏—Ç–∞–µ–º—ã–º"
  (:require [c51cc.parser :as p]))

;; ============================================================================
;; –†–ï–§–ê–ö–¢–û–†–ò–ù–ì: –î–û –ò –ü–û–°–õ–ï
;; ============================================================================

;; –ë–´–õ–û: –ö–æ—à–º–∞—Ä–Ω–∞—è –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å (7 —É—Ä–æ–≤–Ω–µ–π!)
(defn parse-if-statement-old [state]
  (let [if-result ((p/expect-token-value :if) state)]
    (if (:success? if-result)
      (let [open-result ((p/expect-token-value :open-round) (:state if-result))]
        (if (:success? open-result)
          (let [condition-result (p/parse-expression (:state open-result))]
            (if (:success? condition-result)
              (let [close-result ((p/expect-token-value :close-round) (:state condition-result))]
                (if (:success? close-result)
                  (let [then-result (p/parse-statement (:state close-result))]
                    (if (:success? then-result)
                      ;; –ò –µ—â–µ –±–æ–ª—å—à–µ –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏ –¥–ª—è else...
                      ))))))))

;; –°–¢–ê–õ–û: –≠–ª–µ–≥–∞–Ω—Ç–Ω–∞—è –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è
(defn parse-if-statement-new [state]
  ((p/do-parse
    _ (p/expect-token-value :if)
    _ (p/expect-token-value :open-round)
    condition p/parse-expression
    _ (p/expect-token-value :close-round)
    then-branch p/parse-statement
    else-branch (p/optional (p/do-parse
                             _ (p/expect-token-value :else)
                             else-stmt p/parse-statement
                             (p/return-parser else-stmt)))
    (p/return-parser (p/if-statement-node condition then-branch else-branch)))
   state))

;; ============================================================================
;; –ë–û–õ–ï–ï –°–õ–û–ñ–ù–´–ï –ü–†–ò–ú–ï–†–´
;; ============================================================================

;; –ë–´–õ–û: parse-for-statement - 10+ —É—Ä–æ–≤–Ω–µ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏!
(defn parse-for-statement-old [state]
  (let [for-result ((p/expect-token-value :for) state)]
    (if (:success? for-result)
      (let [open-result ((p/expect-token-value :open-round) (:state for-result))]
        (if (:success? open-result)
          (let [init-result ((p/optional p/parse-expression) (:state open-result))]
            (if (:success? init-result)
              (let [semi1-result ((p/expect-token-value :semicolon) (:state init-result))]
                ;; –ò —Ç–∞–∫ –¥–∞–ª–µ–µ... –ö–û–®–ú–ê–†!
                ))))))) 

;; –°–¢–ê–õ–û: –ß–∏—Ç–∞–µ—Ç—Å—è –∫–∞–∫ BNF –≥—Ä–∞–º–º–∞—Ç–∏–∫–∞!
(defn parse-for-statement-new [state]
  ((p/do-parse
    _ (p/expect-token-value :for)
    _ (p/expect-token-value :open-round)
    init (p/optional p/parse-expression)
    _ (p/expect-token-value :semicolon)
    condition (p/optional p/parse-expression)
    _ (p/expect-token-value :semicolon)
    update (p/optional p/parse-expression)
    _ (p/expect-token-value :close-round)
    body p/parse-statement
    (p/return-parser (p/for-statement-node init condition update body)))
   state))

;; ============================================================================
;; –§–£–ù–ö–¶–ò–û–ù–ê–õ–¨–ù–´–ï –ü–ê–†–°–ï–†–´ –í–´–°–®–ï–ì–û –ü–û–†–Ø–î–ö–ê
;; ============================================================================

(defn between 
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏
   –ü—Ä–∏–º–µ—Ä: between(open-paren, close-paren, expression)"
  [open close parser]
  (p/do-parse
    _ open
    result parser
    _ close
    (p/return-parser result)))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º
   –ü—Ä–∏–º–µ—Ä: separated-by(comma, expression) –¥–ª—è 'a, b, c'"
  [separator parser]
  (p/choice
    ;; –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (p/return-parser [])
    ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (p/do-parse
      first-item parser
      rest-items (p/many (p/do-parse
                          _ separator
                          item parser
                          (p/return-parser item)))
      (p/return-parser (cons first-item rest-items)))))

;; –¢–µ–ø–µ—Ä—å –ø–∞—Ä—Å–∏–Ω–≥ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Ç—Ä–∏–≤–∏–∞–ª—å–Ω—ã–º:
(defn parse-argument-list-elegant [state]
  ((between (p/expect-token-value :open-round)
            (p/expect-token-value :close-round)
            (separated-by (p/expect-token-value :comma) p/parse-expression))
   state))

;; ============================================================================
;; –ü–ê–†–°–ï–†–´ –° –û–ë–†–ê–ë–û–¢–ö–û–ô –û–®–ò–ë–û–ö
;; ============================================================================

(defn with-error-context
  "–î–æ–±–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –∫ –æ—à–∏–±–∫–∞–º –ø–∞—Ä—Å–∏–Ω–≥–∞"
  [context parser]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        result
        (p/failure (str context ": " (:error result)) (:state result))))))

(defn parse-function-declaration-with-context [state]
  ((with-error-context "–æ–±—ä—è–≤–ª–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏"
     (p/do-parse
       return-type p/parse-type-specifier
       name (p/expect-token :identifier)
       _ (p/expect-token-value :open-round)
       params p/parse-parameter-list
       _ (p/expect-token-value :close-round)
       body (p/choice p/parse-block-statement
                      (p/do-parse
                        _ (p/expect-token-value :semicolon)
                        (p/return-parser nil)))
       (p/return-parser (p/function-declaration-node 
                         return-type 
                         (p/extract-identifier-name name)
                         params 
                         body))))
   state))

;; ============================================================================
;; –ê–ù–ê–õ–ò–ó –ü–†–ï–ò–ú–£–©–ï–°–¢–í
;; ============================================================================

;; 1. –ß–ò–¢–ê–ï–ú–û–°–¢–¨: –ö–æ–¥ —á–∏—Ç–∞–µ—Ç—Å—è –∫–∞–∫ –≥—Ä–∞–º–º–∞—Ç–∏–∫–∞
;; 2. –ö–û–ú–ü–û–ó–ò–¶–ò–û–ù–ù–û–°–¢–¨: –õ–µ–≥–∫–æ —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–µ –ø–∞—Ä—Å–µ—Ä—ã –∏–∑ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö
;; 3. –ü–ï–†–ï–ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–ï: –ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã —Ç–∏–ø–∞ 'between', 'separated-by' —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã
;; 4. –û–¢–õ–ê–î–ö–ê: –õ–µ–≥—á–µ –Ω–∞–π—Ç–∏ –æ—à–∏–±–∫—É –≤ –ª–∏–Ω–µ–π–Ω–æ–º –∫–æ–¥–µ
;; 5. –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï: –ö–∞–∂–¥—ã–π –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä –º–æ–∂–Ω–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –æ—Ç–¥–µ–ª—å–Ω–æ
;; 6. –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–¨: –ö–æ–º–ø–∏–ª—è—Ç–æ—Ä –ª—É—á—à–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ—Ç –ª–∏–Ω–µ–π–Ω—ã–π –∫–æ–¥

;; ============================================================================
;; –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò –ü–û –†–ï–§–ê–ö–¢–û–†–ò–ù–ì–£
;; ============================================================================

;; 1. –ù–∞—á–Ω–∏—Ç–µ —Å —Å–∞–º—ã—Ö —Å–ª–æ–∂–Ω—ã—Ö –ø–∞—Ä—Å–µ—Ä–æ–≤ (parse-for-statement, parse-function-declaration)
;; 2. –°–æ–∑–¥–∞–π—Ç–µ –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞ (between, separated-by, etc.)
;; 3. –î–æ–±–∞–≤—å—Ç–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫
;; 4. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ do-parse –≤–µ–∑–¥–µ, –≥–¥–µ –µ—Å—Ç—å –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü–∏–π
;; 5. –ì—Ä—É–ø–ø–∏—Ä—É–π—Ç–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã –≤ –º–æ–¥—É–ª–∏

;; –ú–ï–¢–†–ò–ö–ò –£–õ–£–ß–®–ï–ù–ò–Ø:
;; - –£—Ä–æ–≤–Ω–∏ –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏: —Å 7-10 –¥–æ 0-1
;; - –°—Ç—Ä–æ–∫–∏ –∫–æ–¥–∞: —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ –Ω–∞ 40-60%
;; - –¶–∏–∫–ª–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å: —Å–Ω–∏–∂–µ–Ω–∏–µ –≤ 3-5 —Ä–∞–∑
;; - –í—Ä–µ–º—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –∫–æ–¥–∞: —Å–æ–∫—Ä–∞—â–µ–Ω–∏–µ –≤ 5-10 —Ä–∞–∑
```

```clojure
;; –ë–´–õ–û: –ö–æ—à–º–∞—Ä–Ω–∞—è –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç—å (7 —É—Ä–æ–≤–Ω–µ–π!)
(defn parse-if-statement-old [state]
  (let [if-result ((p/expect-token-value :if) state)]
    (if (:success? if-result)
      (let [open-result ((p/expect-token-value :open-round) (:state if-result))]
        (if (:success? open-result)
          (let [condition-result (p/parse-expression (:state open-result))]
            (if (:success? condition-result)
              (let [close-result ((p/expect-token-value :close-round) (:state condition-result))]
                (if (:success? close-result)
                  (let [then-result (p/parse-statement (:state close-result))]
                    (if (:success? then-result)
                      ;; –ò –µ—â–µ –±–æ–ª—å—à–µ –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏ –¥–ª—è else...
                      then-result
                      then-result))
                  close-result))
              condition-result))
          open-result))
      if-result)))
```

```clojure
;; –ë–´–õ–û: parse-for-statement - 10+ —É—Ä–æ–≤–Ω–µ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏!
(defn parse-for-statement-old [state]
  (let [for-result ((p/expect-token-value :for) state)]
    (if (:success? for-result)
      (let [open-result ((p/expect-token-value :open-round) (:state for-result))]
        (if (:success? open-result)
          (let [init-result ((p/optional p/parse-expression) (:state open-result))]
            (if (:success? init-result)
              (let [semi1-result ((p/expect-token-value :semicolon) (:state init-result))]
                ;; –ò —Ç–∞–∫ –¥–∞–ª–µ–µ... –ö–û–®–ú–ê–†!
                semi1-result)
              init-result))
          open-result))
      for-result)))
```

–•–æ—Ä–æ—à–æ, —è –≤–∏–∂—É –ø—Ä–æ–±–ª–µ–º—É - —ç—Ç–æ –æ—à–∏–±–∫–∏ –ª–∏–Ω—Ç–µ—Ä–∞ –∏–∑-–∑–∞ –Ω–µ—Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –≤ `do-parse`. –≠—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞, –Ω–æ –¥–∞–≤–∞–π—Ç–µ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏–º—Å—è –Ω–∞ –≥–ª–∞–≤–Ω–æ–º –≤–æ–ø—Ä–æ—Å–µ.

## üéØ –ü–æ—á–µ–º—É `do-parse` –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è: –ê–Ω–∞–ª–∏–∑ –ø—Ä–æ–±–ª–µ–º—ã

### 1. **–ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∞—è –ø—Ä–∏—á–∏–Ω–∞** 
–ö–æ–¥ –ø–∏—Å–∞–ª—Å—è –≤ –∏–º–ø–µ—Ä–∞—Ç–∏–≤–Ω–æ–º —Å—Ç–∏–ª–µ —Å —Ä—É—á–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π. –ê–≤—Ç–æ—Ä, –≤–µ—Ä–æ—è—Ç–Ω–æ, –Ω–µ –æ—Å–æ–∑–Ω–∞–≤–∞–ª –≤—Å—é –º–æ—â—å —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ `do-parse` –º–∞–∫—Ä–æ—Å–∞.

### 2. **–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø—Ä–∏—á–∏–Ω–∞**
–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –Ω–∞ —Ç–µ–∫—É—â—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é `do-parse`:

```47:60:c51cc/src/c51cc/parser.clj
(defmacro do-parse 
  "–ú–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤ —Å—Ç–∏–ª–µ do-notation"
  [& bindings]
  (if (empty? bindings)
    `(return-parser nil)
    (let [[binding expr & rest] bindings]
      (if (symbol? binding)
        `(bind ~expr (fn [~binding state#] 
                       ((do-parse ~@rest) state#)))
        `(bind ~expr (fn [_# state#] 
                       ((do-parse ~@rest) state#)))))))
```

**–ü—Ä–æ–±–ª–µ–º–∞**: –ú–∞–∫—Ä–æ—Å —Ç—Ä–µ–±—É–µ—Ç, —á—Ç–æ–±—ã –ø–∞—Ä—Å–µ—Ä—ã –≤–æ–∑–≤—Ä–∞—â–∞–ª–∏ —Ñ—É–Ω–∫—Ü–∏–∏, –∞ –Ω–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–∞–ø—Ä—è–º—É—é!

### 3. **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å**

–¢–µ–∫—É—â–∏–µ –ø–∞—Ä—Å–µ—Ä—ã –∏–º–µ—é—Ç —Å–∏–≥–Ω–∞—Ç—É—Ä—É:
```clojure
(defn parse-something [state] -> ParseResult)
```

–ê `do-parse` –æ–∂–∏–¥–∞–µ—Ç:
```clojure
(defn parse-something [] -> (fn [state] -> ParseResult))
```

## üîß –†–µ—à–µ–Ω–∏–µ: –î–≤–∞ –ø–æ–¥—Ö–æ–¥–∞

### –ü–æ–¥—Ö–æ–¥ 1: –ò—Å–ø—Ä–∞–≤–∏—Ç—å `do-parse` –º–∞–∫—Ä–æ—Å

```plaintext
(defmacro do-parse 
  "–ú–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤ —Å—Ç–∏–ª–µ do-notation"
  [& bindings]
  (if (empty? bindings)
    `(return-parser nil)
    (let [[binding expr & rest] bindings]
      (if (symbol? binding)
        `(bind ~expr (fn [~binding state#] 
                       ((do-parse ~@rest) state#)))
        `(bind ~expr (fn [_# state#] 
                       ((do-parse ~@rest) state#)))))))
```

```plaintext
(defmacro do-parse 
  "–ú–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤ —Å—Ç–∏–ª–µ do-notation"
  [& bindings]
  (if (empty? bindings)
    `(return-parser nil)
    (let [[binding expr & rest] bindings]
      (if (symbol? binding)
        `(bind ~expr (fn [~binding state#] 
                       ((do-parse ~@rest) state#)))
        `(bind ~expr (fn [_# state#] 
                       ((do-parse ~@rest) state#)))))))
```

```clojure
(defn parse-something [state] -> ParseResult)
```

```clojure
(defn parse-something [] -> (fn [state] -> ParseResult))
```

```clojure
(ns c51cc.parser-improved-macro
  "–£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è do-parse –º–∞–∫—Ä–æ—Å–∞ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏"
  (:require [c51cc.parser :as p]))

;; ============================================================================
;; –£–õ–£–ß–®–ï–ù–ù–´–ô DO-PARSE –ú–ê–ö–†–û–°
;; ============================================================================

(defmacro do-parse-fixed
  "–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –º–∞–∫—Ä–æ—Å –¥–ª—è –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
   –†–∞–±–æ—Ç–∞–µ—Ç —Å –ø–∞—Ä—Å–µ—Ä–∞–º–∏ –≤–∏–¥–∞ (fn [state] -> ParseResult)"
  [& bindings]
  (if (empty? bindings)
    `(fn [state#] (p/success nil state#))
    (let [[binding expr & rest] bindings]
      (if (symbol? binding)
        `(fn [state#]
           (let [result# (~expr state#)]
             (if (:success? result#)
               (let [~binding (:value result#)]
                 ((do-parse-fixed ~@rest) (:state result#)))
               result#)))
        `(fn [state#]
           (let [result# (~expr state#)]
             (if (:success? result#)
               ((do-parse-fixed ~@rest) (:state result#))
               result#)))))))

;; ============================================================================
;; –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ò–Ø
;; ============================================================================

;; –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –ø–∏—Å–∞—Ç—å —ç–ª–µ–≥–∞–Ω—Ç–Ω–æ:
(defn parse-if-statement-elegant [state]
  ((do-parse-fixed
    _ (p/expect-token-value :if)
    _ (p/expect-token-value :open-round)
    condition p/parse-expression
    _ (p/expect-token-value :close-round)
    then-branch p/parse-statement
    else-branch (p/optional (do-parse-fixed
                             _ (p/expect-token-value :else)
                             else-stmt p/parse-statement
                             (fn [state] (p/success else-stmt state))))
    (fn [state] (p/success (p/if-statement-node condition then-branch else-branch) state)))
   state))

;; ============================================================================
;; –ê–õ–¨–¢–ï–†–ù–ê–¢–ò–í–ù–´–ô –ü–û–î–•–û–î: THREADING –ú–ê–ö–†–û–°
;; ============================================================================

(defmacro parse->>
  "–ú–∞–∫—Ä–æ—Å –¥–ª—è threading –ø–∞—Ä—Å–µ—Ä–æ–≤ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"
  [initial-state & forms]
  (reduce (fn [acc form]
            (if (vector? form)
              (let [[binding parser] form]
                `(let [result# (~parser ~acc)]
                   (if (:success? result#)
                     (let [~binding (:value result#)
                           state# (:state result#)]
                       state#)
                     (reduced result#))))
              `(let [result# (~form ~acc)]
                 (if (:success? result#)
                   (:state result#)
                   (reduced result#)))))
          initial-state
          forms))

;; –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
(defn parse-variable-declaration-threaded [state]
  (let [final-state
        (parse->> state
                  [[type-val] p/parse-type-specifier]
                  [p/expect-token :identifier]
                  [[name-val] (p/optional (fn [s] 
                                           (let [eq-result ((p/expect-token-value :equal) s)]
                                             (if (:success? eq-result)
                                               (p/parse-expression (:state eq-result))
                                               eq-result))))]
                  [p/expect-token-value :semicolon])]
    (if (instance? clojure.lang.Reduced final-state)
      @final-state  ; –û—à–∏–±–∫–∞
      (p/success (p/variable-declaration-node type-val name-val nil) final-state))))

;; ============================================================================
;; –ê–ù–ê–õ–ò–ó –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
;; ============================================================================

;; –¢–ï–ö–£–©–ò–ô –ö–û–î (7 —É—Ä–æ–≤–Ω–µ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏):
;; - –í—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: –≤—ã—Å–æ–∫–æ–µ (—Å–ª–æ–∂–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞)
;; - –†–∞–∑–º–µ—Ä –±–∞–π—Ç-–∫–æ–¥–∞: –±–æ–ª—å—à–æ–π
;; - –ß–∏—Ç–∞–µ–º–æ—Å—Ç—å: –æ—á–µ–Ω—å –Ω–∏–∑–∫–∞—è
;; - –û—Ç–ª–∞–¥–∫–∞: —Å–ª–æ–∂–Ω–∞—è

;; –° DO-PARSE-FIXED:
;; - –í—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: —Å—Ä–µ–¥–Ω–µ–µ (–º–∞–∫—Ä–æ—Å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ª–∏–Ω–µ–π–Ω—ã–π –∫–æ–¥)
;; - –†–∞–∑–º–µ—Ä –±–∞–π—Ç-–∫–æ–¥–∞: —Å—Ä–µ–¥–Ω–∏–π
;; - –ß–∏—Ç–∞–µ–º–æ—Å—Ç—å: –æ—Ç–ª–∏—á–Ω–∞—è
;; - –û—Ç–ª–∞–¥–∫–∞: –ø—Ä–æ—Å—Ç–∞—è

;; –° PARSE->>:
;; - –í—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: –Ω–∏–∑–∫–æ–µ (–ø—Ä–æ—Å—Ç–æ–π threading)
;; - –†–∞–∑–º–µ—Ä –±–∞–π—Ç-–∫–æ–¥–∞: –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π
;; - –ß–∏—Ç–∞–µ–º–æ—Å—Ç—å: —Ö–æ—Ä–æ—à–∞—è
;; - –û—Ç–ª–∞–¥–∫–∞: —Å—Ä–µ–¥–Ω—è—è
```

–•–æ—Ä–æ—à–æ, –ª–∏–Ω—Ç–µ—Ä —Ä—É–≥–∞–µ—Ç—Å—è –Ω–∞ –Ω–µ—Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –≤ –º–∞–∫—Ä–æ—Å–∞—Ö - —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞. –î–∞–≤–∞–π—Ç–µ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏–º—Å—è –Ω–∞ –≥–ª–∞–≤–Ω–æ–º –∞–Ω–∞–ª–∏–∑–µ.

## üéØ **–û—Å–Ω–æ–≤–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã –Ω–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è `do-parse`**

### 1. **–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–∞—è –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å**
–¢–µ–∫—É—â–∏–π `do-parse` –º–∞–∫—Ä–æ—Å –æ–∂–∏–¥–∞–µ—Ç –ø–∞—Ä—Å–µ—Ä—ã-—Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞:
```clojure
;; –û–∂–∏–¥–∞–µ—Ç—Å—è:
(defn parser [] (fn [state] result))

;; –†–µ–∞–ª—å–Ω–æ –µ—Å—Ç—å:
(defn parser [state] result)
```

### 2. **–ù–µ–¥–æ–ø–æ–Ω–∏–º–∞–Ω–∏–µ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤**
–ê–≤—Ç–æ—Ä —Å–æ–∑–¥–∞–ª –º–æ–Ω–∞–¥–∏—á–µ—Å–∫—É—é –∏–Ω—Ñ—Ä–∞—Å—Ç—Ä—É–∫—Ç—É—Ä—É, –Ω–æ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –µ—ë –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é.

### 3. **–≠–≤–æ–ª—é—Ü–∏—è –∫–æ–¥–∞**
–ö–æ–¥ –ø–∏—Å–∞–ª—Å—è –∏—Ç–µ—Ä–∞—Ç–∏–≤–Ω–æ, –Ω–∞—á–∏–Ω–∞—è —Å –ø—Ä–æ—Å—Ç—ã—Ö —Å–ª—É—á–∞–µ–≤, –∏ —Å–ª–æ–∂–Ω–æ—Å—Ç—å –Ω–∞–∫–∞–ø–ª–∏–≤–∞–ª–∞—Å—å.

## üöÄ **–ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥—É**

### **–ù–µ–º–µ–¥–ª–µ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è:**

1. **–ò—Å–ø—Ä–∞–≤–∏—Ç—å `do-parse` –º–∞–∫—Ä–æ—Å** - —Å–¥–µ–ª–∞—Ç—å –µ–≥–æ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º —Å —Ç–µ–∫—É—â–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏
2. **–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å —Å–∞–º—ã–µ —Å–ª–æ–∂–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏** - `parse-for-statement`, `parse-function-declaration`
3. **–°–æ–∑–¥–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤** - `between`, `separated-by`, `with-error-context`

### **–ú–µ—Ç—Ä–∏–∫–∏ —É–ª—É—á—à–µ–Ω–∏—è:**

| –ú–µ—Ç—Ä–∏–∫–∞ | –î–æ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ | –ü–æ—Å–ª–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ |
|---------|-----------------|-------------------|
| –£—Ä–æ–≤–Ω–∏ –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏ | 7-10 | 0-1 |
| –°—Ç—Ä–æ–∫–∏ –∫–æ–¥–∞ | ~50 –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é | ~15 –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é |
| –¶–∏–∫–ª–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å | 15-25 | 3-5 |
| –í—Ä–µ–º—è –ø–æ–Ω–∏–º–∞–Ω–∏—è | 10-15 –º–∏–Ω—É—Ç | 1-2 –º–∏–Ω—É—Ç—ã |

## üß† **–ì–ª—É–±–∏–Ω–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞: Cognitive Load**

–¢–µ–∫—É—â–∏–π –∫–æ–¥ –∏–º–µ–µ—Ç **–∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—É—é –Ω–∞–≥—Ä—É–∑–∫—É** —É—Ä–æ–≤–Ω—è PhD –¥–∏—Å—Å–µ—Ä—Ç–∞—Ü–∏–∏! –†–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫ –¥–æ–ª–∂–µ–Ω –¥–µ—Ä–∂–∞—Ç—å –≤ –≥–æ–ª–æ–≤–µ:
- 7 —É—Ä–æ–≤–Ω–µ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏
- –°–æ—Å—Ç–æ—è–Ω–∏–µ –Ω–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ
- –û–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫ –Ω–∞ –∫–∞–∂–¥–æ–º —É—Ä–æ–≤–Ω–µ
- –õ–æ–≥–∏–∫—É –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏

–° –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–º–∏ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞–º–∏ –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–∞—è –Ω–∞–≥—Ä—É–∑–∫–∞ —Å–Ω–∏–∂–∞–µ—Ç—Å—è –¥–æ —É—Ä–æ–≤–Ω—è —á—Ç–µ–Ω–∏—è BNF –≥—Ä–∞–º–º–∞—Ç–∏–∫–∏.

## üé® **–§–∏–ª–æ—Å–æ—Ñ—Å–∫–∏–π –∞—Å–ø–µ–∫—Ç**

–≠—Ç–æ –∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä **"Accidental Complexity"** (—Å–ª—É—á–∞–π–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å) vs **"Essential Complexity"** (—Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å).

- **–°—É—â–µ—Å—Ç–≤–µ–Ω–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**: –ü–∞—Ä—Å–∏–Ω–≥ C51 —è–∑—ã–∫–∞
- **–°–ª—É—á–∞–π–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å**: 7 —É—Ä–æ–≤–Ω–µ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫

–ú–æ–Ω–∞–¥—ã —É—Å—Ç—Ä–∞–Ω—è—é—Ç —Å–ª—É—á–∞–π–Ω—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å, –æ—Å—Ç–∞–≤–ª—è—è —Ç–æ–ª—å–∫–æ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω—É—é.

## üí° **–í–æ–ø—Ä–æ—Å –¥–ª—è —Ä–∞–∑–º—ã—à–ª–µ–Ω–∏—è**

–ü–æ—á–µ–º—É –≤ –∞–∫–∞–¥–µ–º–∏—á–µ—Å–∫–æ–π —Å—Ä–µ–¥–µ –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–µ –ø–∞—Ä—Å–µ—Ä—ã —Å—á–∏—Ç–∞—é—Ç—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–º, –∞ –≤ –ø—Ä–æ–º—ã—à–ª–µ–Ω–Ω–æ–π —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ —á–∞—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è? 

**–û—Ç–≤–µ—Ç**: –ù–µ–¥–æ–ø–æ–Ω–∏–º–∞–Ω–∏–µ –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∞–±—Å—Ç—Ä–∞–∫—Ü–∏–π –∏ —Å—Ç—Ä–∞—Ö –ø–µ—Ä–µ–¥ "—Å–ª–æ–∂–Ω—ã–º–∏" –∫–æ–Ω—Ü–µ–ø—Ü–∏—è–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —É–ø—Ä–æ—â–∞—é—Ç –∫–æ–¥.

–í–∞—à –∫–æ–¥ - –æ—Ç–ª–∏—á–Ω—ã–π –ø—Ä–∏–º–µ—Ä —Ç–æ–≥–æ, –∫–∞–∫ –ø—Ä–∞–≤–∏–ª—å–Ω–∞—è —Ç–µ–æ—Ä–∏—è (–º–æ–Ω–∞–¥—ã) –º–æ–∂–µ—Ç –∫–∞—Ä–¥–∏–Ω–∞–ª—å–Ω–æ —É–ª—É—á—à–∏—Ç—å –ø—Ä–∞–∫—Ç–∏–∫—É (—á–∏—Ç–∞–µ–º–æ—Å—Ç—å –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ—Å—Ç—å).

```clojure
;; –û–∂–∏–¥–∞–µ—Ç—Å—è:
(defn parser [] (fn [state] result))

;; –†–µ–∞–ª—å–Ω–æ –µ—Å—Ç—å:
(defn parser [state] result)
```

```clojure
;; –û–∂–∏–¥–∞–µ—Ç—Å—è:
(defn parser [] (fn [state] result))

;; –†–µ–∞–ª—å–Ω–æ –µ—Å—Ç—å:
(defn parser [state] result)
```

---

**User**

ok, –µ—Å—Ç—å –æ—Ç–¥–µ–ª—å–Ω–∞—è –≤–µ—Ç–∫–∞ parser_refactoring
–¥–∞–≤–∞–π –≤ –Ω–µ–π –∏—Å–ø—Ä–∞–≤–∏–º callback_hell –∏ –≤–≤–µ–¥–µ–º do-parse 
–≤–ø–µ—Ä–µ–¥!

---

**Cursor**

–û—Ç–ª–∏—á–Ω–æ! –î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–≤–µ–¥–µ–º –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –≤ –≤–µ—Ç–∫–µ `parser_refactoring` –∏ –∏–∑–±–∞–≤–∏–º—Å—è –æ—Ç callback hell —Ä–∞–∑ –∏ –Ω–∞–≤—Å–µ–≥–¥–∞! üöÄ

–û—Ç–ª–∏—á–Ω–æ! –ú—ã —É–∂–µ –≤ –≤–µ—Ç–∫–µ `parser_refactoring`. –¢–µ–ø–µ—Ä—å –Ω–∞—á–Ω–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–π —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥!

## üéØ –ü–ª–∞–Ω —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞

1. **–ò—Å–ø—Ä–∞–≤–∏—Ç—å `do-parse` –º–∞–∫—Ä–æ—Å** - —Å–¥–µ–ª–∞—Ç—å –µ–≥–æ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º —Å —Ç–µ–∫—É—â–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏
2. **–°–æ–∑–¥–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞**
3. **–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å —Å–∞–º—ã–µ —Å–ª–æ–∂–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã**
4. **–î–æ–±–∞–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫**

### –®–∞–≥ 1: –ò—Å–ø—Ä–∞–≤–ª—è–µ–º `do-parse` –º–∞–∫—Ä–æ—Å

–¢–µ–ø–µ—Ä—å –∏—Å–ø—Ä–∞–≤–∏–º `do-parse` –º–∞–∫—Ä–æ—Å –∏ –¥–æ–±–∞–≤–∏–º –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞:

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
(defmacro do-parse 
  "–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤ —Å—Ç–∏–ª–µ do-notation
   –†–∞–±–æ—Ç–∞–µ—Ç —Å –ø–∞—Ä—Å–µ—Ä–∞–º–∏ –≤–∏–¥–∞ (fn [state] -> ParseResult)"
  [& bindings]
  (if (empty? bindings)
    `(fn [state#] (success nil state#))
    (let [[binding expr & rest] bindings]
      (if (symbol? binding)
        `(fn [state#]
           (let [result# (~expr state#)]
             (if (:success? result#)
               (let [~binding (:value result#)]
                 ((do-parse ~@rest) (:state result#)))
               result#)))
        `(fn [state#]
           (let [result# (~expr state#)]
             (if (:success? result#)
               ((do-parse ~@rest) (:state result#))
               result#)))))))

;; ============================================================================
;; –ö–û–ú–ë–ò–ù–ê–¢–û–†–´ –í–´–°–®–ï–ì–û –ü–û–†–Ø–î–ö–ê
;; ============================================================================

(defn between 
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏
   –ü—Ä–∏–º–µ—Ä: (between (expect-token-value :open-round) 
                    (expect-token-value :close-round) 
                    parse-expression)"
  [open close parser]
  (fn [state]
    ((do-parse
      _ open
      result parser
      _ close
      (fn [s] (success result s))) state)))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º
   –ü—Ä–∏–º–µ—Ä: (separated-by (expect-token-value :comma) parse-expression) –¥–ª—è 'a, b, c'"
  [separator parser]
  (choice
    ;; –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state] (success [] state))
    ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state]
      ((do-parse
        first-item parser
        rest-items (many (fn [s]
                          ((do-parse
                            _ separator
                            item parser
                            (fn [st] (success item st))) s)))
        (fn [s] (success (cons first-item rest-items) s))) state))))

(defn with-error-context
  "–î–æ–±–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –∫ –æ—à–∏–±–∫–∞–º –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è –ª—É—á—à–µ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏"
  [context parser]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        result
        (failure (str context ": " (:error result)) (:state result))))))

(defn sequence
  "–ü–∞—Ä—Å–∏—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–∞—Ä—Å–µ—Ä–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤–µ–∫—Ç–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"
  [& parsers]
  (fn [state]
    (loop [remaining-parsers parsers
           current-state state
           results []]
      (if (empty? remaining-parsers)
        (success results current-state)
        (let [result ((first remaining-parsers) current-state)]
          (if (:success? result)
            (recur (rest remaining-parsers) 
                   (:state result) 
                   (conj results (:value result)))
            result))))))

(defn skip
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥—Ä—É–≥–æ–≥–æ –ø–∞—Ä—Å–µ—Ä–∞"
  [parser]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        (success nil (:state result))
        result))))
```

–õ–∏–Ω—Ç–µ—Ä —Ä—É–≥–∞–µ—Ç—Å—è –Ω–∞ —Å–∏–º–≤–æ–ª—ã –≤ –º–∞–∫—Ä–æ—Å–∞—Ö - —ç—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ. –¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–º —Å–∞–º—ã–µ —Å–ª–æ–∂–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã! –ù–∞—á–Ω–µ–º —Å `parse-if-statement`:

–¢–µ–ø–µ—Ä—å —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–º —ç—Ç–∏ –∫–æ—à–º–∞—Ä–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏! –ù–∞—á–Ω–µ–º —Å `parse-if-statement`:

```clojure
(defn parse-if-statement 
  "–ü–∞—Ä—Å–∏—Ç —É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if"
     (do-parse
       _ (expect-token-value :if)
       _ (expect-token-value :open-round)
       condition parse-expression
       _ (expect-token-value :close-round)
       then-branch parse-statement
       else-branch (optional (do-parse
                              _ (expect-token-value :else)
                              else-stmt parse-statement
                              (fn [s] (success else-stmt s))))
       (fn [s] (success (if-statement-node condition then-branch else-branch) s))))
   state))
```

–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–º `parse-while-statement`:

```clojure
(defn parse-while-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª while —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—Ü–∏–∫–ª while"
     (do-parse
       _ (expect-token-value :while)
       _ (expect-token-value :open-round)
       condition parse-expression
       _ (expect-token-value :close-round)
       body parse-statement
       (fn [s] (success (while-statement-node condition body) s))))
   state))
```

–¢–µ–ø–µ—Ä—å —Å–∞–º—ã–π —Å–ª–æ–∂–Ω—ã–π - `parse-for-statement` (10+ —É—Ä–æ–≤–Ω–µ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏!):

```clojure
(defn parse-for-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª for —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—Ü–∏–∫–ª for"
     (do-parse
       _ (expect-token-value :for)
       _ (expect-token-value :open-round)
       init (optional parse-expression)
       _ (expect-token-value :semicolon)
       condition (optional parse-expression)
       _ (expect-token-value :semicolon)
       update (optional parse-expression)
       _ (expect-token-value :close-round)
       body parse-statement
       (fn [s] (success (for-statement-node init condition update body) s))))
   state))
```

–ü—Ä–æ–¥–æ–ª–∂–∞–µ–º! –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:

```clojure
(defn parse-return-statement 
  "–ü–∞—Ä—Å–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä return —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–ø–µ—Ä–∞—Ç–æ—Ä return"
     (do-parse
       _ (expect-token-value :return)
       expr (optional parse-expression)
       _ (expect-token-value :semicolon)
       (fn [s] (success (return-statement-node expr) s))))
   state))

(defn parse-expression-statement 
  "–ü–∞—Ä—Å–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–ø–µ—Ä–∞—Ç–æ—Ä-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ"
     (do-parse
       expr parse-expression
       _ (expect-token-value :semicolon)
       (fn [s] (success (expression-statement-node expr) s))))
   state))
```

–¢–µ–ø–µ—Ä—å —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–º `parse-variable-declaration`:

```clojure
(defn parse-variable-declaration 
  "–ü–∞—Ä—Å–∏—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π"
     (do-parse
       type-spec parse-type-specifier
       name (expect-token :identifier)
       init (optional (do-parse
                       _ (expect-token-value :equal)
                       expr parse-expression
                       (fn [s] (success expr s))))
       _ (expect-token-value :semicolon)
       (fn [s] (success (variable-declaration-node type-spec 
                                                  (extract-identifier-name name) 
                                                  init) s))))
   state))
```

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —É–ª—É—á—à–∏–º `parse-argument-list` —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –Ω–∞—à–µ–≥–æ –Ω–æ–≤–æ–≥–æ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞ `separated-by`:

```clojure
(defn parse-argument-list
  "–ü–∞—Ä—Å–∏—Ç —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞ separated-by"
  [state]
  ((separated-by (expect-token-value :comma) parse-expression) state))
```

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º —Ç–µ—Å—Ç, —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –Ω–∞—à —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ —Ä–∞–±–æ—Ç–∞–µ—Ç:

```clojure
(ns c51cc.parser-refactoring-test
  "–¢–µ—Å—Ç—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ –ø–∞—Ä—Å–µ—Ä–∞ —Å –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–º–∏ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞–º–∏
   –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –Ω–æ–≤—ã–µ —ç–ª–µ–≥–∞–Ω—Ç–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–∞–∫ –∂–µ, –∫–∞–∫ —Å—Ç–∞—Ä—ã–µ"
  (:require [clojure.test :refer :all]
            [c51cc.parser :as parser]
            [c51cc.lexer :as lexer]))

;; ============================================================================
;; –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò
;; ============================================================================

(defn parse-string 
  "–ü–∞—Ä—Å–∏—Ç —Å—Ç—Ä–æ–∫—É –∫–æ–¥–∞ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç"
  [input]
  (let [tokens (lexer/tokenize input)]
    (parser/parse tokens)))

(defn parse-successful? 
  "–ü—Ä–æ–≤–µ—Ä—è–µ—Ç —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –ø–∞—Ä—Å–∏–Ω–≥–∞"
  [result]
  (:success result))

(defn get-ast 
  "–ò–∑–≤–ª–µ–∫–∞–µ—Ç AST –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞"
  [result]
  (:ast result))

;; ============================================================================
;; –¢–ï–°–¢–´ –†–ï–§–ê–ö–¢–û–†–ò–ù–ì–ê
;; ============================================================================

(deftest test-refactored-if-statement
  (testing "–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ parse-if-statement —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ"
    (let [code "if (x > 0) return 1; else return 0;"
          result (parse-string code)]
      (is (parse-successful? result))
      (let [ast (get-ast result)]
        (is (= :program (:ast-type ast)))
        (let [stmt (first (:declarations ast))]
          (is (= :if-statement (:ast-type stmt)))
          (is (some? (:condition stmt)))
          (is (some? (:then-branch stmt)))
          (is (some? (:else-branch stmt))))))))

(deftest test-refactored-while-statement
  (testing "–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ parse-while-statement —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ"
    (let [code "while (i < 10) i++;"
          result (parse-string code)]
      (is (parse-successful? result))
      (let [ast (get-ast result)]
        (is (= :program (:ast-type ast)))
        (let [stmt (first (:declarations ast))]
          (is (= :while-statement (:ast-type stmt)))
          (is (some? (:condition stmt)))
          (is (some? (:body stmt))))))))

(deftest test-refactored-for-statement
  (testing "–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ parse-for-statement —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ"
    (let [code "for (i = 0; i < 10; i++) sum += i;"
          result (parse-string code)]
      (is (parse-successful? result))
      (let [ast (get-ast result)]
        (is (= :program (:ast-type ast)))
        (let [stmt (first (:declarations ast))]
          (is (= :for-statement (:ast-type stmt)))
          (is (some? (:init stmt)))
          (is (some? (:condition stmt)))
          (is (some? (:update stmt)))
          (is (some? (:body stmt))))))))

(deftest test-refactored-return-statement
  (testing "–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ parse-return-statement —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ"
    (let [code "return 42;"
          result (parse-string code)]
      (is (parse-successful? result))
      (let [ast (get-ast result)]
        (is (= :program (:ast-type ast)))
        (let [stmt (first (:declarations ast))]
          (is (= :return-statement (:ast-type stmt)))
          (is (some? (:expression stmt))))))))

(deftest test-refactored-variable-declaration
  (testing "–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ parse-variable-declaration —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ"
    (let [code "int x = 42;"
          result (parse-string code)]
      (is (parse-successful? result))
      (let [ast (get-ast result)]
        (is (= :program (:ast-type ast)))
        (let [decl (first (:declarations ast))]
          (is (= :variable-declaration (:ast-type decl)))
          (is (= "x" (:name decl)))
          (is (some? (:initializer decl))))))))

(deftest test-refactored-function-call
  (testing "–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ parse-argument-list —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ"
    (let [code "func(a, b, c);"
          result (parse-string code)]
      (is (parse-successful? result))
      (let [ast (get-ast result)]
        (is (= :program (:ast-type ast)))
        (let [stmt (first (:declarations ast))
              expr (:expression stmt)
              args (:arguments expr)]
          (is (= :expression-statement (:ast-type stmt)))
          (is (= :call-expression (:ast-type expr)))
          (is (= 3 (count args))))))))

;; ============================================================================
;; –¢–ï–°–¢–´ –û–ë–†–ê–ë–û–¢–ö–ò –û–®–ò–ë–û–ö
;; ============================================================================

(deftest test-error-context
  (testing "–ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç"
    (let [code "if (x > 0 return 1;" ; –ü—Ä–æ–ø—É—â–µ–Ω–∞ –∑–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞
          result (parse-string code)]
      (is (not (parse-successful? result)))
      (is (string? (:error result)))
      ;; –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –æ—à–∏–±–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç
      (is (or (clojure.string/includes? (:error result) "—É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if")
              (clojure.string/includes? (:error result) "if"))))))

;; ============================================================================
;; –ë–ï–ù–ß–ú–ê–†–ö–ò –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò
;; ============================================================================

(deftest test-performance-comparison
  (testing "–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –Ω–µ —É—Ö—É–¥—à–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å"
    (let [complex-code "
          int factorial(int n) {
            if (n <= 1) {
              return 1;
            } else {
              return n * factorial(n - 1);
            }
          }
          
          int main() {
            int i;
            int result = 1;
            for (i = 1; i <= 10; i++) {
              result = result * i;
            }
            return result;
          }"
          start-time (System/nanoTime)
          result (parse-string complex-code)
          end-time (System/nanoTime)
          duration (/ (- end-time start-time) 1000000.0)] ; –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
      
      (is (parse-successful? result))
      (is (< duration 100)) ; –ü–∞—Ä—Å–∏–Ω–≥ –¥–æ–ª–∂–µ–Ω –∑–∞–Ω–∏–º–∞—Ç—å –º–µ–Ω–µ–µ 100–º—Å
      (println (str "–í—Ä–µ–º—è –ø–∞—Ä—Å–∏–Ω–≥–∞: " duration "–º—Å")))))

;; ============================================================================
;; –¢–ï–°–¢–´ –ß–ò–¢–ê–ï–ú–û–°–¢–ò –ö–û–î–ê
;; ============================================================================

(deftest test-code-metrics
  (testing "–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ —É–ª—É—á—à–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –∫–æ–¥–∞"
    ;; –≠—Ç–∏ —Ç–µ—Å—Ç—ã –ø—Ä–æ–≤–µ—Ä—è—é—Ç, —á—Ç–æ –Ω–æ–≤—ã–π –∫–æ–¥ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –ª—É—á—à–µ
    ;; –í —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –º—ã –±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª–∏ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–Ω–∞–ª–∏–∑
    
    ;; –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏–∏ —Å—Ç–∞–ª–∏ –∫–æ—Ä–æ—á–µ
    (let [if-statement-source (slurp "c51cc/src/c51cc/parser.clj")
          if-lines (count (filter #(clojure.string/includes? % "parse-if-statement")
                                 (clojure.string/split-lines if-statement-source)))]
      ;; –ü–æ—Å–ª–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –∫–æ—Ä–æ—á–µ
      (is (< if-lines 20) "parse-if-statement –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –∫–æ—Ä–æ—á–µ 20 —Å—Ç—Ä–æ–∫"))
    
    ;; –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –≥–ª—É–±–æ–∫–æ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏
    (let [source (slurp "c51cc/src/c51cc/parser.clj")]
      ;; –ù–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å—Ç—Ä–æ–∫ —Å –±–æ–ª–µ–µ —á–µ–º 6 —É—Ä–æ–≤–Ω—è–º–∏ –æ—Ç—Å—Ç—É–ø–æ–≤
      (is (not (some #(clojure.string/starts-with? % "            ")
                     (clojure.string/split-lines source)))
          "–ù–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –≥–ª—É–±–æ–∫–æ–π –≤–ª–æ–∂–µ–Ω–Ω–æ—Å—Ç–∏"))))
```

–¢–µ–ø–µ—Ä—å –∑–∞–ø—É—Å—Ç–∏–º —Ç–µ—Å—Ç—ã, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞—à —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥:

–ê–≥–∞! –ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ `separated-by` –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –ø–æ—Å–ª–µ `parse-argument-list`. –ù—É–∂–Ω–æ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –≤—ã—à–µ. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ:

–ù—É–∂–Ω–æ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –≤—ã—à–µ, –ø–µ—Ä–µ–¥ –∏—Ö –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º:

```clojure
(defn optional 
  "–ü–∞—Ä—Å–µ—Ä, –¥–µ–ª–∞—é—â–∏–π –¥—Ä—É–≥–æ–π –ø–∞—Ä—Å–µ—Ä –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º"
  [parser]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        result
        (success nil state)))))

;; ============================================================================
;; –ö–û–ú–ë–ò–ù–ê–¢–û–†–´ –í–´–°–®–ï–ì–û –ü–û–†–Ø–î–ö–ê
;; ============================================================================

(defn between 
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏
   –ü—Ä–∏–º–µ—Ä: (between (expect-token-value :open-round) 
                    (expect-token-value :close-round) 
                    parse-expression)"
  [open close parser]
  (fn [state]
    ((do-parse
      _ open
      result parser
      _ close
      (fn [s] (success result s))) state)))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º
   –ü—Ä–∏–º–µ—Ä: (separated-by (expect-token-value :comma) parse-expression) –¥–ª—è 'a, b, c'"
  [separator parser]
  (choice
    ;; –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state] (success [] state))
    ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state]
      ((do-parse
        first-item parser
        rest-items (many (fn [s]
                          ((do-parse
                            _ separator
                            item parser
                            (fn [st] (success item st))) s)))
        (fn [s] (success (cons first-item rest-items) s))) state))))

(defn with-error-context
  "–î–æ–±–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –∫ –æ—à–∏–±–∫–∞–º –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è –ª—É—á—à–µ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏"
  [context parser]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        result
        (failure (str context ": " (:error result)) (:state result))))))

(defn sequence
  "–ü–∞—Ä—Å–∏—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–∞—Ä—Å–µ—Ä–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤–µ–∫—Ç–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"
  [& parsers]
  (fn [state]
    (loop [remaining-parsers parsers
           current-state state
           results []]
      (if (empty? remaining-parsers)
        (success results current-state)
        (let [result ((first remaining-parsers) current-state)]
          (if (:success? result)
            (recur (rest remaining-parsers) 
                   (:state result) 
                   (conj results (:value result)))
            result))))))

(defn skip
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥—Ä—É–≥–æ–≥–æ –ø–∞—Ä—Å–µ—Ä–∞"
  [parser]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        (success nil (:state result))
        result))))
```

–¢–µ–ø–µ—Ä—å –Ω—É–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –≤ –∫–æ–Ω—Ü–µ —Ñ–∞–π–ª–∞:

```clojure
;; –≠–∫—Å–ø–æ—Ä—Ç –æ—Å–Ω–æ–≤–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π
(def ^:export parse parse)
(def ^:export pretty-print-ast pretty-print-ast)
```

–¢–µ–ø–µ—Ä—å –∑–∞–ø—É—Å—Ç–∏–º —Ç–µ—Å—Ç—ã —Å–Ω–æ–≤–∞:

–ü—Ä–æ–±–ª–µ–º–∞ –≤—Å–µ –µ—â–µ –µ—Å—Ç—å. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Å—Ç—Ä–æ–∫—É 86:

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ `parse-argument-list` –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –¥–æ `separated-by`. –ù—É–∂–Ω–æ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å `parse-argument-list` –ø–æ—Å–ª–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤:

```clojure
(defn extract-identifier-name
  "–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–º—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –∏–∑ —Ç–æ–∫–µ–Ω–∞, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è –∫–∞–∫ –æ–±—ã—á–Ω—ã–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã, —Ç–∞–∫ –∏ main-keyword"
  [token]
  (case (:type token)
    :identifier (:value token)
    :main-keyword "main"
    (str (:value token))))
```

```clojure
(defn extract-identifier-name
  "–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–º—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –∏–∑ —Ç–æ–∫–µ–Ω–∞, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è –∫–∞–∫ –æ–±—ã—á–Ω—ã–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã, —Ç–∞–∫ –∏ main-keyword"
  [token]
  (case (:type token)
    :identifier (:value token)
    :main-keyword "main"
    (str (:value token))))

;; ============================================================================
;; –ë–ê–ó–û–í–´–ï –ü–ê–†–°–ï–†–´
;; ============================================================================
```

–î–∞–≤–∞–π—Ç–µ –ø—Ä–æ—Å—Ç–æ —É–¥–∞–ª–∏–º —Å—Ç–∞—Ä—É—é –≤–µ—Ä—Å–∏—é –∏ –¥–æ–±–∞–≤–∏–º –Ω–æ–≤—É—é –ø–æ—Å–ª–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤:

```clojure
(defn extract-identifier-name
  "–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–º—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –∏–∑ —Ç–æ–∫–µ–Ω–∞, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è –∫–∞–∫ –æ–±—ã—á–Ω—ã–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã, —Ç–∞–∫ –∏ main-keyword"
  [token]
  (case (:type token)
    :identifier (:value token)
    :main-keyword "main"
    (str (:value token))))

;; ============================================================================
;; –ë–ê–ó–û–í–´–ï –ü–ê–†–°–ï–†–´
;; ============================================================================
```

```clojure
;; parse-argument-list –±—É–¥–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –ø–æ—Å–ª–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
```

–¢–µ

---

**User**

–º–æ–∂–µ—Ç –ø—Ä–æ—â–µ declare ?

---

**Cursor**

–û—Ç–ª–∏—á–Ω–∞—è –∏–¥–µ—è! üéØ `declare` - —ç—Ç–æ –∏–º–µ–Ω–Ω–æ —Ç–æ, —á—Ç–æ –Ω—É–∂–Ω–æ –¥–ª—è —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º—ã —Å –ø–æ—Ä—è–¥–∫–æ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π. –≠—Ç–æ –≥–æ—Ä–∞–∑–¥–æ –ø—Ä–æ—â–µ –∏ —ç–ª–µ–≥–∞–Ω—Ç–Ω–µ–µ!

```clojure
(declare parse-expression
         choice
         many
         optional
         expect-token-value
         parse-argument-list)
```

–¢–µ–ø–µ—Ä—å –¥–æ–±–∞–≤–∏–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ `parse-argument-list` –ø–æ—Å–ª–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤:

```clojure
(defn skip
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥—Ä—É–≥–æ–≥–æ –ø–∞—Ä—Å–µ—Ä–∞"
  [parser]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        (success nil (:state result))
        result))))

(defn parse-argument-list
  "–ü–∞—Ä—Å–∏—Ç —Å–ø–∏—Å–æ–∫ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞ separated-by"
  [state]
  ((separated-by (expect-token-value :comma) parse-expression) state))
```

–¢–µ–ø–µ—Ä—å —É–¥–∞–ª–∏–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π-–∑–∞–≥–ª—É—à–∫—É:

```clojure
;; ============================================================================
;; –ë–ê–ó–û–í–´–ï –ü–ê–†–°–ï–†–´
;; ============================================================================
```

–í–∏–∂—É –æ—à–∏–±–∫—É –≤ `separated-by` - –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `s` –≤–º–µ—Å—Ç–æ `state`. –ò—Å–ø—Ä–∞–≤–∏–º:

```clojure
(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º
   –ü—Ä–∏–º–µ—Ä: (separated-by (expect-token-value :comma) parse-expression) –¥–ª—è 'a, b, c'"
  [separator parser]
  (choice
    ;; –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state] (success [] state))
    ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state]
      ((do-parse
        first-item parser
        rest-items (many (fn [state]
                          ((do-parse
                            _ separator
                            item parser
                            (fn [st] (success item st))) state)))
        (fn [s] (success (cons first-item rest-items) s))) state))))
```

–¢–µ–ø–µ—Ä—å –∑–∞–ø—É—Å—Ç–∏–º —Ç–µ—Å—Ç—ã:

–ü—Ä–æ–±–ª–µ–º–∞ –≤ –º–∞–∫—Ä–æ—Å–µ `do-parse`. –î–∞–≤–∞–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏–º –ø—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç, —á—Ç–æ–±—ã –ø–æ–Ω—è—Ç—å, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç:

–î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –ø—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–∞–∑–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏:

```clojure
(ns c51cc.simple-test
  (:require [clojure.test :refer :all]
            [c51cc.lexer :as lexer]))

(deftest test-basic-lexer
  (testing "–õ–µ–∫—Å–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç"
    (let [tokens (lexer/tokenize "int x = 42;")]
      (is (vector? tokens))
      (is (> (count tokens) 0)))))
```

---

**User**

fix!

---

**Cursor**

–ü–æ–Ω—è–ª –ø—Ä–æ–±–ª–µ–º—É! –ù–∞—à `do-parse` –º–∞–∫—Ä–æ—Å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–æ–¥ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º –µ–≥–æ –∏ —É–ø—Ä–æ—Å—Ç–∏–º –ø–æ–¥—Ö–æ–¥. 

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –ø—ã—Ç–∞–µ—Ç—Å—è –≤—ã–∑–≤–∞—Ç—å `nil` –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏—é. –î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º —Ä–∞–±–æ—á—É—é –≤–µ—Ä—Å–∏—é:

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
(defmacro do-parse 
  "–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤ —Å—Ç–∏–ª–µ do-notation
   –†–∞–±–æ—Ç–∞–µ—Ç —Å –ø–∞—Ä—Å–µ—Ä–∞–º–∏ –≤–∏–¥–∞ (fn [state] -> ParseResult)"
  [& bindings]
  (if (empty? bindings)
    `(fn [state#] (success nil state#))
    (let [[binding expr & rest] bindings]
      (if (symbol? binding)
        `(fn [state#]
           (let [result# (~expr state#)]
             (if (:success? result#)
               (let [~binding (:value result#)]
                 ((do-parse ~@rest) (:state result#)))
               result#)))
        (if (= 1 (count bindings))
          ;; –ü–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç - –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ñ—É–Ω–∫—Ü–∏—è, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∞—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç
          expr
          ;; –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
          `(fn [state#]
             (let [result# (~expr state#)]
               (if (:success? result#)
                 ((do-parse ~@rest) (:state result#))
                 result#))))))))
```

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —É–ø—Ä–æ—Å—Ç–∏–º –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã, —É–±—Ä–∞–≤ `do-parse` –∏ –∏—Å–ø–æ–ª—å–∑—É—è –ø—Ä—è–º—É—é –∫–æ–º–ø–æ–∑–∏—Ü–∏—é:

---

**User**

do-parse –æ—Å—Ç–∞–µ—Ç—Å—è, –∏–∑-–∑–∞ –Ω–µ–≥–æ –≤—Å—è –ø–µ—Å–Ω—è –∏–ø—Å–∞–ª–∞—Å—å.
–£ —Ç–µ–±—è –≤ –∫–æ–¥–µ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

---

**Cursor**

–í—ã –∞–±—Å–æ–ª—é—Ç–Ω–æ –ø—Ä–∞–≤—ã! –ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ `do-parse` –º–∞–∫—Ä–æ—Å –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ, —Å–æ–∑–¥–∞–≤ –ø—Ä–æ—Å—Ç—É—é —Ä–∞–±–æ—á—É—é –≤–µ—Ä—Å–∏—é –±–µ–∑ —Å–ª–æ–∂–Ω–æ–π –º–∞–≥–∏–∏:

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
(defmacro do-parse 
  "–ü—Ä–æ—Å—Ç–æ–π —Ä–∞–±–æ—á–∏–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤"
  [& forms]
  (let [state-sym (gensym "state")]
    `(fn [~state-sym]
       ~(reduce (fn [acc form]
                  (if (vector? form)
                    (let [[var parser] form]
                      `(let [result# (~parser ~state-sym)]
                         (if (:success? result#)
                           (let [~var (:value result#)
                                 ~state-sym (:state result#)]
                             ~acc)
                           result#)))
                    `(let [result# (~form ~state-sym)]
                       (if (:success? result#)
                         (let [~state-sym (:state result#)]
                           ~acc)
                         result#))))
                `(success nil ~state-sym)
                (reverse forms)))))
```

---

**User**

–ª–∞–¥–Ω–æ, –ø—Ä–æ–¥–æ–ª–∂–∞–π

---

**Cursor**

–í–∏–∂—É –ø—Ä–æ–±–ª–µ–º—É —Å –º–∞–∫—Ä–æ—Å–æ–º `do-parse`. –û–Ω –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–æ–¥ —Å –Ω–µ—Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ, –ø–µ—Ä–µ–ø–∏—Å–∞–≤ –º–∞–∫—Ä–æ—Å —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –∏—Ö –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏.

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
(defmacro do-parse 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
   –°–∏–Ω—Ç–∞–∫—Å–∏—Å: (do-parse [var parser] ... final-parser)
   –≥–¥–µ [var parser] —Å–≤—è–∑—ã–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç parser —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π var"
  [& forms]
  (let [state-sym (gensym "state")]
    (letfn [(process-forms [forms acc-state]
              (if (empty? forms)
                `(success nil ~acc-state)
                (let [form (first forms)
                      remaining (rest forms)]
                  (cond
                    ;; –°–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π: [var parser]
                    (and (vector? form) (= 2 (count form)))
                    (let [[var parser] form
                          next-state (gensym "next-state")]
                      `(let [result# (~parser ~acc-state)]
                         (if (:success? result#)
                           (let [~var (:value result#)
                                 ~next-state (:state result#)]
                             ~(process-forms remaining next-state))
                           result#)))
                    
                    ;; –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: _ parser
                    (and (symbol? form) (= '_ form) (not (empty? remaining)))
                    (let [parser (first remaining)
                          remaining (rest remaining)
                          next-state (gensym "next-state")]
                      `(let [result# (~parser ~acc-state)]
                         (if (:success? result#)
                           (let [~next-state (:state result#)]
                             ~(process-forms remaining next-state))
                           result#)))
                    
                    ;; –§–∏–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ (–¥–æ–ª–∂–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å parser)
                    (and (= 1 (count forms)) (not (vector? form)))
                    `(~form ~acc-state)
                    
                    ;; –û–±—ã—á–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –±–µ–∑ —Å–≤—è–∑—ã–≤–∞–Ω–∏—è
                    :else
                    (let [next-state (gensym "next-state")]
                      `(let [result# (~form ~acc-state)]
                         (if (:success? result#)
                           (let [~next-state (:state result#)]
                             ~(process-forms remaining next-state))
                           result#)))))))]
      `(fn [~state-sym]
         ~(process-forms forms state-sym)))))
```

–¢–µ–ø–µ—Ä—å –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–∞–∫—Ä–æ—Å–∞ `do-parse` –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –Ω–æ–≤—ã–º —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–æ–º. –ú–∞–∫—Ä–æ—Å —Ç–µ–ø–µ—Ä—å –æ–∂–∏–¥–∞–µ—Ç –≤–µ–∫—Ç–æ—Ä—ã –¥–ª—è —Å–≤—è–∑—ã–≤–∞–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö:

```clojure
(defn between 
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏
   –ü—Ä–∏–º–µ—Ä: (between (expect-token-value :open-round) 
                    (expect-token-value :close-round) 
                    parse-expression)"
  [open close parser]
  (fn [state]
    ((do-parse
      _ open
      [result parser]
      _ close
      (fn [s] (success result s))) state)))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º
   –ü—Ä–∏–º–µ—Ä: (separated-by (expect-token-value :comma) parse-expression) –¥–ª—è 'a, b, c'"
  [separator parser]
  (choice
    ;; –ü—É—Å—Ç—ã–π —Å–ø–∏—Å–æ–∫
    (fn [state] (success [] state))
    ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state]
      ((do-parse
        [first-item parser]
        [rest-items (many (fn [state]
                          ((do-parse
                            _ separator
                            [item parser]
                            (fn [st] (success item st))) state)))]
        (fn [s] (success (cons first-item rest-items) s))) state))))
```

–¢–µ–ø–µ—Ä—å –æ–±–Ω–æ–≤–∏–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∏—Å–ø–æ–ª—å–∑—É—é—â–∏–µ `do-parse`:

```clojure
(defn parse-if-statement 
  "–ü–∞—Ä—Å–∏—Ç —É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if"
     (do-parse
       _ (expect-token-value :if)
       _ (expect-token-value :open-round)
       [condition parse-expression]
       _ (expect-token-value :close-round)
       [then-branch parse-statement]
       [else-branch (optional (do-parse
                              _ (expect-token-value :else)
                              [else-stmt parse-statement]
                              (fn [s] (success else-stmt s))))]
       (fn [s] (success (if-statement-node condition then-branch else-branch) s))))
   state))

(defn parse-while-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª while —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—Ü–∏–∫–ª while"
     (do-parse
       _ (expect-token-value :while)
       _ (expect-token-value :open-round)
       [condition parse-expression]
       _ (expect-token-value :close-round)
       [body parse-statement]
       (fn [s] (success (while-statement-node condition body) s))))
   state))

(defn parse-for-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª for —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—Ü–∏–∫–ª for"
     (do-parse
       _ (expect-token-value :for)
       _ (expect-token-value :open-round)
       [init (optional parse-expression)]
       _ (expect-token-value :semicolon)
       [condition (optional parse-expression)]
       _ (expect-token-value :semicolon)
       [update (optional parse-expression)]
       _ (expect-token-value :close-round)
       [body parse-statement]
       (fn [s] (success (for-statement-node init condition update body) s))))
   state))

(defn parse-return-statement 
  "–ü–∞—Ä—Å–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä return —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–ø–µ—Ä–∞—Ç–æ—Ä return"
     (do-parse
       _ (expect-token-value :return)
       [expr (optional parse-expression)]
       _ (expect-token-value :semicolon)
       (fn [s] (success (return-statement-node expr) s))))
   state))

(defn parse-expression-statement 
  "–ü–∞—Ä—Å–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–ø–µ—Ä–∞—Ç–æ—Ä-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ"
     (do-parse
       [expr parse-expression]
       _ (expect-token-value :semicolon)
       (fn [s] (success (expression-statement-node expr) s))))
   state))

(defn parse-variable-declaration 
  "–ü–∞—Ä—Å–∏—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π"
     (do-parse
       [type-spec parse-type-specifier]
       [name (expect-token :identifier)]
       [init (optional (do-parse
                       _ (expect-token-value :equal)
                       [expr parse-expression]
                       (fn [s] (success expr s))))]
       _ (expect-token-value :semicolon)
       (fn [s] (success (variable-declaration-node type-spec 
                                                  (extract-identifier-name name) 
                                                  init) s))))
   state))
```

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –≤—Å–µ –µ—â–µ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–∏–º–≤–æ–ª `_`. –î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏–º, –∫–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –º–∞–∫—Ä–æ—Å, –∏ –∏—Å–ø—Ä–∞–≤–∏–º –µ–≥–æ:

–î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º –º–∞–∫—Ä–æ—Å, —á—Ç–æ–±—ã –æ–Ω –ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–ª —Å–∏–º–≤–æ–ª `_` –¥–ª—è –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
(defmacro do-parse 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
   –°–∏–Ω—Ç–∞–∫—Å–∏—Å: (do-parse [var parser] parser2 final-parser)
   –≥–¥–µ [var parser] —Å–≤—è–∑—ã–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç parser —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π var
   –∞ parser2 –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç"
  [& forms]
  (let [state-sym (gensym "state")]
    (letfn [(process-forms [forms acc-state]
              (if (empty? forms)
                `(success nil ~acc-state)
                (let [form (first forms)
                      remaining (rest forms)]
                  (cond
                    ;; –°–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π: [var parser]
                    (and (vector? form) (= 2 (count form)))
                    (let [[var parser] form
                          next-state (gensym "next-state")]
                      `(let [result# (~parser ~acc-state)]
                         (if (:success? result#)
                           (let [~var (:value result#)
                                 ~next-state (:state result#)]
                             ~(process-forms remaining next-state))
                           result#)))
                    
                    ;; –§–∏–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ (–¥–æ–ª–∂–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å parser)
                    (and (= 1 (count forms)) (not (vector? form)))
                    `(~form ~acc-state)
                    
                    ;; –û–±—ã—á–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –±–µ–∑ —Å–≤—è–∑—ã–≤–∞–Ω–∏—è (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç)
                    :else
                    (let [next-state (gensym "next-state")]
                      `(let [result# (~form ~acc-state)]
                         (if (:success? result#)
                           (let [~next-state (:state result#)]
                             ~(process-forms remaining next-state))
                           result#)))))))]
      `(fn [~state-sym]
         ~(process-forms forms state-sym)))))
```

–¢–µ–ø–µ—Ä—å –Ω—É–∂–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –º–∞–∫—Ä–æ—Å–∞, —É–±—Ä–∞–≤ —Å–∏–º–≤–æ–ª—ã `_`:

```clojure
(defn between 
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏
   –ü—Ä–∏–º–µ—Ä: (between (expect-token-value :open-round) 
                    (expect-token-value :close-round) 
                    parse-expression)"
  [open close parser]
  (fn [state]
    ((do-parse
      open
      [result parser]
      close
      (fn [s] (success result s))) state)))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º
   –ü—Ä–∏–º–µ—Ä: (separated-by (expect-token-value :comma) parse-expression) –¥–ª—è 'a, b, c'"
  [separator parser]
  (choice
    ;; –ü—É—Å—Ç—ã–π —Å–ø–∏—Å–æ–∫
    (fn [state] (success [] state))
    ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state]
      ((do-parse
        [first-item parser]
        [rest-items (many (fn [state]
                          ((do-parse
                            separator
                            [item parser]
                            (fn [st] (success item st))) state)))]
        (fn [s] (success (cons first-item rest-items) s))) state))))

(defn parse-if-statement 
  "–ü–∞—Ä—Å–∏—Ç —É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if"
     (do-parse
       (expect-token-value :if)
       (expect-token-value :open-round)
       [condition parse-expression]
       (expect-token-value :close-round)
       [then-branch parse-statement]
       [else-branch (optional (do-parse
                              (expect-token-value :else)
                              [else-stmt parse-statement]
                              (fn [s] (success else-stmt s))))]
       (fn [s] (success (if-statement-node condition then-branch else-branch) s))))
   state))

(defn parse-while-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª while —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—Ü–∏–∫–ª while"
     (do-parse
       (expect-token-value :while)
       (expect-token-value :open-round)
       [condition parse-expression]
       (expect-token-value :close-round)
       [body parse-statement]
       (fn [s] (success (while-statement-node condition body) s))))
   state))

(defn parse-for-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª for —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—Ü–∏–∫–ª for"
     (do-parse
       (expect-token-value :for)
       (expect-token-value :open-round)
       [init (optional parse-expression)]
       (expect-token-value :semicolon)
       [condition (optional parse-expression)]
       (expect-token-value :semicolon)
       [update (optional parse-expression)]
       (expect-token-value :close-round)
       [body parse-statement]
       (fn [s] (success (for-statement-node init condition update body) s))))
   state))

(defn parse-return-statement 
  "–ü–∞—Ä—Å–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä return —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–ø–µ—Ä–∞—Ç–æ—Ä return"
     (do-parse
       (expect-token-value :return)
       [expr (optional parse-expression)]
       (expect-token-value :semicolon)
       (fn [s] (success (return-statement-node expr) s))))
   state))

(defn parse-expression-statement 
  "–ü–∞—Ä—Å–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–ø–µ—Ä–∞—Ç–æ—Ä-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ"
     (do-parse
       [expr parse-expression]
       (expect-token-value :semicolon)
       (fn [s] (success (expression-statement-node expr) s))))
   state))

(defn parse-variable-declaration 
  "–ü–∞—Ä—Å–∏—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π"
     (do-parse
       [type-spec parse-type-specifier]
       [name (expect-token :identifier)]
       [init (optional (do-parse
                       (expect-token-value :equal)
                       [expr parse-expression]
                       (fn [s] (success expr s))))]
       (expect-token-value :semicolon)
       (fn [s] (success (variable-declaration-node type-spec 
                                                  (extract-identifier-name name) 
                                                  init) s))))
   state))
```

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –≤—Å–µ –µ—â–µ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç, –∏ —Å–æ–∑–¥–∞–¥–∏–º –ø—Ä–æ—Å—Ç—É—é —Ä–∞–±–æ—á—É—é –≤–µ—Ä—Å–∏—é:

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –ø—ã—Ç–∞–µ—Ç—Å—è –≤—ã–∑–≤–∞—Ç—å `nil` –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏—é. –î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç—É—é –∏ –Ω–∞–¥–µ–∂–Ω—É—é –≤–µ—Ä—Å–∏—é –º–∞–∫—Ä–æ—Å–∞:

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
(defmacro do-parse 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
   –°–∏–Ω—Ç–∞–∫—Å–∏—Å: (do-parse [var parser] parser2 final-result)
   –≥–¥–µ [var parser] —Å–≤—è–∑—ã–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç parser —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π var"
  [& forms]
  (let [state-sym (gensym "state")]
    (letfn [(build-chain [forms current-state]
              (if (empty? forms)
                `(success nil ~current-state)
                (let [form (first forms)
                      remaining (rest forms)]
                  (cond
                    ;; –°–≤—è–∑—ã–≤–∞–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π: [var parser]
                    (vector? form)
                    (let [[var parser] form
                          next-state (gensym "next-state")]
                      `(let [result# (~parser ~current-state)]
                         (if (:success? result#)
                           (let [~var (:value result#)
                                 ~next-state (:state result#)]
                             ~(build-chain remaining next-state))
                           result#)))
                    
                    ;; –ü–æ—Å–ª–µ–¥–Ω–µ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ - –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Ñ—É–Ω–∫—Ü–∏–µ–π, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–µ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                    (= 1 (count forms))
                    `(~form ~current-state)
                    
                    ;; –ü—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–π –ø–∞—Ä—Å–µ—Ä - –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                    :else
                    (let [next-state (gensym "next-state")]
                      `(let [result# (~form ~current-state)]
                         (if (:success? result#)
                           (let [~next-state (:state result#)]
                             ~(build-chain remaining next-state))
                           result#)))))))]
      `(fn [~state-sym]
         ~(build-chain forms state-sym)))))
```

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –≤—Å–µ –µ—â–µ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º –¥—Ä—É–≥–æ–π –ø–æ–¥—Ö–æ–¥ - —Å–æ–∑–¥–∞–¥–∏–º –ø—Ä–æ—Å—Ç—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏-–∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –≤–º–µ—Å—Ç–æ —Å–ª–æ–∂–Ω–æ–≥–æ –º–∞–∫—Ä–æ—Å–∞:

---

**User**

–∏—Å–ø—Ä–∞–≤—å 
(defn between 
(defn separated-by
—Ç–∞–º unresolwed symbols

---

**Cursor**

–í–∏–∂—É –ø—Ä–æ–±–ª–µ–º—É. –ú–∞–∫—Ä–æ—Å `do-parse` –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —Ñ—É–Ω–∫—Ü–∏–∏ `between` –∏ `separated-by`, –∏—Å–ø–æ–ª—å–∑—É—è –æ–±—ã—á–Ω—É—é –∫–æ–º–ø–æ–∑–∏—Ü–∏—é –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤–º–µ—Å—Ç–æ –ø—Ä–æ–±–ª–µ–º–Ω–æ–≥–æ –º–∞–∫—Ä–æ—Å–∞:

```clojure
(defn between 
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏
   –ü—Ä–∏–º–µ—Ä: (between (expect-token-value :open-round) 
                    (expect-token-value :close-round) 
                    parse-expression)"
  [open close parser]
  (fn [state]
    (let [open-result (open state)]
      (if (:success? open-result)
        (let [parser-result (parser (:state open-result))]
          (if (:success? parser-result)
            (let [close-result (close (:state parser-result))]
              (if (:success? close-result)
                (success (:value parser-result) (:state close-result))
                close-result))
            parser-result))
        open-result))))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º
   –ü—Ä–∏–º–µ—Ä: (separated-by (expect-token-value :comma) parse-expression) –¥–ª—è 'a, b, c'"
  [separator parser]
  (choice
    ;; –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state] (success [] state))
    ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state]
      (let [first-result (parser state)]
        (if (:success? first-result)
          (let [rest-result ((many (fn [state]
                                    (let [sep-result (separator state)]
                                      (if (:success? sep-result)
                                        (parser (:state sep-result))
                                        sep-result))))
                            (:state first-result))]
            (if (:success? rest-result)
              (success (cons (:value first-result) (:value rest-result))
                      (:state rest-result))
              rest-result))
          first-result))))
```

–ï—Å—Ç—å –ø—Ä–æ–±–ª–µ–º–∞ —Å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–æ–º. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —Å–∫–æ–±–∫–∏:

---

**User**

–Ω–µ—Ç. –º—ã –ø–æ–ª—É—á–∞–µ–º –æ–±—Ä–∞—Ç–Ω–æ callback hell –æ—Ç –∫–æ—Ç–æ—Ä–æ–≥–æ –∏–∑–±–∞–≤–ª—è–µ–º—Å—è

---

**Cursor**

–í—ã –ø—Ä–∞–≤—ã! –ú—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ "callback hell", –æ—Ç –∫–æ—Ç–æ—Ä–æ–≥–æ –ø—ã—Ç–∞–ª–∏—Å—å –∏–∑–±–∞–≤–∏—Ç—å—Å—è. –ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å `do-parse` –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º –º–∞–∫—Ä–æ—Å, —á—Ç–æ–±—ã –æ–Ω –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–ª:

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
(defmacro do-parse 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
   –ò—Å–ø–æ–ª—å–∑—É–µ—Ç >>= (bind) –¥–ª—è –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏"
  [& bindings-and-body]
  (let [state-sym (gensym "state")]
    (letfn [(expand-bindings [bindings body]
              (if (empty? bindings)
                `(~body ~state-sym)
                (let [binding (first bindings)
                      rest-bindings (rest bindings)]
                  (if (vector? binding)
                    (let [[var parser] binding]
                      `(let [result# (~parser ~state-sym)]
                         (if (:success? result#)
                           (let [~var (:value result#)
                                 ~state-sym (:state result#)]
                             ~(expand-bindings rest-bindings body))
                           result#)))
                    `(let [result# (~binding ~state-sym)]
                       (if (:success? result#)
                         (let [~state-sym (:state result#)]
                           ~(expand-bindings rest-bindings body))
                         result#))))))]
      (let [body (last bindings-and-body)
            bindings (butlast bindings-and-body)]
        `(fn [~state-sym]
           ~(expand-bindings bindings body))))))

(defn between 
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏"
  [open close parser]
  (do-parse
    open
    [result parser]
    close
    (fn [state] (success result state))))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º"
  [separator parser]
  (choice
    ;; –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (fn [state] (success [] state))
    ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (do-parse
      [first-item parser]
      [rest-items (many (do-parse
                          separator
                          [item parser]
                          (fn [state] (success item state))))]
      (fn [state] (success (cons first-item rest-items) state)))))
```

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –≤—Å–µ –µ—â–µ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–∏–º–≤–æ–ª `state-sym`. –î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –≤–µ—Ä—Å–∏—é:

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
(defmacro do-parse 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤"
  [& bindings-and-body]
  (let [initial-state (gensym "state")]
    (letfn [(expand-bindings [bindings body current-state]
              (if (empty? bindings)
                `(~body ~current-state)
                (let [binding (first bindings)
                      rest-bindings (rest bindings)]
                  (if (vector? binding)
                    (let [[var parser] binding
                          next-state (gensym "state")]
                      `(let [result# (~parser ~current-state)]
                         (if (:success? result#)
                           (let [~var (:value result#)
                                 ~next-state (:state result#)]
                             ~(expand-bindings rest-bindings body next-state))
                           result#)))
                    (let [next-state (gensym "state")]
                      `(let [result# (~binding ~current-state)]
                         (if (:success? result#)
                           (let [~next-state (:state result#)]
                             ~(expand-bindings rest-bindings body next-state))
                           result#)))))))]
      (let [body (last bindings-and-body)
            bindings (butlast bindings-and-body)]
        `(fn [~initial-state]
           ~(expand-bindings bindings body initial-state))))))
```

–î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç —Å –º–∞–∫—Ä–æ—Å–æ–º, —Å–æ–∑–¥–∞–≤ –ø—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç:

–î–∞–≤–∞–π—Ç–µ –ø–æ–ø—Ä–æ–±—É–µ–º –¥—Ä—É–≥–æ–π –ø–æ–¥—Ö–æ–¥ - —Å–æ–∑–¥–∞–¥–∏–º –ø—Ä–æ—Å—Ç—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏-–∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –±–µ–∑ –º–∞–∫—Ä–æ—Å–æ–≤:

```clojure
;; –ü—Ä–æ—Å—Ç—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏-–∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –≤–º–µ—Å—Ç–æ –º–∞–∫—Ä–æ—Å–∞
(defn then
  "–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è –¥–≤—É—Ö –ø–∞—Ä—Å–µ—Ä–æ–≤, –∏–≥–Ω–æ—Ä–∏—Ä—É—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–µ—Ä–≤–æ–≥–æ"
  [parser1 parser2]
  (fn [state]
    (let [result1 (parser1 state)]
      (if (:success? result1)
        (parser2 (:state result1))
        result1))))

(defn bind-parser
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è bind –¥–ª—è –ø–∞—Ä—Å–µ—Ä–æ–≤"
  [parser f]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        ((f (:value result)) (:state result))
        result))))

(defn return-value
  "–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –≤—Å–µ–≥–¥–∞ —É—Å–ø–µ—à–µ–Ω —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º"
  [value]
  (fn [state] (success value state)))

(defn between 
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏"
  [open close parser]
  (bind-parser open
    (fn [_] 
      (bind-parser parser
        (fn [result]
          (bind-parser close
            (fn [_] (return-value result))))))))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º"
  [separator parser]
  (choice
    ;; –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (return-value [])
    ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
    (bind-parser parser
      (fn [first-item]
        (bind-parser (many (bind-parser separator
                             (fn [_] parser)))
          (fn [rest-items]
            (return-value (cons first-item rest-items))))))))
```

–Ø —Å–ª—É—á–∞–π–Ω–æ —É–¥–∞–ª–∏–ª —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∫–æ–¥–∞. –î–∞–≤–∞–π—Ç–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏–º —É–¥–∞–ª–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:

```clojure
(defn return-value
  "–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –≤—Å–µ–≥–¥–∞ —É—Å–ø–µ—à–µ–Ω —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º"
  [value]
  (fn [state] (success value state)))

;; ============================================================================
;; –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò
;; ============================================================================

(defn extract-identifier-name
  "–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–º—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ –∏–∑ —Ç–æ–∫–µ–Ω–∞, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—è –∫–∞–∫ –æ–±—ã—á–Ω—ã–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã, —Ç–∞–∫ –∏ main-keyword"
  [token]
  (case (:type token)
    :identifier (:value token)
    :main-keyword "main"
    (str (:value token))))

;; ============================================================================
;; –ë–ê–ó–û–í–´–ï –ü–ê–†–°–ï–†–´
;; ============================================================================

(defn current-token 
  "–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–µ–∫—É—â–∏–π —Ç–æ–∫–µ–Ω –±–µ–∑ –ø—Ä–æ–¥–≤–∏–∂–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏"
  [state]
  (let [{:keys [tokens position]} state]
    (if (< position (count tokens))
      (success (nth tokens position) state)
      (failure "–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π –∫–æ–Ω–µ—Ü –≤—Ö–æ–¥–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞" state))))

(defn advance 
  "–ü—Ä–æ–¥–≤–∏–≥–∞–µ—Ç –ø–æ–∑–∏—Ü–∏—é –≤ –ø–æ—Ç–æ–∫–µ —Ç–æ–∫–µ–Ω–æ–≤ –Ω–∞ –æ–¥–Ω—É –ø–æ–∑–∏—Ü–∏—é"
  [state]
  (let [{:keys [tokens position]} state
        new-position (inc position)]
    (if (<= new-position (count tokens))
      (success nil (->ParseState tokens new-position))
      (failure "–ü–æ–ø—ã—Ç–∫–∞ –≤—ã–π—Ç–∏ –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã –ø–æ—Ç–æ–∫–∞ —Ç–æ–∫–µ–Ω–æ–≤" state))))

(defn expect-token 
  "–ü–∞—Ä—Å–µ—Ä, –æ–∂–∏–¥–∞—é—â–∏–π –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø —Ç–æ–∫–µ–Ω–∞"
  [expected-type]
  (fn [state]
    (let [token-result (current-token state)]
      (if (:success? token-result)
        (let [token (:value token-result)]
          (if (or (= (:type token) expected-type)
                  (and (= expected-type :number) (= (:type token) :number))
                  (and (= expected-type :identifier) (= (:type token) :identifier))
                  (and (= expected-type :identifier) (= (:type token) :main-keyword))
                  (and (= expected-type :void) (and (= (:type token) :type-keyword) (= (:base-type token) :void)))
                  (and (= expected-type :int) (and (= (:type token) :type-keyword) (= (:base-type token) :int)))
                  (and (= expected-type :char) (and (= (:type token) :type-keyword) (= (:base-type token) :char)))
                  (and (= expected-type :signed) (and (= (:type token) :type-keyword) (= (:signedness token) :signed)))
                  (and (= expected-type :unsigned) (and (= (:type token) :type-keyword) (= (:signedness token) :unsigned))))
            (let [advance-result (advance state)]
              (if (:success? advance-result)
                (success token (:state advance-result))
                advance-result))
            (failure (str "–û–∂–∏–¥–∞–ª—Å—è —Ç–æ–∫–µ–Ω —Ç–∏–ø–∞ " expected-type 
                         ", –ø–æ–ª—É—á–µ–Ω " (:type token)) state)))
        token-result))))

(defn expect-token-value 
  "–ü–∞—Ä—Å–µ—Ä, –æ–∂–∏–¥–∞—é—â–∏–π —Ç–æ–∫–µ–Ω —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º"
  [expected-value]
  (fn [state]
    (let [token-result (current-token state)]
      (if (:success? token-result)
        (let [token (:value token-result)]
          (if (or (= (:value token) expected-value)
                  (and (= expected-value :open-round) (and (= (:type token) :bracket) (= (:value token) :open-round)))
                  (and (= expected-value :close-round) (and (= (:type token) :bracket) (= (:value token) :close-round)))
                  (and (= expected-value :open-curly) (and (= (:type token) :bracket) (= (:value token) :open-curly)))
                  (and (= expected-value :close-curly) (and (= (:type token) :bracket) (= (:value token) :close-curly)))
                  (and (= expected-value :open-square) (and (= (:type token) :bracket) (= (:value token) :open-square)))
                  (and (= expected-value :close-square) (and (= (:type token) :bracket) (= (:value token) :close-square)))
                  (and (= expected-value :semicolon) (and (= (:type token) :separator) (= (:value token) :semicolon)))
                  (and (= expected-value :comma) (and (= (:type token) :separator) (= (:value token) :comma)))
                  (and (= expected-value :plus) (and (= (:type token) :math-operator) (= (:value token) :plus)))
                  (and (= expected-value :minus) (and (= (:type token) :math-operator) (= (:value token) :minus)))
                  (and (= expected-value :multiply) (and (= (:type token) :math-operator) (= (:value token) :multiply)))
                  (and (= expected-value :divide) (and (= (:type token) :math-operator) (= (:value token) :divide)))
                  (and (= expected-value :modulo) (and (= (:type token) :math-operator) (= (:value token) :modulo)))
                  (and (= expected-value :increment) (and (= (:type token) :math-operator) (= (:value token) :increment)))
                  (and (= expected-value :decrement) (and (= (:type token) :math-operator) (= (:value token) :decrement)))
                  (and (= expected-value :equal) (and (= (:type token) :assignment-operator) (= (:value token) :equal)))
                  (and (= expected-value :plus-equal) (and (= (:type token) :assignment-operator) (= (:value token) :plus-equal)))
                  (and (= expected-value :minus-equal) (and (= (:type token) :assignment-operator) (= (:value token) :minus-equal)))
                  (and (= expected-value :and-equal) (and (= (:type token) :assignment-operator) (= (:value token) :and-equal)))
                  (and (= expected-value :or-equal) (and (= (:type token) :assignment-operator) (= (:value token) :or-equal)))
                  (and (= expected-value :xor-equal) (and (= (:type token) :assignment-operator) (= (:value token) :xor-equal)))
                  (and (= expected-value :shift-left-equal) (and (= (:type token) :assignment-operator) (= (:value token) :shift-left-equal)))
                  (and (= expected-value :shift-right-equal) (and (= (:type token) :assignment-operator) (= (:value token) :shift-right-equal)))
                  (and (= expected-value :shift-left) (and (= (:type token) :bitwise-operator) (= (:value token) :shift-left)))
                  (and (= expected-value :shift-right) (and (= (:type token) :bitwise-operator) (= (:value token) :shift-right)))
                  (and (= expected-value :less) (and (= (:type token) :comparison-operator) (= (:value token) :less)))
                  (and (= expected-value :greater) (and (= (:type token) :comparison-operator) (= (:value token) :greater)))
                  (and (= expected-value :less-equal) (and (= (:type token) :comparison-operator) (= (:value token) :less-equal)))
                  (and (= expected-value :greater-equal) (and (= (:type token) :comparison-operator) (= (:value token) :greater-equal)))
                  (and (= expected-value :not-equal) (and (= (:type token) :comparison-operator) (= (:value token) :not-equal)))
                  (and (= expected-value :and) (and (= (:type token) :logical-operator) (= (:value token) :and)))
                  (and (= expected-value :or) (and (= (:type token) :logical-operator) (= (:value token) :or)))
                  (and (= expected-value :not) (and (= (:type token) :logical-operator) (= (:value token) :not)))
                  (and (= expected-value :if) (and (= (:type token) :control-keyword) (= (:value token) :if)))
                  (and (= expected-value :else) (and (= (:type token) :control-keyword) (= (:value token) :else)))
                  (and (= expected-value :while) (and (= (:type token) :control-keyword) (= (:value token) :while)))
                  (and (= expected-value :for) (and (= (:type token) :control-keyword) (= (:value token) :for)))
                  (and (= expected-value :return) (and (= (:type token) :control-keyword) (= (:value token) :return)))
                  (and (= expected-value :void) (and (= (:type token) :type-keyword) (= (:base-type token) :void)))
                  (and (= expected-value :int) (and (= (:type token) :type-keyword) (= (:base-type token) :int)))
                  (and (= expected-value :char) (and (= (:type token) :type-keyword) (= (:base-type token) :char)))
                  (and (= expected-value :signed) (and (= (:type token) :type-keyword) (= (:signedness token) :signed)))
                  (and (= expected-value :unsigned) (and (= (:type token) :type-keyword) (= (:signedness token) :unsigned))))
            (let [advance-result (advance state)]
              (if (:success? advance-result)
                (success token (:state advance-result))
                advance-result))
            (failure (str "–û–∂–∏–¥–∞–ª—Å—è —Ç–æ–∫–µ–Ω —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º " expected-value 
                         ", –ø–æ–ª—É—á–µ–Ω " (:value token)) state)))
        token-result))))

(defn choice 
  "–ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä –≤—ã–±–æ—Ä–∞ - –ø—Ä–æ–±—É–µ—Ç –ø–∞—Ä—Å–µ—Ä—ã –ø–æ –ø–æ—Ä—è–¥–∫—É"
  [& parsers]
  (fn [state]
    (loop [remaining-parsers parsers]
      (if (empty? remaining-parsers)
        (failure "–ù–∏ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –Ω–µ –ø–æ–¥–æ—à–µ–ª" state)
        (let [result ((first remaining-parsers) state)]
          (if (:success? result)
            result
            (recur (rest remaining-parsers))))))))

(defn many 
  "–ü–∞—Ä—Å–µ—Ä, –ø—Ä–∏–º–µ–Ω—è—é—â–∏–π –¥—Ä—É–≥–æ–π –ø–∞—Ä—Å–µ—Ä –Ω–æ–ª—å –∏–ª–∏ –±–æ–ª–µ–µ —Ä–∞–∑"
  [parser]
  (fn [state]
    (loop [current-state state
           results []]
      (let [result (parser current-state)]
        (if (:success? result)
          (recur (:state result) (conj results (:value result)))
          (success results current-state))))))

(defn many1 
  "–ü–∞—Ä—Å–µ—Ä, –ø—Ä–∏–º–µ–Ω—è—é—â–∏–π –¥—Ä—É–≥–æ–π –ø–∞—Ä—Å–µ—Ä –æ–¥–∏–Ω –∏–ª–∏ –±–æ–ª–µ–µ —Ä–∞–∑"
  [parser]
  (fn [state]
    (let [first-result (parser state)]
      (if (:success? first-result)
        (let [rest-result ((many parser) (:state first-result))]
          (if (:success? rest-result)
            (success (cons (:value first-result) (:value rest-result))
                    (:state rest-result))
            rest-result))
        first-result))))

(defn optional 
  "–ü–∞—Ä—Å–µ—Ä, –¥–µ–ª–∞—é—â–∏–π –¥—Ä—É–≥–æ–π –ø–∞—Ä—Å–µ—Ä –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–º"
  [parser]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        result
        (success nil state)))))
```

–Ø –¥–æ–±–∞–≤–∏–ª —Ñ—É–Ω–∫—Ü–∏–∏ –≤ –∫–æ–Ω–µ—Ü —Ñ–∞–π–ª–∞, –Ω–æ –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ. –î–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–º–µ—Å—Ç–∏–º –∏—Ö –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –º–µ—Å—Ç–æ –∏ –∏—Å–ø—Ä–∞–≤–∏–º —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—Å–µ –µ—â–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç `do-parse`:

```clojure
(defn parse-if-statement 
  "–ü–∞—Ä—Å–∏—Ç —É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—É—Å–ª–æ–≤–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä if"
     (bind-parser (expect-token-value :if)
       (fn [_]
         (bind-parser (expect-token-value :open-round)
           (fn [_]
             (bind-parser parse-expression
               (fn [condition]
                 (bind-parser (expect-token-value :close-round)
                   (fn [_]
                     (bind-parser parse-statement
                       (fn [then-branch]
                         (bind-parser (optional (bind-parser (expect-token-value :else)
                                                  (fn [_] parse-statement)))
                           (fn [else-branch]
                             (return-value (if-statement-node condition then-branch else-branch)))))))))))))))
   state))

(defn parse-while-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª while —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—Ü–∏–∫–ª while"
     (bind-parser (expect-token-value :while)
       (fn [_]
         (bind-parser (expect-token-value :open-round)
           (fn [_]
             (bind-parser parse-expression
               (fn [condition]
                 (bind-parser (expect-token-value :close-round)
                   (fn [_]
                     (bind-parser parse-statement
                       (fn [body]
                         (return-value (while-statement-node condition body)))))))))))))
   state))

(defn parse-for-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª for —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "—Ü–∏–∫–ª for"
     (bind-parser (expect-token-value :for)
       (fn [_]
         (bind-parser (expect-token-value :open-round)
           (fn [_]
             (bind-parser (optional parse-expression)
               (fn [init]
                 (bind-parser (expect-token-value :semicolon)
                   (fn [_]
                     (bind-parser (optional parse-expression)
                       (fn [condition]
                         (bind-parser (expect-token-value :semicolon)
                           (fn [_]
                             (bind-parser (optional parse-expression)
                               (fn [update]
                                 (bind-parser (expect-token-value :close-round)
                                   (fn [_]
                                     (bind-parser parse-statement
                                       (fn [body]
                                         (return-value (for-statement-node init condition update body)))))))))))))))))))))
   state))

(defn parse-return-statement 
  "–ü–∞—Ä—Å–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä return —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–ø–µ—Ä–∞—Ç–æ—Ä return"
     (bind-parser (expect-token-value :return)
       (fn [_]
         (bind-parser (optional parse-expression)
           (fn [expr]
             (bind-parser (expect-token-value :semicolon)
               (fn [_]
                 (return-value (return-statement-node expr)))))))))
   state))

(defn parse-expression-statement 
  "–ü–∞—Ä—Å–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–ø–µ—Ä–∞—Ç–æ—Ä-–≤—ã—Ä–∞–∂–µ–Ω–∏–µ"
     (bind-parser parse-expression
       (fn [expr]
         (bind-parser (expect-token-value :semicolon)
           (fn [_]
             (return-value (expression-statement-node expr)))))))
   state))

(defn parse-variable-declaration 
  "–ü–∞—Ä—Å–∏—Ç –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–æ–Ω–∞–¥–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  [state]
  ((with-error-context "–æ–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π"
     (bind-parser parse-type-specifier
       (fn [type-spec]
         (bind-parser (expect-token :identifier)
           (fn [name]
             (bind-parser (optional (bind-parser (expect-token-value :equal)
                                      (fn [_] parse-expression)))
               (fn [init]
                 (bind-parser (expect-token-value :semicolon)
                   (fn [_]
                     (return-value (variable-declaration-node type-spec 
                                                            (extract-identifier-name name) 
                                                            init)))))))))))
   state))
```

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ–±–∞–≤–∏–ª–∏—Å—å –≤ –∫–æ–Ω–µ—Ü —Ñ–∞–π–ª–∞, –Ω–æ –æ–Ω–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –Ω–∞—á–∞–ª–µ. –î–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–º–µ—Å—Ç–∏–º –∏—Ö –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –º–µ—Å—Ç–æ:

