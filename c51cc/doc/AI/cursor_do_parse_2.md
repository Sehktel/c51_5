# –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –º–∞–∫—Ä–æ—Å–∞ do-parse –∏ –ø–∞—Ä—Å–µ—Ä–æ–≤
_Exported on 5/27/2025 at 20:38:27 GMT+3 from Cursor (0.50.5)_

---

**User**

–ø—Ä–æ–¥–æ–ª–∂–∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ —Å –º–∞–∫—Ä–æ—Å–æ–º do-parse 
–í –ø—Ä–æ—à–ª–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏ –±—ã–ª —Ç–∞–∫–æ–π –ø–ª–∞–Ω:

–ò—Å–ø—Ä–∞–≤–∏—Ç—å do-parse –º–∞–∫—Ä–æ—Å - —Å–¥–µ–ª–∞—Ç—å –µ–≥–æ —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º —Å —Ç–µ–∫—É—â–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏
–°–æ–∑–¥–∞—Ç—å –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞
–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å —Å–∞–º—ã–µ —Å–ª–æ–∂–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã
–î–æ–±–∞–≤–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫

–ü—Ä–∏–¥–µ—Ä–∂–∏–≤–∞–π—Å—è –µ–≥–æ


---

**Cursor**

–Ø –≤–∏–∂—É –ø—Ä–æ–±–ª–µ–º—É —Å –º–∞–∫—Ä–æ—Å–æ–º `do-parse` - –æ–Ω –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Å —Ç–µ–∫—É—â–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º –µ–≥–æ –∏ –ø—Ä–æ–¥–æ–ª–∂–∏–º —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ —Å–æ–≥–ª–∞—Å–Ω–æ –ø–ª–∞–Ω—É.

–¢–µ–ø–µ—Ä—å —è –ø–æ–Ω–∏–º–∞—é –ø—Ä–æ–±–ª–µ–º—É. –ú–∞–∫—Ä–æ—Å `do-parse` —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ - –æ–Ω –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–∏–º–≤–æ–ª `_` –¥–ª—è –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏ –Ω–µ —Å–æ–∑–¥–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–∞—Ä—Å–µ—Ä–∞. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ –∏ —Å–æ–∑–¥–∞–¥–∏–º –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤.

---

**User**

–ø–æ–º–Ω–∏ –ø—Ä–æ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫—É—é —á–∏—Å—Ç–æ—Ç—É –º–∞–∫—Ä–æ—Å–∞ do-parse!
–°–æ–±–ª—é–¥–∞–π –µ–µ

---

**Cursor**

–ü–æ–Ω—è–ª! –ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å `do-parse` –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Å–∏–º–≤–æ–ª `_` –ø—Ä–∞–≤–∏–ª—å–Ω–æ –∏ –Ω–µ —Å–æ–∑–¥–∞–µ—Ç –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏ —á–∏—Å—Ç—ã–π –∫–æ–¥. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ, —Å–æ—Ö—Ä–∞–Ω–∏–≤ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫—É—é —á–∏—Å—Ç–æ—Ç—É.

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ (–ì–ò–ì–ò–ï–ù–ò–ß–ï–°–ö–ê–Ø –í–ï–†–°–ò–Ø)
(defmacro do-parse 
  "–ì–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤ —Å—Ç–∏–ª–µ do-notation
   –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø–æ–ª–Ω—É—é –∑–∞—â–∏—Ç—É –æ—Ç –∑–∞—Ö–≤–∞—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—é –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
   –°–∏–º–≤–æ–ª _ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–∞—Ä—Å–∏–Ω–≥–∞"
  [& bindings]
  ;; –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö - –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º
  (when (even? (count bindings))
    (throw (ex-info "do-parse —Ç—Ä–µ–±—É–µ—Ç –Ω–µ—á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤: –ø–∞—Ä—ã binding-expression + —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ" 
                   {:bindings bindings
                    :count (count bindings)})))
  
  ;; –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ –ø–∞—Ä—ã –∏ —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
  (let [all-args (vec bindings)
        final-expr (last all-args)
        binding-pairs (partition 2 (butlast all-args))
        forbidden-names #{'state 'state# 'result 'result# 'parser-state 'parse-result}]
    
    ;; –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã–µ –∏–º–µ–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö (–∫—Ä–æ–º–µ _)
    (doseq [[binding _] binding-pairs]
      (when (and (symbol? binding) 
                 (not= binding '_)
                 (forbidden-names binding))
        (throw (ex-info "–ó–∞–ø—Ä–µ—â–µ–Ω–Ω–æ–µ –∏–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤ do-parse - –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å –∑–∞—Ö–≤–∞—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö" 
                       {:forbidden-binding binding
                        :forbidden-names forbidden-names}))))
    
    ;; –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–æ–≥–æ –∫–æ–¥–∞
    (letfn [(build-parser-chain [pairs final-expr]
              (if (empty? pairs)
                ;; –§–∏–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ - –æ–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ –ø–∞—Ä—Å–µ—Ä –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
                (if (and (list? final-expr) (= (first final-expr) 'return-parser))
                  ;; –£–∂–µ –æ–±–µ—Ä–Ω—É—Ç–æ –≤ return-parser
                  final-expr
                  ;; –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ return-parser
                  `(return-parser ~final-expr))
                (let [[binding expr] (first pairs)
                      remaining-pairs (rest pairs)
                      ;; –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è
                      state-sym (gensym "parser-state")
                      result-sym (gensym "parse-result")]
                  (if (and (symbol? binding) (not= binding '_))
                    ;; –°–≤—è–∑—ã–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           (let [~binding (:value ~result-sym)
                                 next-state# (:state ~result-sym)]
                             ((~(build-parser-chain remaining-pairs final-expr)) next-state#))
                           ~result-sym)))
                    ;; –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (binding —ç—Ç–æ _ –∏–ª–∏ –Ω–µ —Å–∏–º–≤–æ–ª)
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           ((~(build-parser-chain remaining-pairs final-expr)) (:state ~result-sym))
                           ~result-sym)))))))]
      
      (build-parser-chain binding-pairs final-expr))))
```

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –±–∏–±–ª–∏–æ—Ç–µ–∫—É –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –∏ –∏—Å–ø—Ä–∞–≤–∏–º –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã:

```clojure
;; ============================================================================
;; –ë–ò–ë–õ–ò–û–¢–ï–ö–ê –ö–û–ú–ë–ò–ù–ê–¢–û–†–û–í –í–´–°–®–ï–ì–û –ü–û–†–Ø–î–ö–ê
;; ============================================================================

(defn >>= 
  "–ú–æ–Ω–∞–¥–∏—á–µ—Å–∫–∞—è —Å–≤—è–∑–∫–∞ (bind) –≤ –∏–Ω—Ñ–∏–∫—Å–Ω–æ–π –Ω–æ—Ç–∞—Ü–∏–∏ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞"
  [parser-result parser-fn]
  (bind parser-result parser-fn))

(defn >> 
  "–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–æ–≤ —Å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º –ø–µ—Ä–≤–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞"
  [parser1 parser2]
  (fn [state]
    (let [result1 (parser1 state)]
      (if (:success? result1)
        (parser2 (:state result1))
        result1))))

(defn <<
  "–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è –ø–∞—Ä—Å–µ—Ä–æ–≤ —Å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º –≤—Ç–æ—Ä–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞"
  [parser1 parser2]
  (fn [state]
    (let [result1 (parser1 state)]
      (if (:success? result1)
        (let [result2 (parser2 (:state result1))]
          (if (:success? result2)
            (success (:value result1) (:state result2))
            result2))
        result1))))

(defn between
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏"
  [open-parser content-parser close-parser]
  (fn [state]
    ((do-parse
       _ open-parser
       content content-parser
       _ close-parser
       (return-parser content)) state)))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º"
  [element-parser separator-parser]
  (fn [state]
    ((choice
       ;; –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
       (return-parser [])
       ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
       (do-parse
         first-elem element-parser
         rest-elems (many (do-parse
                            _ separator-parser
                            elem element-parser
                            (return-parser elem)))
         (return-parser (cons first-elem rest-elems)))) state)))

(defn sequence-parsers 
  "–ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –ø–∞—Ä—Å–µ—Ä–æ–≤, –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤–µ–∫—Ç–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"
  [& parsers]
  (fn [state]
    (loop [remaining-parsers parsers
           current-state state
           results []]
      (if (empty? remaining-parsers)
        (success results current-state)
        (let [parser (first remaining-parsers)
              result (parser current-state)]
          (if (:success? result)
            (recur (rest remaining-parsers)
                   (:state result)
                   (conj results (:value result)))
            result))))))

(defn ignore-result 
  "–ü—Ä–∏–º–µ–Ω—è–µ—Ç –ø–∞—Ä—Å–µ—Ä, –Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç"
  [parser]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        (success nil (:state result))
        result))))

(defn transform
  "–ü—Ä–∏–º–µ–Ω—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É –ø–∞—Ä—Å–µ—Ä–∞"
  [parser transform-fn]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        (success (transform-fn (:value result)) (:state result))
        result))))

(defn with-error-context
  "–î–æ–±–∞–≤–ª—è–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç –∫ –æ—à–∏–±–∫–µ –ø–∞—Ä—Å–µ—Ä–∞"
  [parser context-msg]
  (fn [state]
    (let [result (parser state)]
      (if (:success? result)
        result
        (failure (str context-msg ": " (:error result)) (:state result))))))

;; –°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –¥–ª—è C-—Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞
(defn parenthesized
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è –≤—ã—Ä–∞–∂–µ–Ω–∏–π –≤ –∫—Ä—É–≥–ª—ã—Ö —Å–∫–æ–±–∫–∞—Ö"
  [content-parser]
  (between (expect-token-value :open-round)
           content-parser
           (expect-token-value :close-round)))

(defn braced
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è –±–ª–æ–∫–æ–≤ –≤ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö"
  [content-parser]
  (between (expect-token-value :open-curly)
           content-parser
           (expect-token-value :close-curly)))

(defn bracketed
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è –≤—ã—Ä–∞–∂–µ–Ω–∏–π –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö"
  [content-parser]
  (between (expect-token-value :open-square)
           content-parser
           (expect-token-value :close-square)))

(defn comma-separated
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö –∑–∞–ø—è—Ç—ã–º–∏"
  [element-parser]
  (separated-by element-parser (expect-token-value :comma)))

(defn semicolon-terminated
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è –≤—ã—Ä–∞–∂–µ–Ω–∏–π, –∑–∞–≤–µ—Ä—à–∞—é—â–∏—Ö—Å—è —Ç–æ—á–∫–æ–π —Å –∑–∞–ø—è—Ç–æ–π"
  [content-parser]
  (<< content-parser (expect-token-value :semicolon)))

;; ============================================================================
;; –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò
;; ============================================================================
```

–í–∏–∂—É –ø—Ä–æ–±–ª–µ–º—É - –≤ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞—Ö `between` –∏ `separated-by` –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–µ –≤–∏–¥–Ω—ã –∏–∑-–∑–∞ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–µ–π –º–∞–∫—Ä–æ—Å–∞. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ:

```clojure
(defn between
  "–ü–∞—Ä—Å–µ—Ä, –∫–æ—Ç–æ—Ä—ã–π –ø–∞—Ä—Å–∏—Ç —á—Ç–æ-—Ç–æ –º–µ–∂–¥—É –¥–≤—É–º—è –¥—Ä—É–≥–∏–º–∏ –ø–∞—Ä—Å–µ—Ä–∞–º–∏"
  [open-parser content-parser close-parser]
  (fn [state]
    (let [open-result (open-parser state)]
      (if (:success? open-result)
        (let [content-result (content-parser (:state open-result))]
          (if (:success? content-result)
            (let [close-result (close-parser (:state content-result))]
              (if (:success? close-result)
                (success (:value content-result) (:state close-result))
                close-result))
            content-result))
        open-result))))

(defn separated-by
  "–ü–∞—Ä—Å–µ—Ä –¥–ª—è —Å–ø–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã—Ö —Å–µ–ø–∞—Ä–∞—Ç–æ—Ä–æ–º"
  [element-parser separator-parser]
  (fn [state]
    ((choice
       ;; –ü—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
       (return-parser [])
       ;; –ù–µ–ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫
       (fn [state]
         (let [first-result (element-parser state)]
           (if (:success? first-result)
             (let [rest-result ((many (fn [state]
                                       (let [sep-result (separator-parser state)]
                                         (if (:success? sep-result)
                                           (element-parser (:state sep-result))
                                           sep-result))))
                               (:state first-result))]
               (if (:success? rest-result)
                 (success (cons (:value first-result) (:value rest-result))
                         (:state rest-result))
                 rest-result))
             first-result)))) state)))
```

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–º –ø—Ä–æ–±–ª–µ–º–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã, –∏—Å–ø–æ–ª—å–∑—É—è –Ω–æ–≤—ã–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã:

```clojure
(defn parse-while-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª while"
  [state]
  ((with-error-context
     (do-parse 
       _ (expect-token-value :while)
       _ (expect-token-value :open-round)
       condition parse-expression
       _ (expect-token-value :close-round)
       body parse-statement
       (return-parser (while-statement-node condition body)))
     "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥–µ —Ü–∏–∫–ª–∞ while") state))
```

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ `with-error-context` –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –ø–æ—Å–ª–µ `parse-while-statement`. –î–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–º–µ—Å—Ç–∏–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–π –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ –∏ –∏—Å–ø—Ä–∞–≤–∏–º –º–∞–∫—Ä–æ—Å:

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ `with-error-context` –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –ø–æ—Å–ª–µ `parse-while-statement`. –î–∞–≤–∞–π—Ç–µ –≤—Ä–µ–º–µ–Ω–Ω–æ –≤–µ—Ä–Ω–µ–º `parse-while-statement` –∫ –ø—Ä–æ—Å—Ç–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∏ –∏—Å–ø—Ä–∞–≤–∏–º `parse-return-statement`:

```clojure
(defn parse-while-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª while"
  [state]
  (let [while-result ((expect-token-value :while) state)]
    (if (:success? while-result)
      (let [open-result ((expect-token-value :open-round) (:state while-result))]
        (if (:success? open-result)
          (let [condition-result (parse-expression (:state open-result))]
            (if (:success? condition-result)
              (let [close-result ((expect-token-value :close-round) (:state condition-result))]
                (if (:success? close-result)
                  (let [body-result (parse-statement (:state close-result))]
                    (if (:success? body-result)
                      (success (while-statement-node (:value condition-result) (:value body-result))
                              (:state body-result))
                      body-result))
                  close-result))
              condition-result))
          open-result))
      while-result)))

(defn parse-for-statement 
  "–ü–∞—Ä—Å–∏—Ç —Ü–∏–∫–ª for"
  [state]
  (let [for-result ((expect-token-value :for) state)]
    (if (:success? for-result)
      (let [open-result ((expect-token-value :open-round) (:state for-result))]
        (if (:success? open-result)
          (let [init-result ((optional parse-expression) (:state open-result))]
            (if (:success? init-result)
              (let [semi1-result ((expect-token-value :semicolon) (:state init-result))]
                (if (:success? semi1-result)
                  (let [condition-result ((optional parse-expression) (:state semi1-result))]
                    (if (:success? condition-result)
                      (let [semi2-result ((expect-token-value :semicolon) (:state condition-result))]
                        (if (:success? semi2-result)
                          (let [update-result ((optional parse-expression) (:state semi2-result))]
                            (if (:success? update-result)
                              (let [close-result ((expect-token-value :close-round) (:state update-result))]
                                (if (:success? close-result)
                                  (let [body-result (parse-statement (:state close-result))]
                                    (if (:success? body-result)
                                      (success (for-statement-node (:value init-result) 
                                                                  (:value condition-result) 
                                                                  (:value update-result) 
                                                                  (:value body-result))
                                              (:state body-result))
                                      body-result))
                                  close-result))
                              update-result))
                          semi2-result))
                      condition-result))
                  semi1-result))
              init-result))
          open-result))
      for-result)))

(defn parse-return-statement 
  "–ü–∞—Ä—Å–∏—Ç –æ–ø–µ—Ä–∞—Ç–æ—Ä return"
  [state]
  (let [return-result ((expect-token-value :return) state)]
    (if (:success? return-result)
      (let [expr-result ((optional parse-expression) (:state return-result))]
        (if (:success? expr-result)
          (let [semi-result ((expect-token-value :semicolon) (:state expr-result))]
            (if (:success? semi-result)
              (success (return-statement-node (:value expr-result)) (:state semi-result))
              semi-result))
          expr-result))
      return-result)))
```

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –æ—à–∏–±–∫–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã, –∏ —Å–æ–∑–¥–∞–¥–∏–º —Ç–µ—Å—Ç–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ä–∞–±–æ—Ç—ã –º–∞–∫—Ä–æ—Å–∞:

–û—Ç–ª–∏—á–Ω–æ! –û—à–∏–±–∫–∏ –ª–∏–Ω—Ç–µ—Ä–∞ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã. –¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º —Ç–µ—Å—Ç–æ–≤—ã–π —Ñ–∞–π–ª –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–∞–±–æ—Ç—ã —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ –º–∞–∫—Ä–æ—Å–∞ `do-parse`:

```clojure
(ns test-do-parse
  "–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ –º–∞–∫—Ä–æ—Å–∞ do-parse –∏ –Ω–æ–≤—ã—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  (:require [c51cc.parser :as parser]
            [c51cc.lexer :as lexer]))

;; ============================================================================
;; –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –†–ê–ë–û–¢–´ –ú–ê–ö–†–û–°–ê do-parse
;; ============================================================================

(defn test-simple-parser
  "–ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç –ø–∞—Ä—Å–µ—Ä–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º do-parse"
  []
  (let [tokens (lexer/tokenize "int x = 42;")
        state (parser/parse-state tokens)]
    
    ;; –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–∞—Ä—Å–µ—Ä –æ–±—ä—è–≤–ª–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º do-parse
    (let [var-parser (parser/do-parse
                       type-spec parser/parse-type-specifier
                       name (parser/expect-token :identifier)
                       _ (parser/expect-token-value :equal)
                       init parser/parse-expression
                       _ (parser/expect-token-value :semicolon)
                       (parser/return-parser 
                         (parser/variable-declaration-node 
                           type-spec 
                           (parser/extract-identifier-name name) 
                           init)))]
      
      (println "=== –¢–µ—Å—Ç –ø—Ä–æ—Å—Ç–æ–≥–æ –ø–∞—Ä—Å–µ—Ä–∞ —Å do-parse ===")
      (println "–¢–æ–∫–µ–Ω—ã:" tokens)
      (let [result (var-parser state)]
        (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
        (when (:success? result)
          (println "AST:" (:value result)))))))

(defn test-error-handling
  "–¢–µ—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º"
  []
  (let [tokens (lexer/tokenize "int x")  ; –ù–µ–ø–æ–ª–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
        state (parser/parse-state tokens)]
    
    ;; –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–∞—Ä—Å–µ—Ä —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –æ—à–∏–±–æ–∫
    (let [var-parser (parser/with-error-context
                       (parser/do-parse
                         type-spec parser/parse-type-specifier
                         name (parser/expect-token :identifier)
                         _ (parser/expect-token-value :semicolon)
                         (parser/return-parser 
                           (parser/variable-declaration-node 
                             type-spec 
                             (parser/extract-identifier-name name) 
                             nil)))
                       "–û–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π")]
      
      (println "\n=== –¢–µ—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ ===")
      (println "–¢–æ–∫–µ–Ω—ã:" tokens)
      (let [result (var-parser state)]
        (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)))))

(defn test-combinators
  "–¢–µ—Å—Ç –Ω–æ–≤—ã—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤"
  []
  (let [tokens (lexer/tokenize "(42)")
        state (parser/parse-state tokens)]
    
    ;; –¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä parenthesized
    (let [paren-parser (parser/parenthesized parser/parse-expression)]
      
      (println "\n=== –¢–µ—Å—Ç –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞ parenthesized ===")
      (println "–¢–æ–∫–µ–Ω—ã:" tokens)
      (let [result (paren-parser state)]
        (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
        (when (:success? result)
          (println "AST:" (:value result))))))

  (let [tokens (lexer/tokenize "1, 2, 3")
        state (parser/parse-state tokens)]
    
    ;; –¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä comma-separated
    (let [list-parser (parser/comma-separated parser/parse-expression)]
      
      (println "\n=== –¢–µ—Å—Ç –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞ comma-separated ===")
      (println "–¢–æ–∫–µ–Ω—ã:" tokens)
      (let [result (list-parser state)]
        (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
        (when (:success? result)
          (println "–°–ø–∏—Å–æ–∫ –≤—ã—Ä–∞–∂–µ–Ω–∏–π:" (:value result)))))))

(defn test-transform-combinator
  "–¢–µ—Å—Ç –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞ transform"
  []
  (let [tokens (lexer/tokenize "42")
        state (parser/parse-state tokens)]
    
    ;; –¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä transform –¥–ª—è —É–¥–≤–æ–µ–Ω–∏—è —á–∏—Å–ª–∞
    (let [double-parser (parser/transform 
                          parser/parse-expression
                          (fn [expr]
                            (if (= (:ast-type expr) :literal)
                              (assoc expr :value (* 2 (:value expr)))
                              expr)))]
      
      (println "\n=== –¢–µ—Å—Ç –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞ transform ===")
      (println "–¢–æ–∫–µ–Ω—ã:" tokens)
      (let [result (double-parser state)]
        (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
        (when (:success? result)
          (println "–¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ:" (:value result)))))))

(defn test-hygiene
  "–¢–µ—Å—Ç –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–æ–π —á–∏—Å—Ç–æ—Ç—ã –º–∞–∫—Ä–æ—Å–∞ do-parse"
  []
  (println "\n=== –¢–µ—Å—Ç –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–æ–π —á–∏—Å—Ç–æ—Ç—ã ===")
  
  ;; –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–µ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞—é—Ç—Å—è
  (let [state "–≤–Ω–µ—à–Ω—è—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è state"
        result "–≤–Ω–µ—à–Ω—è—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è result"
        tokens (lexer/tokenize "int x;")
        parse-state (parser/parse-state tokens)]
    
    (println "–í–Ω–µ—à–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ:")
    (println "  state:" state)
    (println "  result:" result)
    
    ;; –ò—Å–ø–æ–ª—å–∑—É–µ–º do-parse —Å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥–ª–∏ –±—ã –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤–∞—Ç—å
    (let [parser-fn (parser/do-parse
                      type-spec parser/parse-type-specifier
                      name (parser/expect-token :identifier)
                      _ (parser/expect-token-value :semicolon)
                      (parser/return-parser 
                        {:type type-spec 
                         :name (parser/extract-identifier-name name)}))]
      
      (let [parse-result (parser-fn parse-state)]
        (println "–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–∞—Ä—Å–∏–Ω–≥–∞:" parse-result)
        (println "–í–Ω–µ—à–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–æ—Å–ª–µ –ø–∞—Ä—Å–∏–Ω–≥–∞:")
        (println "  state:" state)
        (println "  result:" result)
        (println "–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å - –º–∞–∫—Ä–æ—Å –≥–∏–≥–∏–µ–Ω–∏—á–µ–Ω!")))))

;; ============================================================================
;; –ó–ê–ü–£–°–ö –¢–ï–°–¢–û–í
;; ============================================================================

(defn run-all-tests
  "–ó–∞–ø—É—Å–∫–∞–µ—Ç –≤—Å–µ —Ç–µ—Å—Ç—ã"
  []
  (println "üß™ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –£–õ–£–ß–®–ï–ù–ù–û–ì–û –ü–ê–†–°–ï–†–ê")
  (println "=====================================")
  
  (test-simple-parser)
  (test-error-handling)
  (test-combinators)
  (test-transform-combinator)
  (test-hygiene)
  
  (println "\n‚úÖ –í—Å–µ —Ç–µ—Å—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã!"))

;; –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ñ–∞–π–ª–∞
(run-all-tests)
```

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å `do-parse` –≤—Å–µ –µ—â–µ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –î–∞–≤–∞–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏–º —Ç–µ—Å—Ç, —á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å, —á—Ç–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç:

–ù—É–∂–Ω–æ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å —Ñ–∞–π–ª —Å –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏–µ–º:

```clojure
(ns test-do-parse
```

```clojure
(ns test_do_parse
```

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å `do-parse` –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –î–∞–≤–∞–π—Ç–µ —Å–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä–∏–º, –∫–∞–∫ –æ–Ω —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è:

–î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –ø—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–∞–∫—Ä–æ—Å–∞:

```clojure
(require '[c51cc.parser :as parser])
(require '[c51cc.lexer :as lexer])

;; –ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç –º–∞–∫—Ä–æ—Å–∞ do-parse
(println "–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞–∫—Ä–æ—Å–∞ do-parse...")

;; –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–µ—Ä —Å do-parse
(def simple-parser
  (parser/do-parse
    x (parser/expect-token :number)
    _ (parser/expect-token-value :plus)
    y (parser/expect-token :number)
    (parser/return-parser (+ (:value x) (:value y)))))

;; –¢–µ—Å—Ç–∏—Ä—É–µ–º
(let [tokens (lexer/tokenize "42 + 24")
      state (parser/parse-state tokens)
      result (simple-parser state)]
  (println "–¢–æ–∫–µ–Ω—ã:" tokens)
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result))

(println "–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω.")
```

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å `do-parse` –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º –µ–≥–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é. –ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –æ–Ω –Ω–µ —Å–æ–∑–¥–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–∞—Ä—Å–µ—Ä–∞. –î–∞–≤–∞–π—Ç–µ –ø–µ—Ä–µ–ø–∏—Å–∞—Ç—å –µ–≥–æ —Å –Ω—É–ª—è:

---

**User**

–µ–≥–æ —Ç–æ—á–Ω–æ –Ω–∞–¥–æ –ø–µ—Ä–µ–ø–∏—Å—ã–≤–∞—Ç—å? –¢–æ–ª—å–∫–æ-—Ç–æ–ª—å–∫–æ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫—É—é —á—Ç–æ-—Ç–æ —Ç–∞–º –ø–æ–ª—É—á–∏–ª–∏

---

**Cursor**

–í—ã –ø—Ä–∞–≤—ã! –ú–∞–∫—Ä–æ—Å `do-parse` —É–∂–µ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏ —á–∏—Å—Ç—ã–π, –ø—Ä–æ–±–ª–µ–º–∞ –Ω–µ –≤ –Ω–µ–º —Å–∞–º–æ–º, –∞ –≤ —Ç–æ–º, —á—Ç–æ –ª–∏–Ω—Ç–µ—Ä –Ω–µ –ø–æ–Ω–∏–º–∞–µ—Ç, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –±—É–¥—É—Ç —Å–≤—è–∑–∞–Ω—ã –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∞–∫—Ä–æ—Å–∞. –≠—Ç–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –¥–ª—è –º–∞–∫—Ä–æ—Å–æ–≤ –≤ Clojure.

–î–∞–≤–∞–π—Ç–µ –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –∑–∞–ø—É—Å—Ç–∏–≤ –ø—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç:

–ù—É–∂–Ω–æ –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å —Ñ–∞–π–ª –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é:

–§–∞–π–ª —É–∂–µ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏. –î–∞–≤–∞–π—Ç–µ –ø—Ä–æ—Å—Ç–æ –∑–∞–ø—É—Å—Ç–∏–º —Ç–µ—Å—Ç:

–ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å namespace –≤ —Ñ–∞–π–ª:

```clojure
(ns simple_test
  (:require [c51cc.parser :as parser]
            [c51cc.lexer :as lexer]))

(println "=== –¢–µ—Å—Ç –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–æ–≥–æ –º–∞–∫—Ä–æ—Å–∞ do-parse ===")

;; –¢–µ—Å—Ç 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞–∫—Ä–æ—ç–∫—Å–ø–∞–Ω—Å–∏–∏
(println "\n1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞–∫—Ä–æ—ç–∫—Å–ø–∞–Ω—Å–∏–∏:")
(try
  (let [expanded (macroexpand '(parser/do-parse 
                                 x (parser/expect-token :int)
                                 y (parser/expect-token :identifier)
                                 (parser/return-parser [x y])))]
    (println "‚úÖ –ú–∞–∫—Ä–æ—ç–∫—Å–ø–∞–Ω—Å–∏—è –ø—Ä–æ—à–ª–∞ —É—Å–ø–µ—à–Ω–æ")
    (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" (take 50 (str expanded))))
  (catch Exception e
    (println "‚ùå –û—à–∏–±–∫–∞ –º–∞–∫—Ä–æ—ç–∫—Å–ø–∞–Ω—Å–∏–∏:" (.getMessage e))))

;; –¢–µ—Å—Ç 2: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞—â–∏—Ç—ã –æ—Ç –∑–∞—Ö–≤–∞—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
(println "\n2. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞—â–∏—Ç—ã –æ—Ç –∑–∞—Ö–≤–∞—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö:")
(try
  (macroexpand '(parser/do-parse 
                  state (parser/expect-token :int)
                  (parser/return-parser state)))
  (println "‚ùå –ó–∞—â–∏—Ç–∞ –æ—Ç –∑–∞—Ö–≤–∞—Ç–∞ 'state' –ù–ï —Ä–∞–±–æ—Ç–∞–µ—Ç")
  (catch Exception e
    (println "‚úÖ –ó–∞—â–∏—Ç–∞ –æ—Ç –∑–∞—Ö–≤–∞—Ç–∞ 'state' —Ä–∞–±–æ—Ç–∞–µ—Ç:" (.getMessage e))))

;; –¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —á–µ—Ç–Ω–æ—Å—Ç–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
(println "\n3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ —á–µ—Ç–Ω–æ—Å—Ç–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤:")
(try
  (macroexpand '(parser/do-parse 
                  x (parser/expect-token :int)
                  (parser/return-parser x)
                  extra-arg))
  (println "‚ùå –í–∞–ª–∏–¥–∞—Ü–∏—è —á–µ—Ç–Ω–æ—Å—Ç–∏ –ù–ï —Ä–∞–±–æ—Ç–∞–µ—Ç")
  (catch Exception e
    (println "‚úÖ –í–∞–ª–∏–¥–∞—Ü–∏—è —á–µ—Ç–Ω–æ—Å—Ç–∏ —Ä–∞–±–æ—Ç–∞–µ—Ç:" (.getMessage e))))

;; –¢–µ—Å—Ç 4: –ë–∞–∑–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
(println "\n4. –¢–µ—Å—Ç –±–∞–∑–æ–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏:")
(try
  (let [tokens (lexer/tokenize "int x;")
        initial-state (parser/parse-state tokens)
        parser-fn (parser/do-parse 
                    dummy1 (parser/expect-token :int)
                    dummy2 (parser/expect-token :identifier)
                    (parser/return-parser :success))
        result (parser-fn initial-state)]
    (println "–†–µ–∑—É–ª—å—Ç–∞—Ç –ø–∞—Ä—Å–∏–Ω–≥–∞:" result)
    (if (:success? result)
      (println "‚úÖ –ë–∞–∑–æ–≤—ã–π —Ç–µ—Å—Ç –ø—Ä–æ—à–µ–ª —É—Å–ø–µ—à–Ω–æ")
      (println "‚ùå –ë–∞–∑–æ–≤—ã–π —Ç–µ—Å—Ç –ø—Ä–æ–≤–∞–ª–∏–ª—Å—è")))
  (catch Exception e
    (println "‚ùå –û—à–∏–±–∫–∞ –≤ –±–∞–∑–æ–≤–æ–º —Ç–µ—Å—Ç–µ:" (.getMessage e))))

;; –ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç –º–∞–∫—Ä–æ—Å–∞ do-parse
(println "\n–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –º–∞–∫—Ä–æ—Å–∞ do-parse...")

;; –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–µ—Ä —Å do-parse
(def simple-parser
  (parser/do-parse
    x (parser/expect-token :number)
    _ (parser/expect-token-value :plus)
    y (parser/expect-token :number)
    (parser/return-parser (+ (:value x) (:value y)))))

;; –¢–µ—Å—Ç–∏—Ä—É–µ–º
(let [tokens (lexer/tokenize "42 + 24")
      state (parser/parse-state tokens)
      result (simple-parser state)]
  (println "–¢–æ–∫–µ–Ω—ã:" tokens)
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result))

(println "–¢–µ—Å—Ç –∑–∞–≤–µ—Ä—à–µ–Ω.")

(println "\n=== –¢–µ—Å—Ç—ã –∑–∞–≤–µ—Ä—à–µ–Ω—ã ===")
```

–¢–µ–ø–µ—Ä—å –∑–∞–ø—É—Å—Ç–∏–º —Ç–µ—Å—Ç:

–ù—É–∂–Ω–æ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å —Ñ–∞–π–ª:

–î–∞–≤–∞–π—Ç–µ –ø—Ä–æ—Å—Ç–æ –∑–∞–ø—É—Å—Ç–∏–º —Ñ–∞–π–ª –Ω–∞–ø—Ä—è–º—É—é —á–µ—Ä–µ–∑ REPL:

---

**User**

–ø—Ä—è–º–æ–π –∑–∞–ø—É—Å–∫ —ç—Ç–æ clojure -M <foo.clj> 
–†–∞–∑–≤–µ –Ω–µ—Ç?

---

**Cursor**

–î–∞, –≤—ã –ø—Ä–∞–≤—ã! –î–∞–≤–∞–π—Ç–µ –∑–∞–ø—É—Å—Ç–∏–º —Ñ–∞–π–ª –Ω–∞–ø—Ä—è–º—É—é:

–ù—É–∂–Ω–æ –ø–µ—Ä–µ–π—Ç–∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é:

–û—Ç–ª–∏—á–Ω–æ! –ú–∞–∫—Ä–æ—Å —Ä–∞–±–æ—Ç–∞–µ—Ç —á–∞—Å—Ç–∏—á–Ω–æ:

1. ‚úÖ **–ú–∞–∫—Ä–æ—ç–∫—Å–ø–∞–Ω—Å–∏—è —Ä–∞–±–æ—Ç–∞–µ—Ç**
2. ‚úÖ **–ó–∞—â–∏—Ç–∞ –æ—Ç –∑–∞—Ö–≤–∞—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ä–∞–±–æ—Ç–∞–µ—Ç** - –º–∞–∫—Ä–æ—Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç –æ—à–∏–±–∫—É –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–∞–ø—Ä–µ—â–µ–Ω–Ω–æ–µ –∏–º—è `state`
3. ‚úÖ **–í–∞–ª–∏–¥–∞—Ü–∏—è —á–µ—Ç–Ω–æ—Å—Ç–∏ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ —Ä–∞–±–æ—Ç–∞–µ—Ç** - –º–∞–∫—Ä–æ—Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –æ–∂–∏–¥–∞–µ—Ç –∞—Ä–≥—É–º–µ–Ω—Ç `state`, –Ω–æ –º—ã –≤—ã–∑—ã–≤–∞–µ–º –µ—ë –±–µ–∑ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –º–∞–∫—Ä–æ—Å —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ, –Ω–æ –Ω—É–∂–Ω–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å —Å–ø–æ—Å–æ–± –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.

–î–∞–≤–∞–π—Ç–µ —Å–æ–∑–¥–∞–¥–∏–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ç–µ—Å—Ç:

```clojure
(ns working-test
  (:require [c51cc.parser :as parser]
            [c51cc.lexer :as lexer]))

(println "üß™ –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –†–ê–ë–û–¢–ê–Æ–©–ï–ì–û –ú–ê–ö–†–û–°–ê do-parse")
(println "===========================================")

;; –¢–µ—Å—Ç 1: –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–µ—Ä —Å do-parse
(println "\n1. –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä—Å–µ—Ä —á–∏—Å–ª–∞:")
(let [tokens (lexer/tokenize "42")
      state (parser/parse-state tokens)
      number-parser (parser/do-parse
                      num (parser/expect-token :number)
                      (parser/return-parser (:value num)))
      result (number-parser state)]
  (println "–¢–æ–∫–µ–Ω—ã:" tokens)
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
  (when (:success? result)
    (println "‚úÖ –£—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–∏–ª–∏ —á–∏—Å–ª–æ:" (:value result))))

;; –¢–µ—Å—Ç 2: –ü–∞—Ä—Å–µ—Ä —Å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
(println "\n2. –ü–∞—Ä—Å–µ—Ä —Å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º (—Å–∏–º–≤–æ–ª _):")
(let [tokens (lexer/tokenize "int x;")
      state (parser/parse-state tokens)
      var-parser (parser/do-parse
                   type-spec parser/parse-type-specifier
                   name (parser/expect-token :identifier)
                   _ (parser/expect-token-value :semicolon)
                   (parser/return-parser 
                     {:type (:base-type type-spec)
                      :name (:value name)}))
      result (var-parser state)]
  (println "–¢–æ–∫–µ–Ω—ã:" tokens)
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
  (when (:success? result)
    (println "‚úÖ –£—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–∏–ª–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ:" (:value result))))

;; –¢–µ—Å—Ç 3: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–æ–≤—ã—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤
(println "\n3. –¢–µ—Å—Ç –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞ parenthesized:")
(let [tokens (lexer/tokenize "(42)")
      state (parser/parse-state tokens)
      paren-parser (parser/parenthesized parser/parse-expression)
      result (paren-parser state)]
  (println "–¢–æ–∫–µ–Ω—ã:" tokens)
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
  (when (:success? result)
    (println "‚úÖ –£—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–∏–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –≤ —Å–∫–æ–±–∫–∞—Ö")))

;; –¢–µ—Å—Ç 4: –ö–æ–º–±–∏–Ω–∞—Ç–æ—Ä transform
(println "\n4. –¢–µ—Å—Ç –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–∞ transform:")
(let [tokens (lexer/tokenize "42")
      state (parser/parse-state tokens)
      double-parser (parser/transform 
                      parser/parse-expression
                      (fn [expr]
                        (if (= (:ast-type expr) :literal)
                          (assoc expr :value (* 2 (:value expr)))
                          expr)))
      result (double-parser state)]
  (println "–¢–æ–∫–µ–Ω—ã:" tokens)
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
  (when (:success? result)
    (println "‚úÖ –£—Å–ø–µ—à–Ω–æ —Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–ª–∏:" (:value (:value result)))))

;; –¢–µ—Å—Ç 5: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
(println "\n5. –¢–µ—Å—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫:")
(let [tokens (lexer/tokenize "int")  ; –ù–µ–ø–æ–ª–Ω–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ
      state (parser/parse-state tokens)
      error-parser (parser/with-error-context
                     (parser/do-parse
                       type-spec parser/parse-type-specifier
                       name (parser/expect-token :identifier)
                       (parser/return-parser {:type type-spec :name name}))
                     "–û–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π")
      result (error-parser state)]
  (println "–¢–æ–∫–µ–Ω—ã:" tokens)
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
  (when-not (:success? result)
    (println "‚úÖ –û—à–∏–±–∫–∞ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º:" (:error result))))

;; –¢–µ—Å—Ç 6: –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ —Å–ª–æ–∂–Ω–æ–≥–æ –ø–∞—Ä—Å–µ—Ä–∞
(println "\n6. –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ parse-while-statement —Å do-parse:")
(let [tokens (lexer/tokenize "while (x) { }")
      state (parser/parse-state tokens)
      while-parser (parser/do-parse
                     _ (parser/expect-token-value :while)
                     _ (parser/expect-token-value :open-round)
                     condition parser/parse-expression
                     _ (parser/expect-token-value :close-round)
                     body parser/parse-statement
                     (parser/return-parser 
                       (parser/while-statement-node condition body)))
      result (while-parser state)]
  (println "–¢–æ–∫–µ–Ω—ã:" tokens)
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:" result)
  (when (:success? result)
    (println "‚úÖ –£—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–∞—Ä—Å–∏–ª–∏ while —Å do-parse")))

(println "\nüéâ –í–°–ï –¢–ï–°–¢–´ –ó–ê–í–ï–†–®–ï–ù–´!")
(println "–ú–∞–∫—Ä–æ—Å do-parse —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –∏ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏ —á–∏—Å—Ç!")
```

–¢–µ–ø–µ—Ä—å –∑–∞–ø—É—Å—Ç–∏–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ç–µ—Å—Ç:

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ `return-parser` —Ç–æ–∂–µ –æ–∂–∏–¥–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –µ–≥–æ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é –∏ –∏—Å–ø—Ä–∞–≤–∏–º:

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç `return-parser`. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ:

```clojure
    ;; –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–æ–≥–æ –∫–æ–¥–∞
    (letfn [(build-parser-chain [pairs final-expr]
              (if (empty? pairs)
                ;; –§–∏–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ - –ø—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ–Ω–æ —É–∂–µ –ø–∞—Ä—Å–µ—Ä–æ–º
                (if (and (list? final-expr) 
                         (or (= (first final-expr) 'return-parser)
                             (= (first final-expr) 'parser/return-parser)))
                  ;; –£–∂–µ –ø–∞—Ä—Å–µ—Ä - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ –µ—Å—Ç—å
                  final-expr
                  ;; –ù–µ –ø–∞—Ä—Å–µ—Ä - –æ–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ return-parser
                  `(return-parser ~final-expr))
                (let [[binding expr] (first pairs)
                      remaining-pairs (rest pairs)
                      ;; –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è
                      state-sym (gensym "parser-state")
                      result-sym (gensym "parse-result")]
                  (if (and (symbol? binding) (not= binding '_))
                    ;; –°–≤—è–∑—ã–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           (let [~binding (:value ~result-sym)
                                 next-state# (:state ~result-sym)]
                             ((~(build-parser-chain remaining-pairs final-expr)) next-state#))
                           ~result-sym)))
                    ;; –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (binding —ç—Ç–æ _ –∏–ª–∏ –Ω–µ —Å–∏–º–≤–æ–ª)
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           ((~(build-parser-chain remaining-pairs final-expr)) (:state ~result-sym))
                           ~result-sym)))))))]
```

–¢–µ–ø–µ—Ä—å –∑–∞–ø—É—Å—Ç–∏–º —Ç–µ—Å—Ç —Å–Ω–æ–≤–∞:

–ü—Ä–æ–±–ª–µ–º–∞ –≤—Å–µ –µ—â–µ –µ—Å—Ç—å. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ –∏–º–µ–Ω–Ω–æ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –º–∞–∫—Ä–æ—Å:

```clojure
(ns debug-macro
  (:require [c51cc.parser :as parser]))

(println "–û—Ç–ª–∞–¥–∫–∞ –º–∞–∫—Ä–æ—Å–∞ do-parse")

;; –ü–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –ø—Ä–æ—Å—Ç–æ–π —Å–ª—É—á–∞–π
(println "\n–ú–∞–∫—Ä–æ—ç–∫—Å–ø–∞–Ω—Å–∏—è –ø—Ä–æ—Å—Ç–æ–≥–æ —Å–ª—É—á–∞—è:")
(let [expanded (macroexpand-1 '(parser/do-parse
                                 num (parser/expect-token :number)
                                 (parser/return-parser (:value num))))]
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:")
  (clojure.pprint/pprint expanded))

;; –ü–æ—Å–º–æ—Ç—Ä–∏–º –ø–æ–ª–Ω—É—é —ç–∫—Å–ø–∞–Ω—Å–∏—é
(println "\n–ü–æ–ª–Ω–∞—è –º–∞–∫—Ä–æ—ç–∫—Å–ø–∞–Ω—Å–∏—è:")
(let [expanded (macroexpand '(parser/do-parse
                               num (parser/expect-token :number)
                               (parser/return-parser (:value num))))]
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:")
  (clojure.pprint/pprint expanded))
```

```clojure
(ns debug-macro
  (:require [c51cc.parser :as parser]
            [clojure.pprint :as pprint]))

(println "–û—Ç–ª–∞–¥–∫–∞ –º–∞–∫—Ä–æ—Å–∞ do-parse")

;; –ü–æ—Å–º–æ—Ç—Ä–∏–º, –∫–∞–∫ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –ø—Ä–æ—Å—Ç–æ–π —Å–ª—É—á–∞–π
(println "\n–ú–∞–∫—Ä–æ—ç–∫—Å–ø–∞–Ω—Å–∏—è –ø—Ä–æ—Å—Ç–æ–≥–æ —Å–ª—É—á–∞—è:")
(let [expanded (macroexpand-1 '(parser/do-parse
                                 num (parser/expect-token :number)
                                 (parser/return-parser (:value num))))]
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:")
  (pprint/pprint expanded))

;; –ü–æ—Å–º–æ—Ç—Ä–∏–º –ø–æ–ª–Ω—É—é —ç–∫—Å–ø–∞–Ω—Å–∏—é
(println "\n–ü–æ–ª–Ω–∞—è –º–∞–∫—Ä–æ—ç–∫—Å–ø–∞–Ω—Å–∏—è:")
(let [expanded (macroexpand '(parser/do-parse
                               num (parser/expect-token :number)
                               (parser/return-parser (:value num))))]
  (println "–†–µ–∑—É–ª—å—Ç–∞—Ç:")
  (pprint/pprint expanded))
```

–¢–µ–ø–µ—Ä—å —è –≤–∏–∂—É –ø—Ä–æ–±–ª–µ–º—É! –ú–∞–∫—Ä–æ—Å –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç `(((parser/return-parser (:value num))) next-state__270__auto__)` - –æ–Ω –ø—ã—Ç–∞–µ—Ç—Å—è –≤—ã–∑–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç `return-parser` –∫–∞–∫ —Ñ—É–Ω–∫—Ü–∏—é —Å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–º–∏ —Å–∫–æ–±–∫–∞–º–∏.

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Ç–æ–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å –¥–æ–±–∞–≤–ª—è–µ—Ç –ª–∏—à–Ω–∏–µ —Å–∫–æ–±–∫–∏ –≤–æ–∫—Ä—É–≥ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ:

```clojure
                  (if (and (symbol? binding) (not= binding '_))
                    ;; –°–≤—è–∑—ã–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           (let [~binding (:value ~result-sym)
                                 next-state# (:state ~result-sym)]
                             (~(build-parser-chain remaining-pairs final-expr) next-state#))
                           ~result-sym)))
                    ;; –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (binding —ç—Ç–æ _ –∏–ª–∏ –Ω–µ —Å–∏–º–≤–æ–ª)
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           (~(build-parser-chain remaining-pairs final-expr) (:state ~result-sym))
                           ~result-sym))))))]
```

–ï—Å—Ç—å –ø—Ä–æ–±–ª–µ–º–∞ —Å–æ —Å–∫–æ–±–∫–∞–º–∏. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º:

```clojure
                  (if (and (symbol? binding) (not= binding '_))
                    ;; –°–≤—è–∑—ã–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           (let [~binding (:value ~result-sym)
                                 next-state# (:state ~result-sym)]
                             (~(build-parser-chain remaining-pairs final-expr) next-state#))
                           ~result-sym)))
                    ;; –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (binding —ç—Ç–æ _ –∏–ª–∏ –Ω–µ —Å–∏–º–≤–æ–ª)
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           (~(build-parser-chain remaining-pairs final-expr) (:state ~result-sym))
                           ~result-sym)))))))]
```

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–µ–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –º–∞–∫—Ä–æ—Å:

–ï—Å—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Å—Ç—Ä–æ–∫—É 107:

–ü—Ä–æ–±–ª–µ–º–∞ –≤ —Å—Ç—Ä–æ–∫–µ 107. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –≤–µ—Å—å –º–∞–∫—Ä–æ—Å:

–Ø –≤–∏–∂—É –ø—Ä–æ–±–ª–µ–º—É! –í —Å—Ç—Ä–æ–∫–µ 107 –µ—Å—Ç—å –ª–∏—à–Ω—è—è –∑–∞–∫—Ä—ã–≤–∞—é—â–∞—è —Å–∫–æ–±–∫–∞. –î–∞–≤–∞–π—Ç–µ –∏—Å–ø—Ä–∞–≤–∏–º —ç—Ç–æ:

```clojure
                    ;; –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (binding —ç—Ç–æ _ –∏–ª–∏ –Ω–µ —Å–∏–º–≤–æ–ª)
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           (~(build-parser-chain remaining-pairs final-expr) (:state ~result-sym))
                           ~result-sym)))))]
      
      (build-parser-chain binding-pairs final-expr))))
```

–í—Å–µ –µ—â–µ –µ—Å—Ç—å –ø—Ä–æ–±–ª–µ–º–∞. –î–∞–≤–∞–π—Ç–µ –ø–æ—Å–º–æ—Ç—Ä–∏–º –Ω–∞ –≤–µ—Å—å –º–∞–∫—Ä–æ—Å –∏ –∏—Å–ø—Ä–∞–≤–∏–º –µ–≥–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é:

```clojure
;; –ú–∞–∫—Ä–æ—Å –¥–ª—è —É–¥–æ–±–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ (–ì–ò–ì–ò–ï–ù–ò–ß–ï–°–ö–ê–Ø –í–ï–†–°–ò–Ø)
(defmacro do-parse 
  "–ì–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏–π –º–∞–∫—Ä–æ—Å –¥–ª—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–π –∫–æ–º–ø–æ–∑–∏—Ü–∏–∏ –ø–∞—Ä—Å–µ—Ä–æ–≤ –≤ —Å—Ç–∏–ª–µ do-notation
   –û–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –ø–æ–ª–Ω—É—é –∑–∞—â–∏—Ç—É –æ—Ç –∑–∞—Ö–≤–∞—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –≤–∞–ª–∏–¥–∞—Ü–∏—é –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
   –°–∏–º–≤–æ–ª _ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–∞—Ä—Å–∏–Ω–≥–∞"
  [& bindings]
  ;; –í–∞–ª–∏–¥–∞—Ü–∏—è –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö - –ø–æ—Å–ª–µ–¥–Ω–∏–π —ç–ª–µ–º–µ–Ω—Ç –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º
  (when (even? (count bindings))
    (throw (ex-info "do-parse —Ç—Ä–µ–±—É–µ—Ç –Ω–µ—á–µ—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤: –ø–∞—Ä—ã binding-expression + —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ" 
                   {:bindings bindings
                    :count (count bindings)})))
  
  ;; –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ –ø–∞—Ä—ã –∏ —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
  (let [all-args (vec bindings)
        final-expr (last all-args)
        binding-pairs (partition 2 (butlast all-args))
        forbidden-names #{'state 'state# 'result 'result# 'parser-state 'parse-result}]
    
    ;; –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–ø—Ä–µ—â–µ–Ω–Ω—ã–µ –∏–º–µ–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö (–∫—Ä–æ–º–µ _)
    (doseq [[binding _] binding-pairs]
      (when (and (symbol? binding) 
                 (not= binding '_)
                 (forbidden-names binding))
        (throw (ex-info "–ó–∞–ø—Ä–µ—â–µ–Ω–Ω–æ–µ –∏–º—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –≤ do-parse - –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å –∑–∞—Ö–≤–∞—Ç –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö" 
                       {:forbidden-binding binding
                        :forbidden-names forbidden-names}))))
    
    ;; –†–µ–∫—É—Ä—Å–∏–≤–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–æ–≥–æ –∫–æ–¥–∞
    (letfn [(build-parser-chain [pairs final-expr]
              (if (empty? pairs)
                ;; –§–∏–Ω–∞–ª—å–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ - –ø—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ–Ω–æ —É–∂–µ –ø–∞—Ä—Å–µ—Ä–æ–º
                (if (and (list? final-expr) 
                         (or (= (first final-expr) 'return-parser)
                             (= (first final-expr) 'parser/return-parser)))
                  ;; –£–∂–µ –ø–∞—Ä—Å–µ—Ä - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ –µ—Å—Ç—å
                  final-expr
                  ;; –ù–µ –ø–∞—Ä—Å–µ—Ä - –æ–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ return-parser
                  `(return-parser ~final-expr))
                (let [[binding expr] (first pairs)
                      remaining-pairs (rest pairs)
                      ;; –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Å–∏–º–≤–æ–ª—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —É—Ä–æ–≤–Ω—è
                      state-sym (gensym "parser-state")
                      result-sym (gensym "parse-result")]
                  (if (and (symbol? binding) (not= binding '_))
                    ;; –°–≤—è–∑—ã–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           (let [~binding (:value ~result-sym)
                                 next-state# (:state ~result-sym)]
                             (~(build-parser-chain remaining-pairs final-expr) next-state#))
                           ~result-sym)))
                    ;; –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (binding —ç—Ç–æ _ –∏–ª–∏ –Ω–µ —Å–∏–º–≤–æ–ª)
                    `(fn [~state-sym]
                       (let [~result-sym (~expr ~state-sym)]
                         (if (:success? ~result-sym)
                           (~(build-parser-chain remaining-pairs final-expr) (:state ~result-sym))
                           ~result-sym)))))))]
      
      (build-parser-chain binding-pairs final-expr))))
```

–¢–µ–ø–µ—Ä—å –ø—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ –º–∞–∫—Ä–æ—Å —Ä–∞–±–æ—Ç–∞–µ—Ç:

–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –º–∞–∫—Ä–æ—Å —Ä–∞–±–æ—Ç–∞–µ—Ç –ø—Ä–∞–≤–∏–ª—å–Ω–æ. –í–∏–¥–Ω–æ, —á—Ç–æ –æ–Ω –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç `((parser/return-parser (:value num)) next-state__270__auto__)` - —ç—Ç–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ, –ø–æ—Ç–æ–º—É —á—Ç–æ `return-parser` –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä—É—é –Ω—É–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å —Å —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º.

–¢–µ–ø–µ—Ä—å –¥–∞–≤–∞–π—Ç–µ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä—É–µ–º —Ä–∞–±–æ—á–∏–π –ø—Ä–∏–º–µ—Ä:

üéâ **–û–¢–õ–ò–ß–ù–û!** –ú–∞–∫—Ä–æ—Å `do-parse` —Ç–µ–ø–µ—Ä—å —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ! –î–∞–≤–∞–π—Ç–µ –ø–æ–¥–≤–µ–¥–µ–º –∏—Ç–æ–≥–∏ —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞:

## ‚úÖ –ò–¢–û–ì–ò –†–ï–§–ê–ö–¢–û–†–ò–ù–ì–ê –ü–ê–†–°–ï–†–ê

### 1. **–ò—Å–ø—Ä–∞–≤–ª–µ–Ω –≥–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∏–π –º–∞–∫—Ä–æ—Å `do-parse`**
- ‚úÖ **–ì–∏–≥–∏–µ–Ω–∏—á–µ—Å–∫–∞—è —á–∏—Å—Ç–æ—Ç–∞**: –ú–∞–∫—Ä–æ—Å –∑–∞—â–∏—â–µ–Ω –æ—Ç –∑–∞—Ö–≤–∞—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö
- ‚úÖ **–ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Å–∏–º–≤–æ–ª–∞ `_`**: –ü—Ä–∞–≤–∏–ª—å–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–∞—Ä—Å–∏–Ω–≥–∞
- ‚úÖ **–í–∞–ª–∏–¥–∞—Ü–∏—è –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤**: –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —á–µ—Ç–Ω–æ—Å—Ç—å –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
- ‚úÖ **–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–¥–∞**: –£–±—Ä–∞–Ω—ã –ª–∏—à–Ω–∏–µ —Å–∫–æ–±–∫–∏

### 2. **–°–æ–∑–¥–∞–Ω–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤ –≤—ã—Å—à–µ–≥–æ –ø–æ—Ä—è–¥–∫–∞**
- ‚úÖ **`>>`**: –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è —Å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º –ø–µ—Ä–≤–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
- ‚úÖ **`<<`**: –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–∞—è –∫–æ–º–ø–æ–∑–∏—Ü–∏—è —Å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ–º –≤—Ç–æ—Ä–æ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞  
- ‚úÖ **`between`**: –ü–∞—Ä—Å–∏–Ω–≥ –º–µ–∂–¥—É –¥–≤—É–º—è –ø–∞—Ä—Å–µ—Ä–∞–º–∏
- ‚úÖ **`separated-by`**: –ü–∞—Ä—Å–∏–Ω–≥ —Å–ø–∏—Å–∫–æ–≤ —Å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏
- ‚úÖ **`transform`**: –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–∞—Ä—Å–∏–Ω–≥–∞
- ‚úÖ **`with-error-context`**: –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

### 3. **–°–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã –¥–ª—è C-—Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞**
- ‚úÖ **`parenthesized`**: –í—ã—Ä–∞–∂–µ–Ω–∏—è –≤ –∫—Ä—É–≥–ª—ã—Ö —Å–∫–æ–±–∫–∞—Ö
- ‚úÖ **`braced`**: –ë–ª–æ–∫–∏ –≤ —Ñ–∏–≥—É—Ä–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö
- ‚úÖ **`bracketed`**: –í—ã—Ä–∞–∂–µ–Ω–∏—è –≤ –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã—Ö —Å–∫–æ–±–∫–∞—Ö
- ‚úÖ **`comma-separated`**: –°–ø–∏—Å–∫–∏ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é
- ‚úÖ **`semicolon-terminated`**: –í—ã—Ä–∞–∂–µ–Ω–∏—è —Å —Ç–æ—á–∫–æ–π —Å –∑–∞–ø—è—Ç–æ–π

### 4. **–£—Å–ø–µ—à–Ω—ã–µ —Ç–µ—Å—Ç—ã –ø–æ–∫–∞–∑–∞–ª–∏**
- ‚úÖ –ü–∞—Ä—Å–∏–Ω–≥ –ø—Ä–æ—Å—Ç—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π —Å `do-parse`
- ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Å `_`
- ‚úÖ –†–∞–±–æ—Ç—É –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤ `parenthesized` –∏ `transform`
- ‚úÖ –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫
- ‚úÖ –†–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ —Å–ª–æ–∂–Ω—ã—Ö –ø–∞—Ä—Å–µ—Ä–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, `while`)

### 5. **–°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏ –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥–∞**
–¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ:
1. **–†–µ—Ñ–∞–∫—Ç–æ—Ä–∏—Ç—å —Å–∞–º—ã–µ —Å–ª–æ–∂–Ω—ã–µ –ø–∞—Ä—Å–µ—Ä—ã** –∏—Å–ø–æ–ª—å–∑—É—è `do-parse` –∏ –Ω–æ–≤—ã–µ –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä—ã
2. **–î–æ–±–∞–≤–∏—Ç—å –±–æ–ª—å—à–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫** —Å `with-error-context`
3. **–£–ø—Ä–æ—Å—Ç–∏—Ç—å –ø–∞—Ä—Å–µ—Ä—ã –≤—ã—Ä–∞–∂–µ–Ω–∏–π** —Å –ø–æ–º–æ—â—å—é —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–æ–º–±–∏–Ω–∞—Ç–æ—Ä–æ–≤

**–ú–∞–∫—Ä–æ—Å `do-parse` —Ç–µ–ø–µ—Ä—å –ø–æ–ª–Ω–æ—Å—Ç—å—é —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é!** üöÄ

–•–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Ä–µ—Ñ–∞–∫—Ç–æ—Ä–∏–Ω–≥ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –ø–∞—Ä—Å–µ—Ä–æ–≤ –∏–ª–∏ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏?

