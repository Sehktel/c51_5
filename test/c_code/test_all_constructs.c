// Тестовый файл для парсера C51
// Демонстрирует все поддерживаемые конструкции

// Объявления SFR (Специальные функциональные регистры)
sfr P0 = 0x80;    // Порт 0
sfr P1 = 0x90;    // Порт 1
sfr P2 = 0xA0;    // Порт 2
sfr P3 = 0xB0;    // Порт 3
sfr PSW = 0xD0;   // Слово состояния программы
sfr ACC = 0xE0;   // Аккумулятор
sfr B = 0xF0;     // Регистр B
sfr SP = 0x81;    // Указатель стека
sfr DPL = 0x82;   // Младший байт указателя данных
sfr DPH = 0x83;   // Старший байт указателя данных

// Объявления SBIT (Битовые регистры)
sbit EA   = 0xAF; // Глобальное разрешение прерываний
sbit ET0  = 0xA9; // Разрешение прерывания от таймера 0
sbit ET1  = 0xAB; // Разрешение прерывания от таймера 1
sbit ES   = 0xAC; // Разрешение прерывания от UART
sbit CY   = 0xD7; // Флаг переноса
sbit AC   = 0xD6; // Флаг вспомогательного переноса
sbit F0   = 0xD5; // Флаг пользователя
sbit RS0  = 0xD3; // Выбор банка регистров бит 0
sbit RS1  = 0xD4; // Выбор банка регистров бит 1

// Глобальные переменные
unsigned int counter;
unsigned char status;
int data[10];
char message[20];

// Функция обработки прерывания от таймера 0
void timer0_isr(void) interrupt 1 using 1 {
    counter++;
    if (counter >= 1000) {
        counter = 0;
        P1 = ~P1;  // Инвертируем порт P1
    }
}

// Функция обработки прерывания от UART
void serial_isr(void) interrupt 4 {
    char received;
    received = SBUF;  // Читаем принятый байт
    status |= 0x01;   // Устанавливаем флаг приема
}

// Функция инициализации
void init_system(void) {
    // Инициализация переменных
    counter = 0;
    status = 0x00;
    
    // Инициализация портов
    P0 = 0xFF;
    P1 = 0x00;
    P2 = 0xFF;
    P3 = 0x00;
    
    // Настройка таймера
    TMOD = 0x20;  // Таймер 1 в режиме 2 (8-бит авто-перезагрузка)
    TH1 = 0xFD;   // Для скорости 9600 бод при 11.0592 МГц
    TR1 = 1;      // Запуск таймера 1
    
    // Настройка UART
    SCON = 0x50;  // Режим 1, прием разрешен
    
    // Разрешение прерываний
    EA = 1;   // Глобальное разрешение прерываний
    ET0 = 1;  // Разрешение прерывания от таймера 0
    ES = 1;   // Разрешение прерывания от UART
}

// Функция задержки
void delay(unsigned int ms) {
    unsigned int i, j;
    for (i = 0; i < ms; i++) {
        for (j = 0; j < 123; j++) {  // Подобрано для частоты 11.0592 МГц
            // Пустой цикл
        }
    }
}

// Функция обработки данных
int process_data(unsigned char *buffer, int length) {
    int i;
    int sum = 0;
    
    // Цикл while для обработки данных
    while (i < length) {
        sum += buffer[i];
        i++;
    }
    
    // Проверка результата
    if (sum > 1000) {
        return -1;
    } else if (sum > 500) {
        return 0;
    } else {
        return 1;
    }
}

// Основная функция
void main(void) {
    unsigned char buffer[16];
    int result;
    
    // Инициализация системы
    init_system();
    
    // Основной цикл
    while (1) {
        // Проверка статуса
        if (status & 0x01) {
            // Обработка принятых данных
            result = process_data(buffer, 16);
            
            switch (result) {
                case -1:
                    P2 = 0xFF;  // Все светодиоды включены
                    break;
                case 0:
                    P2 = 0xAA;  // Чередующийся паттерн
                    break;
                default:
                    P2 = 0x00;  // Все светодиоды выключены
                    break;
            }
            
            // Сброс флага
            status &= ~0x01;
        }
        
        // Задержка
        delay(100);
    }
} 