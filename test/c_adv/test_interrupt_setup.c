/*
 * Тест настройки прерываний в C51
 * Демонстрирует работу с внешними прерываниями и прерываниями таймеров
 * Соответствует стандарту C89
 */

#include "common.h"

/* Глобальные переменные для обработки прерываний */
unsigned char interrupt_counter = 0;
bit timer_interrupt_flag = 0;
bit external_interrupt_flag = 0;

/* Обработчик прерывания Timer0 */
void timer0_isr(void) interrupt 1 {
    /* Сброс флага переполнения таймера */
    TF0 = 0;
    
    /* Увеличение счетчика прерываний */
    interrupt_counter++;
    
    /* Установка флага */
    timer_interrupt_flag = 1;
    
    /* Индикация на порту */
    TOGGLE_BIT(P1, 0);
}

/* Обработчик внешнего прерывания INT0 */
void external_int0_isr(void) interrupt 0 {
    /* Сброс флага прерывания */
    IE0 = 0;
    
    /* Установка флага */
    external_interrupt_flag = 1;
    
    /* Индикация на порту */
    TOGGLE_BIT(P1, 1);
}

/* Инициализация системы прерываний */
void interrupt_system_init(void) {
    /* Запрет всех прерываний */
    EA = 0;
    
    /* Очистка всех флагов прерываний */
    TF0 = 0;
    TF1 = 0;
    IE0 = 0;
    IE1 = 0;
    
    /* Сброс счетчиков */
    interrupt_counter = 0;
    timer_interrupt_flag = 0;
    external_interrupt_flag = 0;
}

/* Настройка прерывания Timer0 */
void setup_timer0_interrupt(void) {
    /* Остановка таймера */
    TR0 = 0;
    
    /* Настройка режима таймера */
    TMOD &= 0xF0;  /* Очистка битов Timer0 */
    TMOD |= 0x01;  /* Режим 1: 16-битный таймер */
    
    /* Загрузка начального значения для переполнения через ~50мс при 12МГц */
    TH0 = 0x3C;    /* Старший байт */
    TL0 = 0xB0;    /* Младший байт */
    
    /* Разрешение прерывания Timer0 */
    ET0 = 1;
    
    /* Сброс флага */
    TF0 = 0;
    
    /* Запуск таймера */
    TR0 = 1;
}

/* Настройка внешнего прерывания INT0 */
void setup_external_int0(void) {
    /* Настройка типа прерывания INT0 по спаду */
    IT0 = 1;  /* Прерывание по фронту */
    
    /* Сброс флага прерывания */
    IE0 = 0;
    
    /* Разрешение прерывания INT0 */
    EX0 = 1;
}

/* Тест системы прерываний */
void test_interrupt_setup(void) {
    unsigned char test_timeout;
    
    /* Инициализация системы прерываний */
    interrupt_system_init();
    
    /* Настройка прерывания таймера */
    setup_timer0_interrupt();
    
    /* Разрешение глобальных прерываний */
    EA = 1;
    
    /* Ожидание срабатывания прерывания таймера */
    test_timeout = 0;
    while (!timer_interrupt_flag && test_timeout < 200) {
        test_timeout++;
        /* Простая задержка */
        {
            unsigned int delay;
            for (delay = 0; delay < 100; delay++) {
                /* Пустой цикл */
            }
        }
    }
    
    /* Проверка работы прерывания таймера */
    if (timer_interrupt_flag) {
        SET_BIT(P1, 2);  /* Прерывание таймера работает */
    }
    
    /* Настройка внешнего прерывания */
    setup_external_int0();
    
    /* Симуляция внешнего прерывания (программная установка флага) */
    IE0 = 1;  /* Программная установка флага INT0 */
    
    /* Небольшая задержка для обработки */
    {
        unsigned int delay;
        for (delay = 0; delay < 1000; delay++) {
            /* Пустой цикл */
        }
    }
    
    /* Проверка обработки внешнего прерывания */
    if (external_interrupt_flag) {
        SET_BIT(P1, 3);  /* Внешнее прерывание работает */
    }
}

/* Демонстрация приоритетов прерываний */
void interrupt_priority_demo(void) {
    /* Установка высокого приоритета для INT0 */
    PX0 = 1;  /* Высокий приоритет для внешнего прерывания 0 */
    
    /* Установка низкого приоритета для Timer0 */
    PT0 = 0;  /* Низкий приоритет для таймера 0 */
    
    /* Разрешение прерываний */
    EX0 = 1;  /* Внешнее прерывание 0 */
    ET0 = 1;  /* Прерывание таймера 0 */
    EA = 1;   /* Глобальное разрешение */
    
    /* Индикация настройки приоритетов */
    SET_BIT(P1, 4);
}

/* Тест маскирования прерываний */
void interrupt_mask_test(void) {
    /* Запрет всех прерываний */
    EA = 0;
    
    /* Установка флагов прерываний программно */
    TF0 = 1;
    IE0 = 1;
    
    /* Проверка, что прерывания не обрабатываются */
    {
        unsigned int delay;
        for (delay = 0; delay < 1000; delay++) {
            /* Пустой цикл */
        }
    }
    
    /* Если флаги остались установленными, маскирование работает */
    if (TF0 && IE0) {
        SET_BIT(P1, 5);  /* Маскирование работает */
    }
    
    /* Разрешение прерываний */
    EA = 1;
    
    /* Небольшая задержка для обработки */
    {
        unsigned int delay;
        for (delay = 0; delay < 1000; delay++) {
            /* Пустой цикл */
        }
    }
    
    /* Проверка обработки отложенных прерываний */
    if (!TF0 || !IE0) {
        SET_BIT(P1, 6);  /* Отложенные прерывания обработаны */
    }
} 